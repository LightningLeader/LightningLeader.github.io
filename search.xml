<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ROS中使用VLP16激光雷达获取点云数据</title>
      <link href="posts/25.html"/>
      <url>posts/25.html</url>
      
        <content type="html"><![CDATA[<h1 id="ROS中使用VLP16激光雷达获取点云数据"><a href="#ROS中使用VLP16激光雷达获取点云数据" class="headerlink" title="ROS中使用VLP16激光雷达获取点云数据"></a>ROS中使用VLP16激光雷达获取点云数据</h1><a id="more"></a><p>本文测试环境为：<strong>Ubuntu20.04</strong>    <strong>ROS Noetic</strong></p><hr><p>需要将激光雷达与PC连接，然后在设置=&gt;网络=&gt;有线中将IPv4改为手动，并且地址为<strong>192.168.1.100</strong>，子网掩码为<strong>255.255.255.0</strong>，点击应用。然后在浏览器输入192.168.1.201，如果成功进入配置界面则表示连接成功。</p><h2 id="安装VLP驱动"><a href="#安装VLP驱动" class="headerlink" title="安装VLP驱动"></a>安装VLP驱动</h2><pre class="line-numbers language-none"><code class="language-none">cd catkin_ws&#x2F;srcgit clone https:&#x2F;&#x2F;github.com&#x2F;ros-drivers&#x2F;velodyne.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>继续执行下面命令。如果在执行第二条命令的时候报错了，需要根据终端的提示安装一些包或者可以看看这篇文章<a href="https://zhuanlan.zhihu.com/p/546426618">点我</a></p><pre class="line-numbers language-none"><code class="language-none">cd ..rosdep install --from-paths src --ignore-src --rosdistro noetic -ycatkin_make<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>报错处理：</strong></p><p>如果<code>catkin_make</code>命令找不到，就需要看<a href="#%E5%AE%89%E8%A3%85ROS%E4%BE%9D%E8%B5%96">安装ROS依赖</a>最后source脚本部分有没有完成。</p><p>编译中间如果出现找不到文件的报错，大概率是没有安装对应的包。</p><p>例如出现“Could NOT find image_transport (missing: image_transport_DIR)”错误，那就需要在终端输入<code>sudo apt install ros-noetic-image-transport</code>.</p><p>如果遇到“Could NOT find PY_em (missing: PY_EM)”错误，就需要运行<code>catkin_make -DPYTHON_EXECUTABLE=/usr/bin/python3</code>。</p><p>报错参考文章：</p><p><a href="https://blog.csdn.net/tanmx219/article/details/122765853">ROS报错：– Could NOT find PY_em (missing: PY_EM)</a></p><p><a href="https://blog.csdn.net/weixin_44388819/article/details/119668822">ROS报错：Command ‘catkin_make‘ not found</a></p><p><a href="https://zhuanlan.zhihu.com/p/546426618">【ROS】解决rosdep无法更新、缺少依赖问题</a></p><h2 id="可视化测试"><a href="#可视化测试" class="headerlink" title="可视化测试"></a>可视化测试</h2><p>运行<code>rosrun</code>找不到命令的话，可以使用<code>sudo apt install ros-noetic-rosbash</code>安装。</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install ros-noetic-rviz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在终端输入下面命令，这个命令会一直运行，可以用Ctrl+C结束。要在<strong>catkin_velodyne</strong>目录下运行。</p><pre class="line-numbers language-none"><code class="language-none">roslaunch velodyne_pointcloud VLP16_points.launch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行后会出现一个窗口，将其左上角<em>Fixed Frame</em>的<em>map</em>修改为<em>velodyne</em>。如果是运行<code>rosrun rviz rviz -f velodyne</code>命令话就不用做这一步了。</p><p><img src="/posts/25/1.png"></p><p>再点击左下角的<em>Add</em>，在弹出的窗口中选择<em>By topic</em>，再选择<em>PointCloud2</em>，最后点击OK</p><p><img src="/posts/25/2.png"></p><p>之后就可以在右侧看到可视化点云了。</p><p><img src="/posts/25/3.png"></p><h2 id="录制和播放点云"><a href="#录制和播放点云" class="headerlink" title="录制和播放点云"></a>录制和播放点云</h2><p>在终端运行下面命令可以录制点云，点云记录会默认生成在运行目录。可以使用Crtl+C结束录制。</p><pre class="line-numbers language-none"><code class="language-none">rosbag record out &#x2F;velodyne_points<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在终端运行下面命令可以播放点云，第一个参数填写要播放的点云记录。可以在rviz中看到播放的结果。按空格键可以暂停播放。</p><pre class="line-numbers language-none"><code class="language-none">rosbag play 2023-03-28-22-49-58.bag<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是如果是在一直可视化显示点云的rviz下播放记录会出现重叠现象，看起来非常不舒服，因此最好是再重新开一个rviz窗口进行播放。</p><p>在终端输入<code>roscore</code>命令，然后再重新开一个终端输入<code>rosrun rviz rviz -f velodyne</code>命令。</p><p>点击左下角的<em>Add</em>，在弹出的窗口中选择<em>PointCloud2</em>，最后点击OK</p><p><img src="/posts/25/4.png"></p><p>点开左侧的<em>PointCloud2</em>，将<em>Topic</em>的内容改为*/velodyne_points*</p><p><img src="/posts/25/5.png"></p><p>之后在终端中输入播放命令<code>rosbag play 2023-03-28-22-49-58.bag</code>，就可以在该窗口的右侧看到播放画面了。</p><h2 id="将bag文件转化成pcd文件"><a href="#将bag文件转化成pcd文件" class="headerlink" title="将bag文件转化成pcd文件"></a>将bag文件转化成pcd文件</h2><p>录制点云会生成bag文件，可以将该文件记录的每一帧点云转换成pcd格式并保存下来。</p><p>首先在终端中输入<code>roscore</code>命令</p><p>再开启一个终端输入下面的命令。<em>output.bag</em>为要处理的bag文件；*pcd/*为最终pcd文件的输出目录</p><pre class="line-numbers language-none"><code class="language-none">rosrun pcl_ros bag_to_pcd output.bag &#x2F;velodyne_points pcd&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="python获取实时点云数据并保存成pcd文件"><a href="#python获取实时点云数据并保存成pcd文件" class="headerlink" title="python获取实时点云数据并保存成pcd文件"></a>python获取实时点云数据并保存成pcd文件</h2><p>使用python获取VLP16返回的实时点云数据，并把每一帧数据保存成pcd文件。下面介绍两种方式：</p><p><strong>方式一：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">#!&#x2F;usr&#x2F;bin&#x2F;env pythonimport rospyfrom sensor_msgs.msg import PointCloud2import sensor_msgs.point_cloud2 as pc2counts &#x3D; 0def callback(data):    global counts    counts +&#x3D; 1    gen &#x3D; pc2.read_points(data, skip_nans&#x3D;True)    cloud &#x3D; []    for p in gen:        # p是元组类型，代表一个点云数据，一共有6个元素，分别为x, y, z, intensity, ring, time        cloud.append([p[0], p[1], p[2]])    # pcd_name &#x3D; str(counts) + &quot;.pcd&quot;    with open(&#39;output.pcd&#39;, &#39;w&#39;) as f:        f.write(&#39;# .PCD v.7 - Point Cloud Data file format\n&#39;)        f.write(&#39;VERSION .7\n&#39;)        f.write(&#39;FIELDS x y z\n&#39;)        f.write(&#39;SIZE 4 4 4\n&#39;)        f.write(&#39;TYPE F F F\n&#39;)        f.write(&#39;COUNT 1 1 1\n&#39;)        f.write(&#39;WIDTH %d\n&#39; % len(cloud))        f.write(&#39;HEIGHT 1\n&#39;)        f.write(&#39;VIEWPOINT 0 0 0 1 0 0 0\n&#39;)        f.write(&#39;POINTS %d\n&#39; % len(cloud))        f.write(&#39;DATA ascii\n&#39;)        for p in cloud:            f.write(&#39;%f %f %f\n&#39; % (p[0], p[1], p[2]))    print(counts)def listener():    rospy.init_node(&#39;velodyne_listener&#39;, anonymous&#x3D;True)    rospy.Subscriber(&#39;&#x2F;velodyne_points&#39;, PointCloud2, callback)    rospy.spin()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    listener()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方式二：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import rospyfrom sensor_msgs.msg import PointCloud2import sensor_msgs.point_cloud2 as pc2counts &#x3D; 0def callback(data):    global counts    counts +&#x3D; 1    # cloud_list是列表类型，其存放着每个点云数据    # 每个点云数据是sensor_msgs.point_cloud2.Point类型，共有6个元素，分别为x, y, z, intensity, ring, time    cloud_list &#x3D; pc2.read_points_list(data, skip_nans&#x3D;True)    # pcd_name &#x3D; str(counts) + &quot;.pcd&quot;    with open(&#39;output_list.pcd&#39;, &#39;w&#39;) as f:        f.write(&#39;# .PCD v.7 - Point Cloud Data file format\n&#39;)        f.write(&#39;VERSION .7\n&#39;)        f.write(&#39;FIELDS x y z\n&#39;)        f.write(&#39;SIZE 4 4 4\n&#39;)        f.write(&#39;TYPE F F F\n&#39;)        f.write(&#39;COUNT 1 1 1\n&#39;)        f.write(&#39;WIDTH %d\n&#39; % len(cloud_list))        f.write(&#39;HEIGHT 1\n&#39;)        f.write(&#39;VIEWPOINT 0 0 0 1 0 0 0\n&#39;)        f.write(&#39;POINTS %d\n&#39; % len(cloud_list))        f.write(&#39;DATA ascii\n&#39;)        for i in range(len(cloud_list)):            f.write(&#39;%f %f %f\n&#39; % (cloud_list[i][0], cloud_list[i][1], cloud_list[i][2]))    print(counts)def listener():    rospy.init_node(&#39;velodyne_listener&#39;, anonymous&#x3D;True)    rospy.Subscriber(&#39;&#x2F;velodyne_points&#39;, PointCloud2, callback)    rospy.spin()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    listener()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="实时可视化激光雷达点云数据"><a href="#实时可视化激光雷达点云数据" class="headerlink" title="实时可视化激光雷达点云数据"></a>实时可视化激光雷达点云数据</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">from sensor_msgs.msg import PointCloud2import sensor_msgs.point_cloud2 as pc2import numpy as npimport open3d as o3dimport rospyimport cv2# 按下B结束运行def key_callback(vis):    global stop_flag    stop_flag &#x3D; True    print(&quot;Stop&quot;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    # 创建可视化窗口和点云    vis &#x3D; o3d.visualization.VisualizerWithKeyCallback()    vis.create_window(width&#x3D;1080, height&#x3D;720)    vis_render &#x3D; vis.get_render_option()    vis_render.background_color &#x3D; (0, 0, 0)    vis.register_key_callback(ord(&#39;B&#39;), key_callback)    pcd &#x3D; o3d.geometry.PointCloud()    # 标记    add_flag &#x3D; False    # 首次vis.add标记    stop_flag &#x3D; False    # 停止标记    # 初始化ros节点    rospy.init_node(&#39;velodyne_listener&#39;, anonymous&#x3D;True)    while not stop_flag:              # 等待一次消息        data &#x3D; rospy.wait_for_message(&#39;&#x2F;velodyne_points&#39;, PointCloud2, timeout&#x3D;None)        gen &#x3D; pc2.read_points(data, skip_nans&#x3D;True)        cloud &#x3D; []        for p in gen:            cloud.append([p[0], p[1], p[2], p[3]])        points &#x3D; np.array(cloud).astype(np.float32)        # 提取xyz，暂时不需要强度        points_xyz &#x3D; points[:, :3]        pcd.points &#x3D; o3d.utility.Vector3dVector(points_xyz)        if not add_flag:            vis.add_geometry(pcd)            add_flag &#x3D; True        vis.update_geometry(pcd)        vis.poll_events()        vis.update_renderer()    vis.destroy_window()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里使用的是<code>rospy.wait_for_message</code>用于接收一次消息，该函数会返回接收到的消息。可以设置*timeout=rospy.Duration(1)*，代表超时时间为1秒钟。如果在1秒内没有收到消息，则函数会返回None。</p><p>如果使用<code>rospy.spin</code>的话，程序运行到这行代码就会卡死，不会往下执行其他代码，所以在实时可视化的时候不能使用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 三维点云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>open3d可视化点云</title>
      <link href="posts/24.html"/>
      <url>posts/24.html</url>
      
        <content type="html"><![CDATA[<h1 id="open3d可视化点云"><a href="#open3d可视化点云" class="headerlink" title="open3d可视化点云"></a>open3d可视化点云</h1><a id="more"></a><h2 id="将pcd文件转换成bin文件"><a href="#将pcd文件转换成bin文件" class="headerlink" title="将pcd文件转换成bin文件"></a>将pcd文件转换成bin文件</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">import open3d as o3dimport numpy as nppcd &#x3D; o3d.io.read_point_cloud(&quot;data&#x2F;output.pcd&quot;)points &#x3D; np.array(pcd.points)lidar &#x3D; []for linestr in points:    if len(linestr) &#x3D;&#x3D; 3:  # only x,y,z        linestr_convert &#x3D; list(map(float, linestr))        linestr_convert.append(0)        lidar.append(linestr_convert)    if len(linestr) &#x3D;&#x3D; 4:  # x,y,z,i        linestr_convert &#x3D; list(map(float, linestr))lidar &#x3D; np.array(lidar).astype(np.float32)lidar.tofile(&quot;666.bin&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="将pcd文件转化成npy文件"><a href="#将pcd文件转化成npy文件" class="headerlink" title="将pcd文件转化成npy文件"></a>将pcd文件转化成npy文件</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">import open3d as o3dimport numpy as nplidar &#x3D; []pcd &#x3D; o3d.io.read_point_cloud(&quot;data&#x2F;output.pcd&quot;)points &#x3D; np.array(pcd.points)for linestr in points:    if len(linestr) &#x3D;&#x3D; 3:  # only x,y,z        linestr_convert &#x3D; list(map(float, linestr))        linestr_convert.append(0)        lidar.append(linestr_convert)    if len(linestr) &#x3D;&#x3D; 4:  # x,y,z,i        linestr_convert &#x3D; list(map(float, linestr))lidar &#x3D; np.array(lidar).astype(np.float32)np.save(&quot;666.npy&quot;, lidar)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="同时显示多个可视化窗口"><a href="#同时显示多个可视化窗口" class="headerlink" title="同时显示多个可视化窗口"></a>同时显示多个可视化窗口</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 同时显示两个窗口，按ESC退出import open3d as o3dfrom pynput import keyboard    # 加载pynput用于键盘监听# 当键盘按下时的回调函数def on_press(key):    global stop_flag    if key &#x3D;&#x3D; keyboard.Key.esc:        stop_flag &#x3D; Truepcd_1 &#x3D; o3d.io.read_point_cloud(&quot;data&#x2F;room.pcd&quot;)vis_1 &#x3D; o3d.visualization.Visualizer()pcd_2 &#x3D; o3d.io.read_point_cloud(&quot;data&#x2F;bunny.pcd&quot;)vis_2 &#x3D; o3d.visualization.Visualizer()# 创建窗口vis_1.create_window(window_name&#x3D;&quot;Window 1&quot;, width&#x3D;1080, height&#x3D;720)vis_2.create_window(window_name&#x3D;&quot;Window 2&quot;, width&#x3D;1080, height&#x3D;720)# 添加点云数据vis_1.add_geometry(pcd_1)vis_2.add_geometry(pcd_2)# 开始键盘监听listener &#x3D; keyboard.Listener(on_press&#x3D;on_press)listener.start()# 窗口循环渲染stop_flag &#x3D; Falsewhile not stop_flag:    vis_1.poll_events()    vis_1.update_renderer()        vis_2.poll_events()    vis_2.update_renderer()# 销毁窗口vis_1.destroy_window()vis_2.destroy_window()# 停止监听listener.stop()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/24/1.png"></p><h2 id="根据最大边界点和最小边界点画边界框"><a href="#根据最大边界点和最小边界点画边界框" class="headerlink" title="根据最大边界点和最小边界点画边界框"></a>根据最大边界点和最小边界点画边界框</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">import open3d as o3dimport numpy as np# 生成一个随机点云pcd &#x3D; o3d.geometry.PointCloud()points &#x3D; np.random.rand(100, 3)pcd.points &#x3D; o3d.utility.Vector3dVector(points)# 获取点云边界框的对角线两个点min_bound &#x3D; np.min(points, axis&#x3D;0)max_bound &#x3D; np.max(points, axis&#x3D;0)# 使用对角线的两个点创建一个包围盒bbox &#x3D; o3d.geometry.AxisAlignedBoundingBox(min_bound, max_bound)# 创建一个边界框bbox_lines &#x3D; o3d.geometry.LineSet.create_from_axis_aligned_bounding_box(bbox)bbox_lines.paint_uniform_color([1, 0, 0])# 可视化结果o3d.visualization.draw_geometries([pcd, bbox_lines])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/24/2.png"></p><h2 id="根据长宽高画边界框"><a href="#根据长宽高画边界框" class="headerlink" title="根据长宽高画边界框"></a>根据长宽高画边界框</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">import open3d as o3dimport numpy as npx &#x3D; 10y &#x3D; 10z &#x3D; 10# 创建立方体网格mesh_box &#x3D; o3d.geometry.TriangleMesh.create_box(width&#x3D;x, height&#x3D;y, depth&#x3D;z)# 将网格放置在原点mesh_box.translate([-x&#x2F;2, -y&#x2F;2, -z&#x2F;2])# 创建一个边界框bbox_lines &#x3D; o3d.geometry.LineSet.create_from_triangle_mesh(mesh_box)bbox_lines.paint_uniform_color([1, 0, 0])# 可视化结果o3d.visualization.draw_geometries([bbox_lines], width&#x3D;1080, height&#x3D;720)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/24/3.png"></p><h2 id="将可视化结果保存成图片"><a href="#将可视化结果保存成图片" class="headerlink" title="将可视化结果保存成图片"></a>将可视化结果保存成图片</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">import open3d as o3dpcd &#x3D; o3d.io.read_point_cloud(&quot;data&#x2F;bun_zipper.ply&quot;)# 获取边界框obb &#x3D; pcd.get_oriented_bounding_box()# 设置边界框颜色obb.color &#x3D; [1, 0, 0]vis &#x3D; o3d.visualization.Visualizer()vis.create_window(width&#x3D;1080, height&#x3D;720)vis.add_geometry(pcd)vis.add_geometry(obb)vis.run()# 保存图片vis.capture_screen_image(&quot;output.png&quot;)vis.destroy_window()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/24/4.png"></p><h2 id="画坐标轴"><a href="#画坐标轴" class="headerlink" title="画坐标轴"></a>画坐标轴</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">import open3d as o3dvis &#x3D; o3d.visualization.Visualizer()vis.create_window(width&#x3D;1080, height&#x3D;720)vis.get_render_option().point_size &#x3D; 1vis.get_render_option().background_color &#x3D; [0, 0, 0]bin_path &#x3D; &#39;&#x2F;home&#x2F;lightning&#x2F;work&#x2F;bishe&#x2F;VLP16&#x2F;cap_data&#x2F;17.bin&#39;bin &#x3D; np.fromfile(bin_path, dtype&#x3D;np.float32, count&#x3D;-1).reshape(-1, 4)bin_xyz &#x3D; bin[:, :3]pcd &#x3D; o3d.open3d.geometry.PointCloud()pcd.points &#x3D; o3d.utility.Vector3dVector(bin_xyz)vis.add_geometry(pcd)# 画坐标轴，蓝色Z轴 绿色Y轴 红色X轴axis_pcd &#x3D; o3d.geometry.TriangleMesh.create_coordinate_frame(size&#x3D;5, origin&#x3D;[0, 0, 0])vis.add_geometry(axis_pcd)vis.run()vis.destroy_window()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/24/5.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 三维点云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Anchor-Based目标检测学习记录</title>
      <link href="posts/23.html"/>
      <url>posts/23.html</url>
      
        <content type="html"><![CDATA[<h1 id="Anchor-Based目标检测学习记录"><a href="#Anchor-Based目标检测学习记录" class="headerlink" title="Anchor-Based目标检测学习记录"></a>Anchor-Based目标检测学习记录</h1><a id="more"></a><h2 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h2><p><a href="https://zhuanlan.zhihu.com/p/86741707">Anchor-Based-01 目标检测算法设计思想一：anchor是什么</a></p><p><a href="https://zhuanlan.zhihu.com/p/86743285">Anchor-Based-02 目标检测算法设计思想二 ：Matcher</a></p><p><a href="https://zhuanlan.zhihu.com/p/86941635">Anchor-Based-03 目标检测算法设计思想三 ：BoxCoder-BoxDecoder</a></p><p><a href="https://zhuanlan.zhihu.com/p/88658153">Anchor-Based-04 目标检测的网络结构/backbone</a></p><p><a href="https://zhuanlan.zhihu.com/p/104036488">Anchor-Based-04 目标检测的网络结构/RPN</a></p><p>这几篇文章讲的非常详细，而且讲的很好。</p><hr><p>下面部分是我对于其中一些算法或者问题的个人见解，特地记录一下。</p><h2 id="Matcher-算法"><a href="#Matcher-算法" class="headerlink" title="Matcher 算法"></a>Matcher 算法</h2><p>对于简单的猫狗分类任务，我们会对每一张图片进行标注，然后模型会根据图片的真实类别进行学习和训练。在基于Anchor的目标检测任务中，模型也会对每一个Anchor进行预测分类，但我们没有对每一个Anchor进行标注，模型并不知道目前预测的Anchor的真实类别，因此这是无法学习的。但我们不可能手动对每一个Anchor进行标注，我们只是标注了一张图片中某些目标区域而已，而且这些被标注的目标区域并不会与Anchor完美匹配。</p><p>因此为了确定每一个Anchor的真实类别，需要引入Matcher算法。</p><p>我们会计算每一个目标的GT（Ground Truth）与每一个Anchor的IOU，如果IOU超过设定的阈值，那么就认为该Anchor的类别为该目标的类别，否则就认为是背景。</p><p>这样我们就可以根据标注图片获得每一个Anchor的类别了。</p><h2 id="BoxCoder算法"><a href="#BoxCoder算法" class="headerlink" title="BoxCoder算法"></a>BoxCoder算法</h2><p>由于Anchor的框往往不会完美匹配真实目标，也就是说Anchor的框是有可能不会完美框中真是目标的，有可能会只框住大部分，这样是没法获取到检测目标准确的位置信息的。因此为了获取目标的准确位置需要用模型再预测出Anchor与目标GT的位置偏移量。</p><p>也就是说现在的模型需要预测两个值，一个是Anchor的类别，另一个是Anchor与目标GT的位置偏移量。</p><p>与之前说的类似，我们也不可能为每一个Anchor标注出其与目标GT的位置偏移量，因此需要使用BoxCoder算法将Anchor的坐标与GT坐标之间的偏移量编码成模型可以预测的变量。</p><h2 id="Anchor生成"><a href="#Anchor生成" class="headerlink" title="Anchor生成"></a>Anchor生成</h2><p>Anchor一般有3种不同的面积，area1&lt;area2&lt;area3，每一种面积又有3种不同长宽比的Anchor，1:1、1:2、2:1。因此一般来说对于某一个锚点会生成9张Anchor。</p><p>一般来说，对于特征图上的每一个像素点都会生成一系列的Anchor。但这不意味每个像素点都会生成9种Anchor，对于不同的特征图只需要生成一种面积的特征图就行。一般来说，对于尺度大的特征图，会生成小面积的Anchor；尺度小的特征图，会生成大面积的Anchor。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 目标检测 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sklearn实现基于TF-IDF的KNN新闻标题文本分类</title>
      <link href="posts/22.html"/>
      <url>posts/22.html</url>
      
        <content type="html"><![CDATA[<h1 id="sklearn实现基于TF-IDF的KNN新闻标题文本分类"><a href="#sklearn实现基于TF-IDF的KNN新闻标题文本分类" class="headerlink" title="sklearn实现基于TF-IDF的KNN新闻标题文本分类"></a>sklearn实现基于TF-IDF的KNN新闻标题文本分类</h1><a id="more"></a><h2 id="数据集下载"><a href="#数据集下载" class="headerlink" title="数据集下载"></a>数据集下载</h2><p><a href="https://wwxy.lanzouf.com/iJcVB0qx5v5g">点我下载</a></p><p>数据集已经分好了训练集和测试集，一共有10个类别。训练集每个类别有180000条数据，测试集每个类别有1000条数据。</p><h2 id="读取数据集"><a href="#读取数据集" class="headerlink" title="读取数据集"></a>读取数据集</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pandas as pd# 读取训练集和测试集，并进行分词处理# train_text[0]是新闻文本 train_text[1]是类别标签train_text &#x3D; pd.read_table(&quot;data&#x2F;新闻标题文本分类&#x2F;4分类_72000&#x2F;train_4_72000.txt&quot;, header&#x3D;None, sep&#x3D;&quot; &quot;)test_text &#x3D; pd.read_table(&quot;data&#x2F;新闻标题文本分类&#x2F;4分类_72000&#x2F;test_4_4000.txt&quot;, header&#x3D;None, sep&#x3D;&quot; &quot;)print(train_text.head(5))print(&quot;*&quot;*50)print(test_text.head(5))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本次演示使用的是4分类的数据集。运行上面代码，得到下面的输出：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">                           0  10         中华女子学院：本科层次仅1专业招男生  31  卡佩罗：告诉你德国脚生猛的原因 不希望英德战踢点球  72           《赤壁OL》攻城战诸侯战硝烟又起  83    上海2010上半年四六级考试报名4月8日前完成  34    李永波称李宗伟难阻林丹取胜 透露谢杏芳有望出战  7**************************************************                         0  10   词汇阅读是关键 08年考研暑期英语复习全指南  31  中国人民公安大学2012年硕士研究生目录及书目  32       日本地震：金吉列关注在日学子系列报道  33    名师辅导：2012考研英语虚拟语气三种用法  34        自考经验谈：自考生毕业论文选题技巧  3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到数据集主要由两部分组成，前面部分是新闻标题文本，后面部分是类别标签。</p><p>使用pandas加载后train_text[0]和test_text[0]代表的就是新闻标题文本，train_text[1]和test_text[1]代表的是类别标签。</p><h2 id="中文分词"><a href="#中文分词" class="headerlink" title="中文分词"></a>中文分词</h2><p>使用<strong>jieba</strong>对新闻标题文本分词。jieba一共提供了四种分词模式，默认使用的是精确模式，效果还不错。此外，jieba还提供了paddle模式的分词，我自己使用下来的效果是和精确模式差不多。（不过paddle模式的分词感觉确实要比精确模式好一点的。）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import jieba# 使用jieba分词def new_cut(text):    return &quot; &quot;.join(list(jieba.cut(train_text)))train_text[&quot;分词结果&quot;] &#x3D; train_text[0].map(new_cut)test_text[&quot;分词结果&quot;] &#x3D; test_text[0].map(new_cut)print(train_text[&quot;分词结果&quot;].head(5))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分词结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">0                中华 女子 学院 ： 本科 层次 仅 1 专业 招 男生1    卡佩罗 ： 告诉 你 德国 脚 生猛 的 原因   不 希望 英德 战 踢 点球2                   《 赤壁 OL 》 攻城战 诸侯 战 硝烟 又 起3           上海 2010 上半年 四六级 考试 报名 4 月 8 日前 完成4           李永波 称 李宗伟 难 阻林丹 取胜   透露 谢杏芳 有望 出战<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="去除停用词"><a href="#去除停用词" class="headerlink" title="去除停用词"></a>去除停用词</h2><p>本次使用的停用词表是哈工大停用词表，<a href="https://wwxy.lanzouf.com/iHDvo0qx76fi">点我下载</a></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 加载停用词def get_custom_stopwords(stop_words_file):    with open(stop_words_file, encoding&#x3D;&quot;gbk&quot;) as f:        stopwords &#x3D; f.read()    stopwords_list &#x3D; stopwords.split(&#39;\n&#39;)    custom_stopwords_list &#x3D; [i for i in stopwords_list]    return custom_stopwords_liststop_words_file &#x3D; &quot;stopwords.txt&quot;stopwords &#x3D; get_custom_stopwords(stop_words_file)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="TF-IDF算法提取文本特征"><a href="#TF-IDF算法提取文本特征" class="headerlink" title="TF-IDF算法提取文本特征"></a>TF-IDF算法提取文本特征</h2><p>具体<strong>TfidfVectorizer</strong>的配置参数可以去参考[官方文档](<a href="https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.TfidfVectorizer.html#sklearn.feature_extraction.text.TfidfVectorizer">sklearn.feature_extraction.text.TfidfVectorizer — scikit-learn 1.2.2 documentation</a>)，或者其他的博客。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from sklearn.feature_extraction.text import TfidfVectorizer# 使用TF-IDF将文本处理成向量格式tfidf_vectorizer  &#x3D; TfidfVectorizer(max_df&#x3D;0.8,                                    min_df&#x3D;3,                                    token_pattern&#x3D;u&#39;(?u)\\b[^\\d\\W]\\w+\\b&#39;,                                    stop_words&#x3D;frozenset(stopwords),                                    # max_features&#x3D;1000) # 最大提取特征，默认就是没有限制                                    )train_weight &#x3D; tfidf_vectorizer.fit_transform(train_text[&quot;分词结果&quot;])test_weight &#x3D; tfidf_vectorizer.transform(test_text[&quot;分词结果&quot;])print(&quot;train:\n&quot;, f&quot;数据集大小：&#123;train_weight.toarray().shape[0]&#125; 提取特征数量：&#123;train_weight.toarray().shape[1]&#125;&quot;)print(&quot;test:\n&quot;, f&quot;数据集大小：&#123;test_weight.toarray().shape[0]&#125; 提取特征数量：&#123;test_weight.toarray().shape[1]&#125;&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">train: 数据集大小：72000 提取特征数量：20677test: 数据集大小：4000 提取特征数量：20677<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="KNN分类器的设计"><a href="#KNN分类器的设计" class="headerlink" title="KNN分类器的设计"></a>KNN分类器的设计</h2><p>KNN分类器的K值（<em>n_neighbors</em>参数）取3，距离计算方式（<em>metric</em>参数）选择余弦距离，其他的参数默认就行。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from sklearn.neighbors import KNeighborsClassifierfrom sklearn.metrics import accuracy_score, recall_score, f1_score, precision_scoreimport picklesave_model &#x3D; Falsek &#x3D; 3knn &#x3D; KNeighborsClassifier(n_neighbors&#x3D;k, metric&#x3D;&quot;cosine&quot;)# 训练knn.fit(train_weight, train_text[1])# 预测test_pred &#x3D; knn.predict(test_weight)# 计算准确率、召回率、精确率和F1值accuracy &#x3D; accuracy_score(test_pred, test_text[1])recall &#x3D; recall_score(test_pred, test_text[1], average&#x3D;&#39;macro&#39;)precision &#x3D; precision_score(test_pred, test_text[1], average&#x3D;&#39;macro&#39;)f1 &#x3D; f1_score(test_pred, test_text[1], average&#x3D;&#39;macro&#39;)# 输出训练日志with open(&quot;output_logs&#x2F;knn_cls.txt&quot;, &quot;a+&quot;) as log_txt:    log_txt.write(f&quot;k &#x3D; &#123;k&#125;\n&quot;)    log_txt.write(f&quot;accuracy &#x3D; &#123;accuracy&#125;\n&quot;)    log_txt.write(f&quot;recall &#x3D; &#123;recall&#125;\n&quot;)    log_txt.write(f&quot;precision &#x3D; &#123;precision&#125;\n&quot;)    log_txt.write(f&quot;f1 &#x3D; &#123;f1&#125;\n&quot;)    log_txt.close()    # 保存训练模型if save_model:    with open(f&quot;output_models&#x2F;knn_&#123;k&#125;.pkl&quot;, &quot;wb&quot;) as f:        pickle.dump(knn, f)    print(&quot;Save model sucess!&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果日志输出：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">k &#x3D; 3accuracy &#x3D; 0.8945recall &#x3D; 0.9015750424563225precision &#x3D; 0.8945f1 &#x3D; 0.8939859931730288<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在的模型分类效果可以在调调参数，比如把k值调大一点等。</p><h2 id="完整代码下载"><a href="#完整代码下载" class="headerlink" title="完整代码下载"></a>完整代码下载</h2><p><a href="https://download.csdn.net/download/ZhuanShangNiDeXin/87609588">CSDN下载（只需1积分）</a></p><p><a href="https://wwxy.lanzouf.com/iy8l20qx8syf">蓝奏云下载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab搭建AlexNet实现手写数字识别</title>
      <link href="posts/21.html"/>
      <url>posts/21.html</url>
      
        <content type="html"><![CDATA[<h1 id="Matlab搭建AlexNet实现手写数字识别"><a href="#Matlab搭建AlexNet实现手写数字识别" class="headerlink" title="Matlab搭建AlexNet实现手写数字识别"></a>Matlab搭建AlexNet实现手写数字识别</h1><a id="more"></a><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>Matlab 2020a</li><li>Windows10</li></ul><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>使用Matlab对MNIST数据集进行预处理，搭建卷积神经网络进行训练，实现识别手写数字的任务。在训练过程中，每隔30个batch输出一次模型在验证集上的准确率和损失值。在训练结束后会输出验证集中每个数字的真实值、网络预测值和判定概率，并给出总的识别准确率。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="准备MNIST数据集"><a href="#准备MNIST数据集" class="headerlink" title="准备MNIST数据集"></a>准备MNIST数据集</h3><p>为了方便进行测试，本次只选用500张MNIST数据集，每个数字50张。</p><p><strong><a href="https://pan.baidu.com/s/1COuYnUrywAbCqWoDMkwQig?pwd=af6n">数据集下载地址</a>  提取码：af6n</strong></p><p>下载数据集后并解压，为每个数字创建单独文件夹并将该数字的所有图片放在对应的文件夹下，如图1所示。</p><p><img src="/posts/21/1.png" alt="图1 将图片按数字分类"></p><p>手动分类结束后每个文件夹中应有50张图片。</p><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 加载数据集imds &#x3D; imageDatastore(...    &quot;.&#x2F;data&quot;,...    &#39;IncludeSubfolders&#39;, true,...    &#39;LabelSource&#39;,&#39;foldernames&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>imageDatastore</code>加载数据集。第一个参数填写数据集路径。由于本次实验data目录下含有子文件夹所以<code>IncludeSubfolders</code>需要指定为true。<code>LabelSource</code>表示标签来源，这里使用文件夹名字来代表标签。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">ImageDatastore - 属性:                     Files: &#123;                            &#39;D:\data\0\0_1.bmp&#39;;                            &#39;D:\data\0\0_10.bmp&#39;;                            &#39;D:\data\0\0_11.bmp&#39;                             ... and 497 more                            &#125;                   Folders: &#123;                            &#39;D:\data&#39;                            &#125;                    Labels: [0; 0; 0 ... and 497 more categorical]  AlternateFileSystemRoots: &#123;&#125;                  ReadSize: 1    SupportedOutputFormats: [1×5 string]       DefaultOutputFormat: &quot;png&quot;                   ReadFcn: @readDatastoreImage<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面内容为执行imageDatastore后返回变量的属性。可以看出已经成功将数据集读入并对每张图片进行label处理。</p><p>由于每个数字有50张图像，因此本次实验每个数字选用30张进行训练，另20张进行验证。使用splitEachLabel进行划分，得到训练集和验证集。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 数据打乱imds &#x3D; shuffle(imds);% 划分训练集和验证集。每一个类别训练集有30个，验证集有20个[imdsTrain,imdsValidation] &#x3D; splitEachLabel(imds, 30);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用shuffle进行数据打乱。得到的imdsTrain和imdsValidation分别有300和200张图片。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 将训练集与验证集中图像的大小调整成与输入层的大小相同augimdsTrain &#x3D; augmentedImageDatastore([28 28],imdsTrain);augimdsValidation &#x3D; augmentedImageDatastore([28 28],imdsValidation);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="定义网络模型"><a href="#定义网络模型" class="headerlink" title="定义网络模型"></a>定义网络模型</h3><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 构建alexnet卷积网络 alexnet &#x3D; [    imageInputLayer([56,56,1], &#39;Name&#39;, &#39;Input&#39;)    convolution2dLayer([11,11],48,&#39;Padding&#39;,&#39;same&#39;,&#39;Stride&#39;,4, &#39;Name&#39;, &#39;Conv_1&#39;)    batchNormalizationLayer(&#39;Name&#39;, &#39;BN_1&#39;)    reluLayer(&#39;Name&#39;, &#39;Relu_1&#39;)    maxPooling2dLayer(3,&#39;Padding&#39;,&#39;same&#39;,&#39;Stride&#39;,2, &#39;Name&#39;, &#39;MaxPooling_1&#39;)    convolution2dLayer([5,5],128,&#39;Padding&#39;,2,&#39;Stride&#39;,1, &#39;Name&#39;, &#39;Conv_2&#39;)    batchNormalizationLayer(&#39;Name&#39;, &#39;BN_2&#39;)    reluLayer(&#39;Name&#39;, &#39;Relu_2&#39;)    maxPooling2dLayer(3,&#39;Padding&#39;,&#39;same&#39;,&#39;Stride&#39;,2, &#39;Name&#39;, &#39;MaxPooling_2&#39;)    convolution2dLayer([3 3],192,&#39;Padding&#39;,1,&#39;Stride&#39;,1, &#39;Name&#39;, &#39;Conv_3&#39;)    batchNormalizationLayer(&#39;Name&#39;, &#39;BN_3&#39;)    reluLayer(&#39;Name&#39;, &#39;Relu_3&#39;)    convolution2dLayer([3 3],192,&#39;Padding&#39;,1,&#39;Stride&#39;,1, &#39;Name&#39;, &#39;Conv_4&#39;)    batchNormalizationLayer(&#39;Name&#39;, &#39;BN_4&#39;)    reluLayer(&#39;Name&#39;, &#39;Relu_4&#39;)    convolution2dLayer([3 3],128,&#39;Stride&#39;,1,&#39;Padding&#39;,1, &#39;Name&#39;, &#39;Conv_5&#39;)    batchNormalizationLayer(&#39;Name&#39;, &#39;BN_5&#39;)    reluLayer(&#39;Name&#39;, &#39;Relu_5&#39;)    maxPooling2dLayer(3,&#39;Padding&#39;,&#39;same&#39;,&#39;Stride&#39;,2, &#39;Name&#39;, &#39;MaxPooling_3&#39;)    fullyConnectedLayer(4096, &#39;Name&#39;, &#39;FC_1&#39;)    reluLayer(&#39;Name&#39;, &#39;Relu_6&#39;)    fullyConnectedLayer(4096, &#39;Name&#39;, &#39;FC_2&#39;)    reluLayer(&#39;Name&#39;, &#39;Relu_7&#39;)    fullyConnectedLayer(10, &#39;Name&#39;, &#39;FC_3&#39;)    % 将新的全连接层的输出设置为训练数据中的种类    softmaxLayer(&#39;Name&#39;, &#39;Softmax&#39;)            % 添加新的Softmax层    classificationLayer(&#39;Name&#39;, &#39;Output&#39;) ];   % 添加新的分类层<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用上面的代码即可构建AlexNet模型。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 对构建的网络进行可视化分析lgraph &#x3D; layerGraph(mynet);analyzeNetwork(lgraph)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/posts/21\2.png" alt="2" style="zoom:50%;"><h3 id="定义训练超参数"><a href="#定义训练超参数" class="headerlink" title="定义训练超参数"></a>定义训练超参数</h3><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 配置训练选项   options &#x3D; trainingOptions(&#39;sgdm&#39;, ...    &#39;InitialLearnRate&#39;,0.001, ...        &#39;MaxEpochs&#39;,100, ...                   &#39;Shuffle&#39;,&#39;every-epoch&#39;, ...    &#39;ValidationData&#39;,augimdsValidation, ...    &#39;ValidationFrequency&#39;,30, ...    &#39;Verbose&#39;,true, ...    &#39;Plots&#39;,&#39;training-progress&#39;); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本次实验选用sgdm作为优化器，初始学习率设置为0.001，最大迭代次数为100，每次迭代都会打乱数据，每隔30个batch进行一次验证。</p><h3 id="网络训练和预测"><a href="#网络训练和预测" class="headerlink" title="网络训练和预测"></a>网络训练和预测</h3><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 对网络进行训练net &#x3D; trainNetwork(augimdsTrain, mynet, options); % 将训练好的网络用于对新的输入图像进行分类，得到预测结果和判定概率[YPred, err] &#x3D; classify(net, augimdsValidation);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，YPred是存放网络对验证集预测结果的数组，err存放着每个数字的判定概率。</p><p><img src="/posts/posts%5C21%5C3.png" alt="3"></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 打印真实数字、预测数字、判定概率和准确率YValidation &#x3D; imdsValidation.Labels;for i&#x3D;1:200fprintf(&quot;真实数字：%d  预测数字：%d&quot;, double(YValidation(i,1))-1, double(YPred(i, 1))-1);fprintf(&quot;  判定概率：%f\n&quot;, max(err(i, :)));end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行上面代码即可打印相关结果。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">... ...真实数字：4  预测数字：4  判定概率：0.814434真实数字：0  预测数字：0  判定概率：0.657829真实数字：8  预测数字：8  判定概率：0.874560真实数字：0  预测数字：0  判定概率：0.988826真实数字：6  预测数字：6  判定概率：0.970034... ...真实数字：5  预测数字：5  判定概率：0.806220真实数字：4  预测数字：4  判定概率：0.938233真实数字：7  预测数字：7  判定概率：0.906994真实数字：7  预测数字：7  判定概率：0.837794真实数字：6  预测数字：6  判定概率：0.951572真实数字：6  预测数字：1  判定概率：0.415834真实数字：5  预测数字：5  判定概率：0.789031真实数字：2  预测数字：2  判定概率：0.363526真实数字：7  预测数字：7  判定概率：0.930049准确率：0.880000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h2><p><a href="https://github.com/LightningLeader/Matlab-builds-AlexNet-to-realize-handwritten-digit-recognition">GitHub下载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atlas200DK环境配置</title>
      <link href="posts/20.html"/>
      <url>posts/20.html</url>
      
        <content type="html"><![CDATA[<h1 id="Atlas200DK环境配置"><a href="#Atlas200DK环境配置" class="headerlink" title="Atlas200DK环境配置"></a>Atlas200DK环境配置</h1><a id="more"></a><h2 id="dd镜像安装"><a href="#dd镜像安装" class="headerlink" title="dd镜像安装"></a>dd镜像安装</h2><p>推荐使用dd镜像安装环境，这种方式更快更方便。</p><p>直接去网站下载需要版本的dd镜像，然后利用Etcher烧录到sd卡中就行。</p><p>参考链接：</p><p><a href="https://www.bilibili.com/video/BV1g3411r7Vz/">Atlas 200DK样例速跑_哔哩哔哩_bilibili</a></p><p><a href="https://bbs.huaweicloud.com/forum/thread-139685-1-1.html">更方便的200DK合设环境搭建方法——dd镜像_Atlas 200 DK_昇腾论坛_华为云论坛 (huaweicloud.com)</a></p><h2 id="MindSpore安装"><a href="#MindSpore安装" class="headerlink" title="MindSpore安装"></a>MindSpore安装</h2><p>不推荐在该开发板上安装MindSpore，安装之后可能无法正常使用。</p><p>非要安装的话需要把MindSpore和环境版本对应，建议安装低版本的MindSpore。</p><h2 id="联网方式"><a href="#联网方式" class="headerlink" title="联网方式"></a>联网方式</h2><p>使用网络共享的话可能会出现开发板重启后网络无法正常连接的问题，这个时候只需要在PC端先关闭共享网络，再重新打开即可（重启共享网络）。</p><p>参考链接：</p><p><a href="https://www.bilibili.com/video/BV1u3411B7CY/?spm_id_from=333.788.recommend_more_video.-1">Atlas 200 DK的多种联网方式_哔哩哔哩_bilibili</a></p><h2 id="代码运行环境配置"><a href="#代码运行环境配置" class="headerlink" title="代码运行环境配置"></a>代码运行环境配置</h2><p>如果需要运行cv方向的代码需要安装对应的环境配置。这个具体的环境配置可以在官方gitee中找到。</p><p>参考链接：</p><p><a href="https://blog.csdn.net/weixin_42800966/article/details/122587832">华为Atlas200DK的环境部署与运行demo（人脸识别）_Quinton123的博客-CSDN博客_华为atlas200dk</a></p><p><a href="https://toscode.gitee.com/ascend/samples/tree/master/python/environment">python/environment · Ascend/samples - 码云 - 开源中国 (gitee.com)</a></p><h2 id="模型转换"><a href="#模型转换" class="headerlink" title="模型转换"></a>模型转换</h2><p>在windows训练得到的模型是ckpt格式的，这种格式的模型文件是无法在开发板上运行，因此需要转换格式。</p><p>可以转换的总共有四种模型文件，分别是MindIR、AIR、ONNX和OM。这四种格式对应了不同的应用场景。我在这里只简单介绍AIR和OM两种文件格式，因为本实验只用到了这两种。</p><p>AIR格式只能Ascend910环境中上才能导出，是官网推荐的模型格式，可以转换成OM格式。而OM格式可以在Ascend310上推理使用，也是本次实验使用的模型格式。</p><p>为了获得AIR格式模型需要创建华为云的Ascend910环境，然后在这个环境中训练并得到ckpt模型。再将ckpt模型转换成air格式模型并传到开发板中。最后将这个air格式模型转换成om格式才结束。整个过程需要两次模型转换，好在这个模型转换操作不算复杂，就是转换时间可能需要耐心等下。</p><h2 id="其它参考链接"><a href="#其它参考链接" class="headerlink" title="其它参考链接"></a>其它参考链接</h2><p><a href="https://blog.csdn.net/qq_42703283/article/details/110389270">华为Atlas200DK环境配置指南(版本20.0.0)_ChrisLiu__的博客-CSDN博客_华为atlas200dk</a></p><p><a href="https://blog.csdn.net/Hariod/article/details/119721967">华为Atlas 200 DK开发者套件踩坑记(持续更新)_Hariod的博客-CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为云ModelAtrs创建GPU环境训练模型</title>
      <link href="posts/19.html"/>
      <url>posts/19.html</url>
      
        <content type="html"><![CDATA[<h1 id="华为云ModelAtrs创建GPU环境训练模型"><a href="#华为云ModelAtrs创建GPU环境训练模型" class="headerlink" title="华为云ModelAtrs创建GPU环境训练模型"></a>华为云ModelAtrs创建GPU环境训练模型</h1><a id="more"></a><h2 id="创建Notebook"><a href="#创建Notebook" class="headerlink" title="创建Notebook"></a>创建Notebook</h2><p>首先需要创建新的Notebook</p><p><img src="/posts/19/1.png"></p><p>然后根据自己的训练需求选择要创建的镜像和规格。我这里选择mindspore的GPU进行创建，规格选择64GB的。</p><p><img src="/posts/19/2.png"></p><p><img src="/posts/19/3.png"></p><p>如果要选择SSH远程开发的话需要填写这个密钥对，没有的话选择点击立即创建之后就按照它的要求走就行。</p><h2 id="添加数据存储"><a href="#添加数据存储" class="headerlink" title="添加数据存储"></a>添加数据存储</h2><p><img src="/posts/19/4.png"></p><p>点击添加数据存储。如果没有并行文件系统，就选择新建并行文件系统。创建过程很简单就不多说了。</p><p>可以把我们的文件上传到这个并行文件系统，然后在这个选择需要挂载的文件夹目录，这样就可以在镜像中使用这些文件了。</p><h3 id="上传文件至并行文件系统"><a href="#上传文件至并行文件系统" class="headerlink" title="上传文件至并行文件系统"></a>上传文件至并行文件系统</h3><p>上传方式推荐使用<code>OBS Browser+</code>，这个软件可以在华为云的官网下载。安装后打开，界面如下图所示。</p><p><img src="/posts/19/5.png"></p><p>然后选择一种方式进行登录。</p><p>如果使用AK方式登录的话需要AccessKey，这个东西可以点击界面上的<code>获取AccessKey</code>进行获取，然后输入进去登录就可以了。</p><p>登录之后，选择左侧的并行文件系统。</p><p><img src="/posts/19/6.png"></p><p>找到自己需要的那个并行文件系统，然后点击进去。之后就可以选择上传，可以上传文件也可以上传整个文件夹。</p><p>上传结束后就可以在里面看到自己上传的文件或文件夹了。</p><p><img src="/posts/19/7.png"></p><h3 id="选择挂载文件目录"><a href="#选择挂载文件目录" class="headerlink" title="选择挂载文件目录"></a>选择挂载文件目录</h3><p>之后就可以返回刚才的界面选择并行文件系统中自己想要挂载的文件夹目录。本地挂载目录也可以按照自己的需求更改。</p><p><img src="/posts/19/8.png"></p><p>点击确定后等他挂载成功后就可以了，不想要的时候可以卸载。</p><h3 id="找到挂载的文件"><a href="#找到挂载的文件" class="headerlink" title="找到挂载的文件"></a>找到挂载的文件</h3><p><img src="/posts/19/9.png"></p><h2 id="使用WinSCP连接镜像"><a href="#使用WinSCP连接镜像" class="headerlink" title="使用WinSCP连接镜像"></a>使用WinSCP连接镜像</h2><p><img src="/posts/19/10.png"></p><p>获得图中的信息然后依次填写</p><p><img src="/posts/19/11.png"></p><p>需要注意的是，在连接的时候需要一个密钥文件，这个密钥文件就是之前创建密钥时下载的那个文件。这里需要将那个密钥文件加载进来。第一次加载可能会提示你格式不对需要转换之类的信息，只需要点击确定就行。</p><p><img src="/posts/19/12.png"></p><p>填完密钥后点击确定，之后就可以正常登录了。</p><p><img src="/posts/19/13.png"></p><h2 id="使用VScode连接镜像"><a href="#使用VScode连接镜像" class="headerlink" title="使用VScode连接镜像"></a>使用VScode连接镜像</h2><p>使用VScode通过ssh连接镜像需要下载插件。</p><p><img src="/posts/19/14.png"></p><p>安装完之后</p><p><img src="/posts/19/15.png"></p><p><img src="/posts/19/16.png"></p><p>配置完之后保存文件，就可以在左侧看到相应名称的对象了。</p><p>右击它然后选择第一个（在本窗口连接），第一次连接会让你选择平台，这里选择Linux就行。然后会询问你一个东西，输入yes就行。</p><p>之后慢慢等待一下就可以正常连接上去了。</p><p>之后选择打开文件夹，可以直接打开到我们之前挂载的文件夹目录，这样方便修改调试里面的代码。</p><h2 id="使用MobaXterm连接镜像"><a href="#使用MobaXterm连接镜像" class="headerlink" title="使用MobaXterm连接镜像"></a>使用MobaXterm连接镜像</h2><p>打开软件，选择左上角的Session，再选择SSH。</p><p><img src="/posts/19/17.png"></p><p>按照要求填写内容以及添加密钥文件后点击OK。</p><p><img src="/posts/19/18.png"></p><p>成功连接。</p><h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><p>使用MobaXterm或者镜像自带的命令行进入挂载目录。</p><p>然后运行train.py（已经修改成使用GPU训练），查看训练结果。</p><p><img src="/posts/19/19.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 华为云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MindSpore】简单使用Resnet50实现狗狼图片分类</title>
      <link href="posts/18.html"/>
      <url>posts/18.html</url>
      
        <content type="html"><![CDATA[<h1 id="【MindSpore】简单使用Resnet50实现狗狼图片分类"><a href="#【MindSpore】简单使用Resnet50实现狗狼图片分类" class="headerlink" title="【MindSpore】简单使用Resnet50实现狗狼图片分类"></a>【MindSpore】简单使用Resnet50实现狗狼图片分类</h1><a id="more"></a><p><strong>本文章用的例子来自MindSpore官网<a href="https://www.mindspore.cn/tutorials/zh-CN/r1.6/intermediate/image_and_video/transfer_learning.html">教程</a>，这里主要是分享一下个人理解和整合一下相关代码。</strong></p><p>环境配置：</p><ul><li>windows10</li><li>MindSpore1.6.1 CPU版本</li><li>python3.9.0</li></ul><h2 id="一、数据集和预训练模型下载"><a href="#一、数据集和预训练模型下载" class="headerlink" title="一、数据集和预训练模型下载"></a>一、数据集和预训练模型下载</h2><p><a href="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/datasets/intermediate/Canidae_data.zip">数据集下载</a></p><p><a href="https://download.mindspore.cn/model_zoo/official/cv/resnet/resnet50_v1.5_ascend_0.3.0_cifar10_official_classification_20200718/resnet50.ckpt">预训练模型下载</a></p><p>注：以上链接均来源MindSpore官网。</p><h2 id="二、定义命令行参数并保存成config-yml"><a href="#二、定义命令行参数并保存成config-yml" class="headerlink" title="二、定义命令行参数并保存成config.yml"></a>二、定义命令行参数并保存成config.yml</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">def parse_args():    parser &#x3D; argparse.ArgumentParser()        # 工程文件名字    parser.add_argument(&quot;--name&quot;, default&#x3D;&quot;resnet50_classify&quot;, help&#x3D;&quot;The name of project.&quot;)    # 数据集名称    parser.add_argument(&#39;--dataset&#39;, default&#x3D;&#39;Canidae&#39;, help&#x3D;&#39;dataset name&#39;)    parser.add_argument(&quot;--epochs&quot;, default&#x3D;200, type&#x3D;int, metavar&#x3D;&#39;N&#39;)    parser.add_argument(&#39;--batch_size&#39;, default&#x3D;16, type&#x3D;int, metavar&#x3D;&#39;N&#39;)    # 预训练权重，参数填预训练文件的路径    parser.add_argument(&#39;--pre_ckpt&#39;, default&#x3D;&quot;.&#x2F;pre_ckpt&#x2F;resnet50.ckpt&quot;)    # 是否删除预训练模型的全连接层    parser.add_argument(&quot;--delfc_flag&quot;, default&#x3D;True)        # 输入图片的channels，默认是RGB三通道图片    parser.add_argument(&#39;--input_channels&#39;, default&#x3D;3, type&#x3D;int, help&#x3D;&#39;input channels&#39;)    # 类别个数    parser.add_argument(&#39;--num_classes&#39;, default&#x3D;20, type&#x3D;int, help&#x3D;&#39;number of classes&#39;)    # 输入图像的尺寸    parser.add_argument(&#39;--image_size&#39;, default&#x3D;128, type&#x3D;int, help&#x3D;&#39;image size&#39;)    # 优化器    parser.add_argument(&#39;--optimizer&#39;, default&#x3D;&#39;Adam&#39;)    # 损失函数    parser.add_argument(&#39;--loss&#39;, default&#x3D;&#39;SoftmaxCrossEntropyWithLogits&#39;)        parser.add_argument(&#39;--dataset_sink_mode&#39;, default&#x3D;False)    config &#x3D; parser.parse_args()    return config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>argparse</code>这个库可以自定义命令行参数，方便训练参数的更改。后面可以把这些参数存储为<code>config.yml</code>，作为配置文件使用，也方便自己或其他人了解这个网络的相关参数。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def main():    # 解析命令行参数。config类型为字典，键是之前定义的命令行参数名字，值是对应其的内容。    config &#x3D; vars(parse_args())        # 创建模型工程文件夹，用来保存训练文件    if config[&quot;name&quot;] is None:        config[&#39;name&#39;] &#x3D; &quot;test&quot;    os.makedirs(os.path.join(&quot;models&quot;, config[&quot;name&quot;]), exist_ok&#x3D;True)    # 创建config文件并将参数写入    config_path &#x3D; &#39;models&#x2F;%s&#x2F;config.yml&#39; % config[&#39;name&#39;]    with open(config_path, &#39;w&#39;) as f:        yaml.dump(config, f)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、★数据集预处理和加载★"><a href="#三、★数据集预处理和加载★" class="headerlink" title="三、★数据集预处理和加载★"></a>三、★数据集预处理和加载★</h2><p>数据集分为训练集和验证集。</p><p>MindSpore提供了<code>mindspore.dataset.ImageFolderDataset</code>函数可以方便读取数据集。<a href="%5BMindSpore%5D(https://www.mindspore.cn/docs/api/zh-CN/r1.6/api_python/dataset/mindspore.dataset.ImageFolderDataset.html?highlight=imagefolderdataset#mindspore.dataset.ImageFolderDataset)">函数官方解释</a></p><p>不过要使用函数需要按照规定的方式存储数据。以本数据集为例，数据集可以以下面这种方式存放。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">└─Canidae  └─train  │   └─dogs  │   └─wolves  └─val      └─dogs      └─wolves<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该数据的存放方式是，在单个目录下创建要分类图片的对应文件夹，每一个文件夹对应一个类别。</p><p>例如，该函数会自动读取train目录下的所有文件夹，将同一个文件夹内的所有图片看作同一个类别。</p><p>在按文件夹名称顺序读入图片后会给每一类的图片赋予数字标签也就是label。第一个读入的文件夹图片被记为0，第二个读入的文件夹图片被记为1，依此类推直到所有文件夹读取完毕。</p><p>这种读取方式是函数默认的方式，但这种方式可能会让人无法准确判断哪一种类别对应着哪个label，在后面进行测试推理的时候可能会麻烦一点。因此我们可以使用该函数的<code>class_indexing</code>参数，用来直接指定文件夹与label的对应关系。</p><p>可以给这个参数传入字典类型。字典的键就是文件夹名称，值就是对应的数字。</p><p>例如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dataset &#x3D; ds.ImageFolderDataset(dataset_dir&#x3D;image_folder_dataset_dir,                                class_indexing&#x3D;&#123;&quot;dogs&quot;:0, &quot;wolves&quot;:1&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样就直接指定dogs是0，wolves是1。这就比较清晰label和类别的具体关系了。</p><p>因此我比较推荐直接将类别的名称作为文件夹的名字，可以通过函数读取文件夹的名字然后依次赋值生成相关字典并将内容保存到config文件中，这样之后测试就可以很清晰的知道类别和label关系。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def getClasses(data_path, config_path):    &quot;&quot;&quot;    加载路径下所有文件夹的名字然后进行升序排序。    将第一个文件夹记作0，第二个文件夹记作1，依此类推。    然后将文件夹名称和对应的标记写入config文件，用于制作数据集label。    Args:        data_path (str): 数据集路径        config_path (str): 配置文件路径    Returns:        _type_: _description_    &quot;&quot;&quot;    res_dict &#x3D; &#123;&quot;classes&quot;:&#123;&#125;&#125;    data_list &#x3D; os.listdir(data_path)    data_list.sort()    for data in data_list:        res_dict[&quot;classes&quot;][data] &#x3D; data_list.index(data)    # 保存到config文件    with open(config_path, &#39;a+&#39;) as f:        yaml.dump(res_dict, f, Dumper&#x3D;yaml.RoundTripDumper)        f.close()    return res_dict[&quot;classes&quot;]# 获取label，就是获取所有种类名称将其与数字对应classesDict &#x3D; getClasses(train_data_path, config_path)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在官方教程中给了<code>create_dataset</code>函数。这个函数是比较完整的数据集读取和处理。这个函数我就不多介绍了，能说的都写在下面的注释里了。</p><p>需要注意的是<code>training</code>参数。这个参数在True的时候是表示对训练集进行处理，False是对验证集进行处理。也就是只对训练集进行数据增强而验证集不用。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def create_dataset(data_path, image_size, classDict&#x3D;None, batch_size&#x3D;24, repeat_num&#x3D;1, training&#x3D;True):    &quot;&quot;&quot;定义数据集&quot;&quot;&quot;        # 默认是按照文件夹名称排序（字母顺序），每一个类被赋予一个从0开始的唯一索引    data_set &#x3D; ds.ImageFolderDataset(data_path,                                     num_parallel_workers&#x3D;8,                                     shuffle&#x3D;True,                                     class_indexing&#x3D;classDict)    # 对数据进行增强操作    mean &#x3D; [0.485 * 255, 0.456 * 255, 0.406 * 255]    std &#x3D; [0.229 * 255, 0.224 * 255, 0.225 * 255]    if training:        trans &#x3D; [            # 裁剪、Decode、Resize            CV.RandomCropDecodeResize(image_size, scale&#x3D;(0.8, 1.0), ratio&#x3D;(0.75, 1.333)),            # 水平翻转            CV.RandomHorizontalFlip(prob&#x3D;0.5),            # 随机旋转            CV.RandomRotation(90),            # 归一化            CV.Normalize(mean&#x3D;mean, std&#x3D;std),            # h,w,c -&gt; c,h,w            CV.HWC2CHW()        ]    else:        trans &#x3D; [            # 解码            CV.Decode(),            # 调整大小            CV.Resize((image_size, image_size)),            CV.Normalize(mean&#x3D;mean, std&#x3D;std),            CV.HWC2CHW()        ]    type_cast_op &#x3D; C.TypeCast(mstype.int32)    # 实现数据的map映射、批量处理和数据重复的操作    data_set &#x3D; data_set.map(operations&#x3D;trans, input_columns&#x3D;&quot;image&quot;, num_parallel_workers&#x3D;8)    data_set &#x3D; data_set.map(operations&#x3D;type_cast_op, input_columns&#x3D;&quot;label&quot;, num_parallel_workers&#x3D;8)    data_set &#x3D; data_set.batch(batch_size, drop_remainder&#x3D;True)    data_set &#x3D; data_set.repeat(repeat_num)    return data_set<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、训练过程"><a href="#四、训练过程" class="headerlink" title="四、训练过程"></a>四、训练过程</h2><p>主要的参数配置记录和数据集加载已经说完了，模型加载和训练方面MindSpore整合的很好，只需要几句话就可以调用，所以这部分就不多说了，在文章末尾会有工程的全部文件供下载。</p><h2 id="五、测试过程"><a href="#五、测试过程" class="headerlink" title="五、测试过程"></a>五、测试过程</h2><p>首先要加载分类标签，就是之前保存在config文件中的内容。</p><p>还需要将字典内容的键值调换顺序，方便后面根据预测结果直接输出类别名称。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># classes格式classesDict &#x3D; config[&quot;classes&quot;]# 将字典的键值调换顺序class_name &#x3D; dict(zip(classesDict.values(), classesDict.keys()))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="★加载测试数据及预处理★"><a href="#★加载测试数据及预处理★" class="headerlink" title="★加载测试数据及预处理★"></a>★加载测试数据及预处理★</h3><p>这一部分是很关键的。这一步的加载数据选择了与之前训练时不同的方式，是使用自定义的加载方式来读取数据集。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class testDataset:    &quot;&quot;&quot;    自定义的读取图片的类。    只用于test使用，不返回label。    返回：    第一个值为用于分类的图    第二个值为该图的ID，即名字和后缀    第三个值为用于显示的图    &quot;&quot;&quot;    def __init__(self, data_path):        self.data_path &#x3D; data_path        self.imgList &#x3D; os.listdir(self.data_path)    def __getitem__(self, index):        imgID &#x3D; self.imgList[index]        img &#x3D; cv2.imread(os.path.join(self.data_path, imgID))        # 图像预处理        img &#x3D; cv2.resize(img, (256, 256))        img &#x3D; cv2.cvtColor(img, cv2.COLOR_BGR2RGB)        img &#x3D; img.astype(np.float32)        return img, imgID, img    def __len__(self):        return len(self.imgList)# 读取测试数据并做预处理testData &#x3D; testDataset(test_data_path)# image用于分类处理；imgID为图片名字和后缀；imageInit用于显示原图dataset &#x3D; ds.GeneratorDataset(testData, [&quot;image&quot;, &quot;imgID&quot;, &quot;imageInit&quot;])# 图像预处理，主要是归一化和通道交换顺序mean &#x3D; [0.485 * 255, 0.456 * 255, 0.406 * 255]std &#x3D; [0.229 * 255, 0.224 * 255, 0.225 * 255]dataset &#x3D; dataset.map(operations&#x3D;[CV.Normalize(mean&#x3D;mean, std&#x3D;std), CV.HWC2CHW()],                      input_columns&#x3D;&quot;image&quot;,                      num_parallel_workers&#x3D;8)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一部分可能比较难理解。</p><p>首先自己定义了一个<code>testDataset</code>类去读取数据集并做简单的预处理，这个类的<code>__getitem__</code>函数返回三个值，分别是img，imgID，img。这三个值代表什么含义我在类的介绍里写了，可以去理解一下。</p><p><code>ds.GeneratorDataset</code>这个函数可以创建一个<code>dataset</code>。第一个参数就填写之前写的<code>testDataset</code>类的实例结果，第二个参数填写“列名称”。这个“列名称”也就是<code>column_names</code>参数，我认为可以理解为通道名称。之前<code>testDataset</code>类的<code>__getitem__</code>函数可以返回三个值，这三个值可以通过<code>ds.GeneratorDataset</code>函数赋予每个值一个单独的名称，之后就可以通过这个“名称”调用对应的数据。</p><p>这部分可能难理解，我说的可能也不够详细和简洁，所以建议这部分单步调试，一点一点搞懂这个几个函数的用法比较好。</p><p>之后就是对图像进行归一化和通道数改变顺序的基本操作。</p><h3 id="预测过程"><a href="#预测过程" class="headerlink" title="预测过程"></a>预测过程</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 用于存放预测结果pred_list &#x3D; []# 存放显示图片img_list &#x3D; []# 图片名字imgID_list &#x3D; []# 扩充维度expand &#x3D; ExpandDims()for data in dataset.create_dict_iterator():    # 将图像添加到待显示图片列表中    img_list.append(data[&quot;imageInit&quot;].asnumpy())    imgID_list.append(str(data[&quot;imgID&quot;]))    # 使用处理后的图像来预测    image &#x3D; data[&quot;image&quot;].asnumpy()    # 扩充维度    img &#x3D; expand(Tensor(image), 0)    output &#x3D; model.predict(img)    pred &#x3D; np.argmax(output.asnumpy(), axis&#x3D;1)[0]    pred_list.append(pred)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我这里的预测没有使用batch_size的格式，而是一张一张图片的预测，所以需要进行一个扩维的操作。</p><p>如果是batch_size格式的话需要在这之前对数据集进行batch处理。</p><p>模型最后的输出也就是pred是数字，这个数字与数据集的种类对应。具体的对应关系可以从class_name字典中获得。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 可视化模型预测plt.figure(figsize&#x3D;(12, 5))# 显示24张图for i in range(len(img_list)):    plt.subplot(3, 9, i+1)    plt.title(&#39;&#123;&#125;&#39;.format(class_name[pred_list[i]]))    picture_show &#x3D; img_list[i]&#x2F;np.amax(img_list[i])    picture_show &#x3D; np.clip(picture_show, 0, 1)    plt.imshow(picture_show)    plt.axis(&#39;off&#39;)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可视化输出。可以显示预测结果和对应图片。</p><p>注意，这里显示的图片来自<code>imageInit</code>通道，因为<code>image</code>通道的图片都被归一化和通道顺序转换了所以没法直接用来显示。</p><p>可视化效果：</p><p><img src="/posts/18/1.png" alt="可视化效果"></p><h2 id="六、完整代码下载"><a href="#六、完整代码下载" class="headerlink" title="六、完整代码下载"></a>六、完整代码下载</h2><p><a href="https://github.com/LightningLeader/MindSpore_classify">Github</a></p><p><a href="https://download.csdn.net/download/ZhuanShangNiDeXin/85149846">CSDN</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> MindSpore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PX4飞控-uORB主题的发布与订阅</title>
      <link href="posts/17.html"/>
      <url>posts/17.html</url>
      
        <content type="html"><![CDATA[<h1 id="PX4飞控-uORB主题的发布与订阅"><a href="#PX4飞控-uORB主题的发布与订阅" class="headerlink" title="PX4飞控-uORB主题的发布与订阅"></a>PX4飞控-uORB主题的发布与订阅</h1><a id="more"></a><h3 id="一、添加msg文件"><a href="#一、添加msg文件" class="headerlink" title="一、添加msg文件"></a>一、添加msg文件</h3><p>在<code>源代码目录/msg</code>文件夹下新建一个<code>.msg</code>文件。文件内容如下。</p><p><img src="/posts/17/1.png" alt="1"></p><p>其中test1、test2、test3均为自定义的变量。timestamp为时间戳。</p><h3 id="二、-修改CMakeLists-txt文件"><a href="#二、-修改CMakeLists-txt文件" class="headerlink" title="二、 修改CMakeLists.txt文件"></a>二、 修改CMakeLists.txt文件</h3><p>在同目录下找到<code>CMakeLists.txt</code>文件，打开后添加刚才定义的<code>.msg</code>文件。</p><p><img src="/posts/17/2.png" alt="2"></p><h3 id="三、-编译源代码"><a href="#三、-编译源代码" class="headerlink" title="三、 编译源代码"></a>三、 编译源代码</h3><p>编译完源代码后，进入<code>源代码目录/build/px4_fmu-v2_default/uORB/topics</code>文件夹，找到与之前新建的<code>.msg</code>文件同名的<code>.h</code>文件。在我这里即为<code>test_uorb.h</code>文件。</p><p>可以打开这个文件查看内容。</p><p><img src="/posts/17/3.png" alt="3"></p><p>里面有一个<code>test_uorb_s</code>的结构体，这个结构体里面包含之前定义的几个变量。</p><h3 id="四、编写发布文件"><a href="#四、编写发布文件" class="headerlink" title="四、编写发布文件"></a>四、编写发布文件</h3><p><code>.c</code>文件编写：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;** * @file px4_uorb_adver_app.c *&#x2F;#include &lt;stdio.h&gt;#include &lt;termios.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdbool.h&gt;#include &lt;errno.h&gt;#include &lt;drivers&#x2F;drv_hrt.h&gt;#include &lt;systemlib&#x2F;err.h&gt;#include &lt;fcntl.h&gt;#include &lt;systemlib&#x2F;mavlink_log.h&gt;#include &lt;uORB&#x2F;uORB.h&gt;#include &lt;uORB&#x2F;topics&#x2F;test_uorb.h&gt;#include &lt;px4_platform_common&#x2F;log.h&gt;#include  &lt;px4_platform_common&#x2F;px4_config.h&gt;#include  &lt;px4_platform_common&#x2F;tasks.h&gt;#include  &lt;px4_platform_common&#x2F;time.h&gt;#include  &lt;px4_platform_common&#x2F;posix.h&gt;&#x2F;&#x2F;#include  &lt;px4_platform_common&#x2F;shutdown.h&gt;    &#x2F;&#x2F; 包含就会报错#include  &lt;px4_platform_common&#x2F;defines.h&gt;static bool thread_should_exit &#x3D; false;&#x2F;**&lt; daemon exit flag *&#x2F;static bool thread_running &#x3D; false;&#x2F;**&lt; daemon status flag *&#x2F;static int px4_uorb_adver_task;&#x2F;**&lt; Handle of daemon task &#x2F; thread *&#x2F;&#x2F;** * daemon management function. *&#x2F;__EXPORT int px4_uorb_adver_main(int argc, char *argv[]);&#x2F;** * Mainloop of daemon. *&#x2F;int px4_uorb_adver_thread_main(int argc, char *argv[]);&#x2F;** * Print the correct usage. *&#x2F;static void usage(const char *reason);static voidusage(const char *reason)&#123;if (reason) &#123;warnx(&quot;%s\n&quot;, reason);&#125;warnx(&quot;usage: px4_uorb_adver &#123;start|stop|status&#125; [-p &lt;additional params&gt;]\n\n&quot;);&#125;&#x2F;**消息发布进程，会不断的发送自定义的消息**&#x2F;int px4_uorb_adver_main(int argc, char *argv[])&#123;if (argc &lt; 2) &#123;usage(&quot;missing command&quot;);return 1;&#125;if (!strcmp(argv[1], &quot;start&quot;)) &#123;if (thread_running) &#123;warnx(&quot;daemon already running\n&quot;);&#x2F;* this is not an error *&#x2F;return 0;&#125;thread_should_exit &#x3D; false;&#x2F;&#x2F;定义一个守护进程px4_uorb_adver_task &#x3D; px4_task_spawn_cmd(&quot;px4_uorb_adver&quot;, SCHED_DEFAULT, SCHED_PRIORITY_DEFAULT,&#x2F;&#x2F;调度优先级 2000,&#x2F;&#x2F;堆栈分配大小 px4_uorb_adver_thread_main, (argv) ? (char *const *)&amp;argv[2] : (char *const *)NULL);return 0;&#125;if (!strcmp(argv[1], &quot;stop&quot;)) &#123;thread_should_exit &#x3D; true;return 0;&#125;if (!strcmp(argv[1], &quot;status&quot;)) &#123;if (thread_running) &#123;warnx(&quot;\trunning\n&quot;);&#125; else &#123;warnx(&quot;\tnot started\n&quot;);&#125;return 0;&#125;usage(&quot;unrecognized command&quot;);return 1;&#125;int px4_uorb_adver_thread_main(int argc, char *argv[])&#123;        struct test_uorb_s test_uorb_ad;   &#x2F;&#x2F; 自定义消息的结构体        &#x2F;&#x2F; 初始化数据 全零        memset(&amp;test_uorb_ad, 0 , sizeof(test_uorb_ad));        &#x2F;&#x2F; 公告主题        orb_advert_t test_pub &#x3D; orb_advertise(ORB_ID(test_uorb), &amp;test_uorb_ad);warnx(&quot;[daemon] starting\n&quot;);thread_running &#x3D; true;&#x2F;&#x2F; 每隔1s 发布一次新的数据while (!thread_should_exit) &#123;        test_uorb_ad.test1 &#x3D; 5;        test_uorb_ad.test2 &#x3D; 6;        test_uorb_ad.test3 &#x3D; 7;orb_publish(ORB_ID(test_uorb), test_pub, &amp;test_uorb_ad);usleep(1000);&#125;warnx(&quot;[daemon] exiting.\n&quot;);thread_running &#x3D; false;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>CMakeLists.txt</code>文件编写：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">##############################################################################   Copyright (c) 2015 PX4 Development Team. All rights reserved.## Redistribution and use in source and binary forms, with or without# modification, are permitted provided that the following conditions# are met:## 1. Redistributions of source code must retain the above copyright#    notice, this list of conditions and the following disclaimer.# 2. Redistributions in binary form must reproduce the above copyright#    notice, this list of conditions and the following disclaimer in#    the documentation and&#x2F;or other materials provided with the#    distribution.# 3. Neither the name PX4 nor the names of its contributors may be#    used to endorse or promote products derived from this software#    without specific prior written permission.## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS# &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE# POSSIBILITY OF SUCH DAMAGE.#############################################################################px4_add_module(MODULE modules__px4_uorb_adverMAIN px4_uorb_adverSTACK_MAIN 2000  #程序堆栈大小SRCSpx4_uorb_adver.cDEPENDS)# vim: set noet ft&#x3D;cmake fenc&#x3D;utf-8 ff&#x3D;unix : <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="五、-编写订阅文件"><a href="#五、-编写订阅文件" class="headerlink" title="五、 编写订阅文件"></a>五、 编写订阅文件</h3><p><code>.c</code>文件编写：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;** * @file px4_uorb_subs.c *&#x2F;#include &lt;stdio.h&gt;#include &lt;termios.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdbool.h&gt;#include &lt;errno.h&gt;#include &lt;drivers&#x2F;drv_hrt.h&gt;#include &lt;systemlib&#x2F;err.h&gt;#include &lt;fcntl.h&gt;#include &lt;systemlib&#x2F;mavlink_log.h&gt;#include &lt;uORB&#x2F;uORB.h&gt;#include &lt;uORB&#x2F;topics&#x2F;test_uorb.h&gt;#include &lt;px4_platform_common&#x2F;log.h&gt;#include  &lt;px4_platform_common&#x2F;px4_config.h&gt;#include  &lt;px4_platform_common&#x2F;tasks.h&gt;#include  &lt;px4_platform_common&#x2F;time.h&gt;#include  &lt;px4_platform_common&#x2F;posix.h&gt;&#x2F;&#x2F;#include  &lt;px4_platform_common&#x2F;shutdown.h&gt;    &#x2F;&#x2F; 包含就会报错#include  &lt;px4_platform_common&#x2F;defines.h&gt;static bool thread_should_exit &#x3D; false;&#x2F;**&lt; px4_uorb_subs exit flag *&#x2F;static bool thread_running &#x3D; false;&#x2F;**&lt; px4_uorb_subs status flag *&#x2F;static int px4_uorb_subs_task;&#x2F;**&lt; Handle of px4_uorb_subs task &#x2F; thread *&#x2F;&#x2F;** * daemon management function. *&#x2F;__EXPORT int px4_uorb_subs_main(int argc, char *argv[]);&#x2F;** * Mainloop of daemon. *&#x2F;int px4_uorb_subs_thread_main(int argc, char *argv[]);&#x2F;** * Print the correct usage. *&#x2F;static void usage(const char *reason);static voidusage(const char *reason)&#123;if (reason) &#123;warnx(&quot;%s\n&quot;, reason);&#125;warnx(&quot;usage: px4_uorb_adver &#123;start|stop|status&#125; [-p &lt;additional params&gt;]\n\n&quot;);&#125;&#x2F;**消息发布进程，会不断的接收自定义消息 *&#x2F;int px4_uorb_subs_main(int argc, char *argv[])&#123;if (argc &lt; 2) &#123;usage(&quot;missing command&quot;);return 1;&#125;if (!strcmp(argv[1], &quot;start&quot;)) &#123;if (thread_running) &#123;warnx(&quot;px4_uorb_subs already running\n&quot;);&#x2F;* this is not an error *&#x2F;return 0;&#125;thread_should_exit &#x3D; false;&#x2F;&#x2F;定义一个守护进程px4_uorb_subs_task &#x3D; px4_task_spawn_cmd(&quot;px4_uorb_subs&quot;, SCHED_DEFAULT, SCHED_PRIORITY_DEFAULT,&#x2F;&#x2F;调度优先级 2000,&#x2F;&#x2F;堆栈分配大小 px4_uorb_subs_thread_main, (argv) ? (char *const *)&amp;argv[2] : (char *const *)NULL);return 0;&#125;if (!strcmp(argv[1], &quot;stop&quot;)) &#123;thread_should_exit &#x3D; true;return 0;&#125;if (!strcmp(argv[1], &quot;status&quot;)) &#123;if (thread_running) &#123;warnx(&quot;\trunning\n&quot;);&#125; else &#123;warnx(&quot;\tnot started\n&quot;);&#125;return 0;&#125;usage(&quot;unrecognized command&quot;);return 1;&#125;int px4_uorb_subs_thread_main(int argc, char *argv[])&#123;warnx(&quot;[px4_uorb_subs] starting\n&quot;);&#x2F;&#x2F; 订阅主题    int test_sub_fd &#x3D; orb_subscribe(ORB_ID(test_uorb));    &#x2F;&#x2F; 初始化结构体    struct test_uorb_s test_uorb_sub;    &#x2F;&#x2F; 初始化数据 全零    memset(&amp;test_uorb_sub, 0 , sizeof(test_uorb_sub));    &#x2F;&#x2F; 定义变量    int test1 &#x3D; 0,test2 &#x3D; 0,test3 &#x3D; 0;thread_running &#x3D; true;while (!thread_should_exit) &#123;warnx(&quot;Hello px4_uorb_subs!\n&quot;);        bool updated;&#x2F;* Check if vehicle control mode has changed *&#x2F;        &#x2F;&#x2F; 检查是否更新orb_check(test_sub_fd, &amp;updated);if (updated)    &#123;    &#x2F;&#x2F; copy数据        orb_copy(ORB_ID(test_uorb),test_sub_fd,&amp;test_uorb_sub);        &#x2F;&#x2F; 赋值到变量        test1 &#x3D; test_uorb_sub.test1;        test2 &#x3D; test_uorb_sub.test2;        test3 &#x3D;  test_uorb_sub.test3;&#125;&#x2F;&#x2F; 打印warnx(&quot;test_uorb.test1 &#x3D; %d, test_uorb.test2 &#x3D; %d ,test_uorb.test3 &#x3D; %d\n&quot;,test1,test2,test3);    usleep(500);&#125;warnx(&quot;[px4_uorb_subs] exiting.\n&quot;);thread_running &#x3D; false;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>CMakeLists.txt</code>文件编写：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">##############################################################################   Copyright (c) 2015 PX4 Development Team. All rights reserved.## Redistribution and use in source and binary forms, with or without# modification, are permitted provided that the following conditions# are met:## 1. Redistributions of source code must retain the above copyright#    notice, this list of conditions and the following disclaimer.# 2. Redistributions in binary form must reproduce the above copyright#    notice, this list of conditions and the following disclaimer in#    the documentation and&#x2F;or other materials provided with the#    distribution.# 3. Neither the name PX4 nor the names of its contributors may be#    used to endorse or promote products derived from this software#    without specific prior written permission.## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS# &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE# POSSIBILITY OF SUCH DAMAGE.#############################################################################px4_add_module(MODULE modules__px4_uorb_subsMAIN px4_uorb_subsSTACK_MAIN 2000  #程序堆栈大小SRCSpx4_uorb_subs.cDEPENDS)# vim: set noet ft&#x3D;cmake fenc&#x3D;utf-8 ff&#x3D;unix : <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="六、测试"><a href="#六、测试" class="headerlink" title="六、测试"></a>六、测试</h3><p>编写完之后就可以正常的进行调用然后测试效果了。</p><p>需要先运行发布脚本再运行订阅脚本才能有效果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> PX4 </tag>
            
            <tag> 无人机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PX4飞控-自定义发送MavLink消息</title>
      <link href="posts/16.html"/>
      <url>posts/16.html</url>
      
        <content type="html"><![CDATA[<h1 id="PX4飞控-自定义发送MavLink消息"><a href="#PX4飞控-自定义发送MavLink消息" class="headerlink" title="PX4飞控-自定义发送MavLink消息"></a>PX4飞控-自定义发送MavLink消息</h1><a id="more"></a><h3 id="一、自定义XML文件"><a href="#一、自定义XML文件" class="headerlink" title="一、自定义XML文件"></a>一、自定义XML文件</h3><p><img src="/posts/16/1.png" alt="1"></p><p>如图所示。</p><p>这相当于定义了一个结构体，结构体里面就有一个类型为uint8_t的u8元素。</p><p>使用的id端口为150，这里注意不要与已经存在的id重复。</p><h3 id="二、使用XML文件生成对应的头文件"><a href="#二、使用XML文件生成对应的头文件" class="headerlink" title="二、使用XML文件生成对应的头文件"></a>二、使用XML文件生成对应的头文件</h3><p>在这里需要使用到一个工具<code>mavlink_generator</code>，它的安装方法比较简单。</p><p>在命令行依次输入下方命令即可完成安装：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">git clone https:&#x2F;&#x2F;github.com&#x2F;mavlink&#x2F;mavlink.gitcd mavlink    git submodule update --init --recursive    python -m mavgenerate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后会弹出下图界面：</p><p><img src="/posts/16/2.png" alt="2"></p><p>点击第一个Browse，选择之前新建的XML文件。</p><p>点击第二个Browse，选择最终的输出文件夹。</p><p>将Language切换为C，其他保持默认。</p><p>最终选择界面如下图所示</p><p><img src="/posts/16/3.png" alt="3"></p><p>点击Generate按钮，会弹出一个窗口，点击OK即可。</p><p><img src="/posts/16/4.png" alt="4"></p><p>最后成功生成最终文件。</p><h3 id="三、将生成的头文件添加到源代码中"><a href="#三、将生成的头文件添加到源代码中" class="headerlink" title="三、将生成的头文件添加到源代码中"></a>三、将生成的头文件添加到源代码中</h3><p>在生成目录找到<code>mavlink_msg_mytestmessage.h</code>（这个文件名不是固定的，根据个人定义而不同。）</p><p>将这个文件复制到源代码/mavlink/include/mavlink/v2.0/common目录下。</p><p>同时在同目录的<code>common.h</code>文件中添加刚才复制的头文件。</p><p><img src="/posts/16/5.png" alt="5"></p><h3 id="四、-修改mavlink-messages-cpp文件"><a href="#四、-修改mavlink-messages-cpp文件" class="headerlink" title="四、 修改mavlink_messages.cpp文件"></a>四、 修改mavlink_messages.cpp文件</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">class MavlinkMytestMessage : public MavlinkStream&#123;public:const char *get_name() const override&#123;return MavlinkMytestMessage::get_name_static();&#125;static constexpr const char *get_name_static()&#123;return &quot;MytestMessage&quot;;&#125;static constexpr uint16_t get_id_static()&#123;return MAVLINK_MSG_ID_TEST_TYPES;&#125;uint16_t get_id() override&#123;return get_id_static();&#125;bool const_rate() override&#123;return true;&#125;static MavlinkStream *new_instance(Mavlink *mavlink)&#123;return new MavlinkMytestMessage(mavlink);&#125;unsigned get_size() override&#123;return MAVLINK_MSG_ID_TEST_TYPES_LEN + MAVLINK_NUM_NON_PAYLOAD_BYTES;&#125;private:&#x2F;* do not allow top copying this class *&#x2F;MavlinkMytestMessage(MavlinkMytestMessage &amp;) ;MavlinkMytestMessage &amp;operator &#x3D; (const MavlinkMytestMessage &amp;) ;protected:explicit MavlinkMytestMessage(Mavlink *mavlink) : MavlinkStream(mavlink)&#123;&#125;~MavlinkMytestMessage()&#123;&#125;    &#x2F;* 发送函数 *&#x2F;bool send(const hrt_abstime t) override&#123;        &#x2F;* 创建结构体 *&#x2F;mavlink_test_types_t test;        &#x2F;* 结构体变量赋值 *&#x2F;test.u8 &#x3D; 150;        &#x2F;* 发送函数 *&#x2F;mavlink_msg_test_types_send_struct(_mavlink-&gt;get_channel(), &amp;test);return true;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>mavlink_messages.cpp</code>文件中添加如上面代码差不多的类。有一些地方需要对应起来，也可以参考这个文件中其他类的定义来进行修改和理解。</p><p>添加完自定义的类之后还需要修改<code>static const StreamListItem streams_list</code>这个列表。</p><p>这个列表里面存放着目前所有需要输出的Mavlink消息，可以根据自己的需要进行取舍，注释掉不需要的消息。</p><p>要发送自定义的消息，就需要把刚才自定义的类添加到这个列表中来。</p><p><img src="/posts/16/6.png" alt="6"></p><h3 id="五、-修改mavlink-main-cpp文件"><a href="#五、-修改mavlink-main-cpp文件" class="headerlink" title="五、 修改mavlink_main.cpp文件"></a>五、 修改mavlink_main.cpp文件</h3><p>需要在<code>Mavlink::configure_streams_to_default(const char *configure_single_stream)</code>这个函数里面添加要发送的消息。（位置差不多在函数尾处）</p><p><img src="/posts/16/7.png" alt="7"></p><p>这个函数第二个参数是发送速率，可以通过修改它来更改发送速率。</p><h3 id="六、-上传固件"><a href="#六、-上传固件" class="headerlink" title="六、 上传固件"></a>六、 上传固件</h3><p>编译已经修改过的源代码，并上传到飞行器中。之后查看Mavlink消息就会找到自己定义的消息了。</p><p>推荐测试的时候把其他所有消息全部注释，只留自己自定义的消息，这样可以更清晰的看到输出结果。</p><p>QGC地面站可能无法正常查看到自己自定义的消息，可能还需要进一步修改地面站的配置。所以这里还是推荐使用串口助手直接调试查看。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> PX4 </tag>
            
            <tag> 无人机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YOLOv5简易使用教程</title>
      <link href="posts/15.html"/>
      <url>posts/15.html</url>
      
        <content type="html"><![CDATA[<h1 id="YOLOv5简易使用笔记"><a href="#YOLOv5简易使用笔记" class="headerlink" title="YOLOv5简易使用笔记"></a>YOLOv5简易使用笔记</h1><a id="more"></a><p>前言：</p><p>这篇博客只是简单记录下YOLOv5的使用方式，并不会详细介绍代码含义之类的。</p><h3 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h3><ul><li><p>YOLOv5</p></li><li><p>Python 3.8.1</p></li></ul><h3 id="YOLOv5目录介绍"><a href="#YOLOv5目录介绍" class="headerlink" title="YOLOv5目录介绍"></a>YOLOv5目录介绍</h3><p>从Github上下载解压好最新的YOLOv5文件后的目录如下图</p><p><img src="/posts/15/1.png"></p><p><strong>data</strong>文件夹里面放着<code>yaml</code>文件，就是数据集的一些配置，是比较重要的，在训练自己数据集的时候会用到这个文件夹。</p><p><strong>model</strong>文件夹里面放着一些官方的参数模型，里面有4个<code>yaml</code>文件分别对应着不同的模型参数，在自己训练的时候会用到这4个文件。</p><p><strong>detect.py</strong>这个是用来测试模型效果的。</p><p><strong>train.py</strong>这个是用来训练自己模型的。</p><p>自己进行训练或检测模型后还会多一个<strong>run</strong>文件夹，这个里面会存放检测模型的效果和训练的模型。</p><h3 id="train-py-介绍"><a href="#train-py-介绍" class="headerlink" title="train.py 介绍"></a>train.py 介绍</h3><p>首先介绍一下train.py。我们自己可以使用这个py文件来训练自己的模型。</p><p>其中需要了解的是<code>parse_opt</code>函数，这个是重点。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def parse_opt(known&#x3D;False):    parser &#x3D; argparse.ArgumentParser()    # 模型选择 不填表示从头开始训练 也可以指定模型进行训练    parser.add_argument(&#39;--weights&#39;, type&#x3D;str, default&#x3D;&#39;&#39;, help&#x3D;&#39;initial weights path&#39;)    # 配置模型    parser.add_argument(&#39;--cfg&#39;, type&#x3D;str, default&#x3D;&#39;models&#x2F;yolov5s.yaml&#39;, help&#x3D;&#39;model.yaml path&#39;)    # 指定训练数据集    parser.add_argument(&#39;--data&#39;, type&#x3D;str, default&#x3D;&#39;data&#x2F;mytrain.yaml&#39;, help&#x3D;&#39;dataset.yaml path&#39;)    # 超参数    parser.add_argument(&#39;--hyp&#39;, type&#x3D;str, default&#x3D;&#39;data&#x2F;hyps&#x2F;hyp.scratch.yaml&#39;, help&#x3D;&#39;hyperparameters path&#39;)    # 迭代次数 500到1000次    parser.add_argument(&#39;--epochs&#39;, type&#x3D;int, default&#x3D;300)    # 一次对多少数据进行训练  数值越大对显卡要求越高了。    parser.add_argument(&#39;--batch-size&#39;, type&#x3D;int, default&#x3D;16, help&#x3D;&#39;total batch size for all GPUs&#39;)    # 图片缩放尺寸    parser.add_argument(&#39;--imgsz&#39;, &#39;--img&#39;, &#39;--img-size&#39;, type&#x3D;int, default&#x3D;640, help&#x3D;&#39;train, val image size (pixels)&#39;)    parser.add_argument(&#39;--rect&#39;, action&#x3D;&#39;store_true&#39;, help&#x3D;&#39;rectangular training&#39;)    # 可以修改这个参数来在以前的模型基础上训练 但是需要原来的路径和文件    parser.add_argument(&#39;--resume&#39;, nargs&#x3D;&#39;?&#39;, const&#x3D;True, default&#x3D;&quot;runs&#x2F;train&#x2F;exp&#x2F;weights&#x2F;last.pt&quot;, help&#x3D;&#39;resume most recent training&#39;)    parser.add_argument(&#39;--nosave&#39;, action&#x3D;&#39;store_true&#39;, help&#x3D;&#39;only save final checkpoint&#39;)    parser.add_argument(&#39;--noval&#39;, action&#x3D;&#39;store_true&#39;, help&#x3D;&#39;only validate final epoch&#39;)    parser.add_argument(&#39;--noautoanchor&#39;, action&#x3D;&#39;store_true&#39;, help&#x3D;&#39;disable autoanchor check&#39;)    # 调优方式    parser.add_argument(&#39;--evolve&#39;, type&#x3D;int, nargs&#x3D;&#39;?&#39;, const&#x3D;300, help&#x3D;&#39;evolve hyperparameters for x generations&#39;)    parser.add_argument(&#39;--bucket&#39;, type&#x3D;str, default&#x3D;&#39;&#39;, help&#x3D;&#39;gsutil bucket&#39;)    parser.add_argument(&#39;--cache&#39;, type&#x3D;str, nargs&#x3D;&#39;?&#39;, const&#x3D;&#39;ram&#39;, help&#x3D;&#39;--cache images in &quot;ram&quot; (default) or &quot;disk&quot;&#39;)    parser.add_argument(&#39;--image-weights&#39;, action&#x3D;&#39;store_true&#39;, help&#x3D;&#39;use weighted image selection for training&#39;)    parser.add_argument(&#39;--device&#39;, default&#x3D;&#39;&#39;, help&#x3D;&#39;cuda device, i.e. 0 or 0,1,2,3 or cpu&#39;)    parser.add_argument(&#39;--multi-scale&#39;, action&#x3D;&#39;store_true&#39;, help&#x3D;&#39;vary img-size +&#x2F;- 50%%&#39;)    parser.add_argument(&#39;--single-cls&#39;, action&#x3D;&#39;store_true&#39;, help&#x3D;&#39;train multi-class data as single-class&#39;)    parser.add_argument(&#39;--adam&#39;, action&#x3D;&#39;store_true&#39;, help&#x3D;&#39;use torch.optim.Adam() optimizer&#39;)    parser.add_argument(&#39;--sync-bn&#39;, action&#x3D;&#39;store_true&#39;, help&#x3D;&#39;use SyncBatchNorm, only available in DDP mode&#39;)    parser.add_argument(&#39;--workers&#39;, type&#x3D;int, default&#x3D;8, help&#x3D;&#39;maximum number of dataloader workers&#39;)    parser.add_argument(&#39;--project&#39;, default&#x3D;&#39;runs&#x2F;train&#39;, help&#x3D;&#39;save to project&#x2F;name&#39;)    parser.add_argument(&#39;--entity&#39;, default&#x3D;None, help&#x3D;&#39;W&amp;B entity&#39;)    parser.add_argument(&#39;--name&#39;, default&#x3D;&#39;exp&#39;, help&#x3D;&#39;save to project&#x2F;name&#39;)    parser.add_argument(&#39;--exist-ok&#39;, action&#x3D;&#39;store_true&#39;, help&#x3D;&#39;existing project&#x2F;name ok, do not increment&#39;)    parser.add_argument(&#39;--quad&#39;, action&#x3D;&#39;store_true&#39;, help&#x3D;&#39;quad dataloader&#39;)    # 学习速率    parser.add_argument(&#39;--linear-lr&#39;, action&#x3D;&#39;store_true&#39;, help&#x3D;&#39;linear LR&#39;)    parser.add_argument(&#39;--label-smoothing&#39;, type&#x3D;float, default&#x3D;0.0, help&#x3D;&#39;Label smoothing epsilon&#39;)    parser.add_argument(&#39;--upload_dataset&#39;, action&#x3D;&#39;store_true&#39;, help&#x3D;&#39;Upload dataset as W&amp;B artifact table&#39;)    parser.add_argument(&#39;--bbox_interval&#39;, type&#x3D;int, default&#x3D;-1, help&#x3D;&#39;Set bounding-box image logging interval for W&amp;B&#39;)    parser.add_argument(&#39;--save_period&#39;, type&#x3D;int, default&#x3D;-1, help&#x3D;&#39;Log model after every &quot;save_period&quot; epoch&#39;)    parser.add_argument(&#39;--artifact_alias&#39;, type&#x3D;str, default&#x3D;&quot;latest&quot;, help&#x3D;&#39;version of dataset artifact to be used&#39;)    parser.add_argument(&#39;--local_rank&#39;, type&#x3D;int, default&#x3D;-1, help&#x3D;&#39;DDP parameter, do not modify&#39;)    parser.add_argument(&#39;--freeze&#39;, type&#x3D;int, default&#x3D;0, help&#x3D;&#39;Number of layers to freeze. backbone&#x3D;10, all&#x3D;24&#39;)    opt &#x3D; parser.parse_known_args()[0] if known else parser.parse_args()    return opt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>--weights</code>：这个参数是填写模型的。在<code>default</code>后面可以填写模型路径，下次训练就是在这个模型的基础上训练的。不过一般都是不填写，让它重新训练。</p><p><code>--cfg</code>：这个参数是用来选择模型参数的。一般是使用官方的，就是选择<strong>models</strong>文件夹下那4个文件中的一个。这4个文件每个特点都不同，具体差异可以去Github上看详细介绍。一般都是使用<code>yolov5s.yaml</code>，因为这个又小又快很适合完成小项目。</p><p><code>--data</code>：这个参数是用来指定数据集参数的。就是使用<strong>data</strong>文件夹里面的文件，但要使用的文件是自己定义的，这个地方需要注意。</p><p><img src="/posts/15/2.png"></p><p>​    <strong>train</strong>后面填写训练集路径</p><p>​    <strong>val</strong>后面填写验证集路径</p><p>​    <strong>test</strong>后面填写测试集路径</p><p>​    <strong>nc</strong>后面填写种类数量</p><p>​    <strong>names</strong>后面填写对应的类型名称</p><p><code>--hyp</code>：这个参数是超参数。默认就行，不用改。</p><p><code>--epochs</code>：这个参数设置迭代次数。默认值为300，就是训练总次数。数值越高对显卡要求就越高。一般默认或者提高到500-1000.</p><p><code>--batch-size</code>：每个轮次下图片训练的批次大小。同样对显卡的配置有要求。一般都是默认。</p><p><code>--imgsz</code>：输入图像的分辨率大小，注意这里是训练和mAP测试的图像尺寸，而不是一个图像的宽高。一般默认。</p><p><code>--resume</code>：这个参数是设置是否从上次一次没训练完的地方继续训练。但要求保留原文件。因为训练过程中会在run文件夹下生成对应的训练文件目录，这个参数要求这个训练文件目录还存在。</p><p><img src="/posts/15/3.png"></p><p>目录大概如上图。使用方式就是在default后面填写weights文件夹里面的last.pt路径。例如：default=”runs/train/exp/weights/last.pt”（也可以写绝对路径），不使用的话就填False。</p><p>后面还有很多参数，就不说了，我认为比较常用的就这些。</p><h3 id="detect-py-介绍"><a href="#detect-py-介绍" class="headerlink" title="detect.py 介绍"></a>detect.py 介绍</h3><p>这个文件是用来检测模型效果的。</p><p>其中需要了解的是<code>parse_opt</code>函数。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def parse_opt():    parser &#x3D; argparse.ArgumentParser()    # 权重        在这里可以选择模型    parser.add_argument(&#39;--weights&#39;, nargs&#x3D;&#39;+&#39;, type&#x3D;str, default&#x3D;&#39;mymodels&#x2F;best.pt&#39;, help&#x3D;&#39;model.pt path(s)&#39;)    # 给模型指定检测目录 可以是文件夹下的所有图片、单个图片、本地视频、youtube视频链接、传输协议（视频推流？）    # default&#x3D;&#39;0&#39; 开启摄像头    parser.add_argument(&#39;--source&#39;, type&#x3D;str, default&#x3D;&#39;D:\\myTest\\yolov5_temp\\mydata\\videos\\2.mp4&#39;, help&#x3D;&#39;file&#x2F;dir&#x2F;URL&#x2F;glob, 0 for webcam&#39;)    # 检测过程中的图片大小    parser.add_argument(&#39;--imgsz&#39;, &#39;--img&#39;, &#39;--img-size&#39;, nargs&#x3D;&#39;+&#39;, type&#x3D;int, default&#x3D;[640], help&#x3D;&#39;inference size h,w&#39;)    # 置信度 大于这个数值就认为目标检测成功    parser.add_argument(&#39;--conf-thres&#39;, type&#x3D;float, default&#x3D;0.25, help&#x3D;&#39;confidence threshold&#39;)    # 交并比 交集面积&#x2F;并集面积 大于设定阈值则选择其中一个 小于设定阈值则都选择    parser.add_argument(&#39;--iou-thres&#39;, type&#x3D;float, default&#x3D;0.45, help&#x3D;&#39;NMS IoU threshold&#39;)    parser.add_argument(&#39;--max-det&#39;, type&#x3D;int, default&#x3D;1000, help&#x3D;&#39;maximum detections per image&#39;)    parser.add_argument(&#39;--device&#39;, default&#x3D;&#39;&#39;, help&#x3D;&#39;cuda device, i.e. 0 or 0,1,2,3 or cpu&#39;)    # 实时显示结果 在命令行运行的时候指定参数 python detect.py --view-img    parser.add_argument(&#39;--view-img&#39;, action&#x3D;&#39;store_true&#39;, help&#x3D;&#39;show results&#39;)    # 保存标注信息    parser.add_argument(&#39;--save-txt&#39;, action&#x3D;&#39;store_true&#39;, help&#x3D;&#39;save results to *.txt&#39;)    # 保存置信度    parser.add_argument(&#39;--save-conf&#39;, action&#x3D;&#39;store_true&#39;, help&#x3D;&#39;save confidences in --save-txt labels&#39;)    parser.add_argument(&#39;--save-crop&#39;, action&#x3D;&#39;store_true&#39;, help&#x3D;&#39;save cropped prediction boxes&#39;)    parser.add_argument(&#39;--nosave&#39;, action&#x3D;&#39;store_true&#39;, help&#x3D;&#39;do not save images&#x2F;videos&#39;)    # 过滤不要的类型 只保留需要的类别    parser.add_argument(&#39;--classes&#39;, nargs&#x3D;&#39;+&#39;, type&#x3D;int, help&#x3D;&#39;filter by class: --class 0, or --class 0 2 3&#39;)    # 增强检测    parser.add_argument(&#39;--agnostic-nms&#39;, action&#x3D;&#39;store_true&#39;, help&#x3D;&#39;class-agnostic NMS&#39;)    # 增强检测    parser.add_argument(&#39;--augment&#39;, action&#x3D;&#39;store_true&#39;, help&#x3D;&#39;augmented inference&#39;)    parser.add_argument(&#39;--visualize&#39;, action&#x3D;&#39;store_true&#39;, help&#x3D;&#39;visualize features&#39;)    parser.add_argument(&#39;--update&#39;, action&#x3D;&#39;store_true&#39;, help&#x3D;&#39;update all models&#39;)    # 保存结果    parser.add_argument(&#39;--project&#39;, default&#x3D;&#39;runs&#x2F;detect&#39;, help&#x3D;&#39;save results to project&#x2F;name&#39;)    # 保存名字    parser.add_argument(&#39;--name&#39;, default&#x3D;&#39;exp&#39;, help&#x3D;&#39;save results to project&#x2F;name&#39;)    parser.add_argument(&#39;--exist-ok&#39;, action&#x3D;&#39;store_true&#39;, help&#x3D;&#39;existing project&#x2F;name ok, do not increment&#39;)    parser.add_argument(&#39;--line-thickness&#39;, default&#x3D;3, type&#x3D;int, help&#x3D;&#39;bounding box thickness (pixels)&#39;)    parser.add_argument(&#39;--hide-labels&#39;, default&#x3D;False, action&#x3D;&#39;store_true&#39;, help&#x3D;&#39;hide labels&#39;)    parser.add_argument(&#39;--hide-conf&#39;, default&#x3D;False, action&#x3D;&#39;store_true&#39;, help&#x3D;&#39;hide confidences&#39;)    parser.add_argument(&#39;--half&#39;, action&#x3D;&#39;store_true&#39;, help&#x3D;&#39;use FP16 half-precision inference&#39;)    opt &#x3D; parser.parse_args()    opt.imgsz *&#x3D; 2 if len(opt.imgsz) &#x3D;&#x3D; 1 else 1  # expand    return opt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>--weights</code>：这个参数是用来选择测试的模型。</p><p><code>--source</code>：这个参数是用来选择测试文件目录。可以是单个图片、视频或者文件夹等。</p><p><code>--imgsz</code>：测试中图片大小。默认就行。</p><p><code>--conf-thres</code>：置信度。大于这个数值就认为目标检测成功。可以根据实际情况调整。</p><p><code>--iou-thres</code>：交并比。根据实际情况调整。</p><p><code>--view-img</code>：一边检测一边输出效果。</p><p>用法是</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">python detect.py --view-img<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这些参数都可以使用这种方式来配置。</p><p>其他的参数不多说。</p><p>最后的输出结果在run文件夹下。</p><h3 id="数据集制作—图片标注"><a href="#数据集制作—图片标注" class="headerlink" title="数据集制作—图片标注"></a>数据集制作—图片标注</h3><p>一种是网页在线标注。网址是：<a href="https://www.makesense.ai/">Make Sense</a> 这个怎么使用就不说了，因为我自己不用这个网站标注。</p><p>一种是使用labelimg标注。</p><p>使用下面的命令安装</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pip install labelImg #直接命令行输入<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后在命令行直接输入<code>labelimg</code>就可以打开软件了。</p><p><img src="/posts/15/4.png"></p><p>软件有关介绍如上图。</p><p>使用方式：</p><p>先选择图片目录，再选择输出的保存目录，最后选择保存格式为yolo。</p><p>在图片上按下<code>w</code>键开始框选矩形区域，用这个矩形选中要检测的目标，单击鼠标左键确定、首次使用会让你输入标签，你就输入你想填的标签，再点击OK，就行了。后面再框选的话可以选择之前已经有的标签就不用再打字了。</p><p><img src="/posts/15/5.png"></p><p>标注完一张图片后要记得保存，快捷键<code>ctrl+s</code>。之后再切换到下一张图片进行标注就行了。</p><p>标注一张图片就会生成一个txt文件，这个txt文件就是标注信息，后面自己训练的时候会用到。</p><p><img src="/posts/15/7.png"></p><p>这个就是txt文件内容，最开头的0表示标签类型，也就是对应的标签序号。</p><p>还会有个classes文件，这个里面存放着标签类型和顺序。</p><p>标注是个技术活也是劳力活。因为一般情况下一个模型至少要100或者200多张图片才可以，每张图片都要标的准确不然最后训练的效果会受到影响。</p><h3 id="自己训练模型—本地训练"><a href="#自己训练模型—本地训练" class="headerlink" title="自己训练模型—本地训练"></a>自己训练模型—本地训练</h3><p>首先要准备好自己要训练的数据集，至少要有个几百张吧，然后分成训练集和验证集，数量大概5:1就可以。如果图片数量少的话就不要加验证集了。（不仅仅图片要分，标签信息也要对应着分。）</p><ol><li><p>在目录新建一个文件夹用于存放自己训练的数据集。</p><p><img src="/posts/15/6.png"></p><p>该文件夹下必须包含这两个目录。第一个存放图片，第二个存放标签。（这个标签就是标注后生成的txt文件）</p></li><li><p>在images下新建文件夹，表示训练集、验证集、测试集（没有验证集或者测试集可以不用建），然后把准备好的训练集、验证集或者测试集图片放入对应的文件夹里面就行。文件夹名字应该没有要求，一般都是训练集–train，验证集–val，测试集–test。</p></li><li><p>在labels下新建文件夹，表示训练集、验证集、测试集（没有验证集或者测试集可以不用建），这个地方要与images对应起来。然后把标签信息文件对应放入文件夹就行。</p></li><li><p>打开data文件夹，在这里新建一个自己的yaml文件。</p><p>例如：</p><p><img src="/posts/15/2.png"></p><pre><code> **train**后面填写训练集路径</code></pre><p>​    <strong>val</strong>后面填写验证集路径</p><p>​    <strong>test</strong>后面填写测试集路径</p><p>​    <strong>nc</strong>后面填写种类数量</p><p>​    <strong>names</strong>后面填写对应的类型名称</p><p>按照这样填写然后保存就行。</p></li><li><p>打开train.py。根据自己需要调整一下参数。</p><p>重点注意：<code>--data</code>参数要填写自己刚才配置的yaml文件</p></li><li><p>运行train.py就可以了。如果要GPU训练的话还需要配置cuda，这个方面就自行查找资料吧。</p><p><img src="/posts/15/8.png"></p><p>训练过程差不多就是这样。</p></li></ol><p>训练过程中会在run文件夹下生成对应的文件。在对应的训练中，weights文件夹下的best.pt表示训练过程中最好的模型，last.pt表示最后一次训练的模型。</p><h3 id="自己训练模型—谷歌免费GPU训练"><a href="#自己训练模型—谷歌免费GPU训练" class="headerlink" title="自己训练模型—谷歌免费GPU训练"></a>自己训练模型—谷歌免费GPU训练</h3><p>以后有空再填坑。懂的都懂。</p><p>（其实这个也就那样，谷歌会给你限流，用一会就不能用了。懂的都懂。）</p><h3 id="自己测试模型效果"><a href="#自己测试模型效果" class="headerlink" title="自己测试模型效果"></a>自己测试模型效果</h3><p>这个比较简单。就按照之前介绍detect.py里面的参数填写最后运行就行。但要主要路径不要出现中文，不然可能会报错。</p><p>最后效果会生成在run文件夹下，如果测试的是视频那最终就是生成视频，如果是图片就会生成图片。</p><p>这个是我自己随便搞得一个，效果就是这样。</p><p><img src="/posts/15/9.png"></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"># Write resultsfor *xyxy, conf, cls in reversed(det):    # 标出目标中心点坐标    # c1, c2 &#x3D; (int(xyxy[0]), int(xyxy[1])), (int(xyxy[2]), int(xyxy[3]))    # w &#x3D; c2[0] - c1[0]    # h &#x3D; c1[1] - c2[1]    # cv2.circle(im0, (int(c1[0] + w &#x2F; 2), int(c1[1] - h &#x2F; 2)), 1, (0, 255, 0), 2)    # 根据cls判断目标类型  names[int(cls)] 这个类型与标注对应    # print(&quot;\n&quot; + &quot;class:&quot; + str(int(cls)) + &quot;\n&quot;)    if save_txt:  # Write to file        xywh &#x3D; (xyxy2xywh(torch.tensor(xyxy).view(1, 4)) &#x2F; gn).view(-1).tolist()  # normalized xywh        line &#x3D; (cls, *xywh, conf) if save_conf else (cls, *xywh)  # label format        with open(txt_path + &#39;.txt&#39;, &#39;a&#39;) as f:            f.write((&#39;%g &#39; * len(line)).rstrip() % line + &#39;\n&#39;)    if save_img or save_crop or view_img:  # Add bbox to image        c &#x3D; int(cls)  # integer class        label &#x3D; None if hide_labels else (names[c] if hide_conf else f&#39;&#123;names[c]&#125; &#123;conf:.2f&#125;&#39;)        im0 &#x3D; plot_one_box(xyxy, im0, label&#x3D;label, color&#x3D;colors(c, True), line_width&#x3D;line_thickness)        if save_crop:            save_one_box(xyxy, imc, file&#x3D;save_dir &#x2F; &#39;crops&#39; &#x2F; names[c] &#x2F; f&#39;&#123;p.stem&#125;.jpg&#39;, BGR&#x3D;True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Python </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现堆栈和队列</title>
      <link href="posts/14.html"/>
      <url>posts/14.html</url>
      
        <content type="html"><![CDATA[<h1 id="C语言实现堆栈和队列"><a href="#C语言实现堆栈和队列" class="headerlink" title="C语言实现堆栈和队列"></a>C语言实现堆栈和队列</h1><a id="more"></a><h2 id="堆栈实现（顺序结构）"><a href="#堆栈实现（顺序结构）" class="headerlink" title="堆栈实现（顺序结构）"></a>堆栈实现（顺序结构）</h2><p>base称为栈底指针，在顺序栈中，它始终指向栈底的位置，若base的值为NULL，则表明栈结构不存在。</p><p>top称为栈顶指针，其初值指向栈底，即top=base可作为栈空的标记。每当插入新的栈顶元素时，指针top增1；删除栈顶元素时，指针top减1，因此，非空栈中的栈顶指针始终在栈顶元素的下一个位置上。</p><p><img src="/posts/14/1.jpg" alt="栈顶指针和栈中元素之间地关系"></p><h3 id="定义堆栈"><a href="#定义堆栈" class="headerlink" title="定义堆栈"></a>定义堆栈</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define stack_maxSize 100    &#x2F;&#x2F; 存储空间初始分配量#define stack_increment 10    &#x2F;&#x2F; 存储空间分配增量typedef struct&#123;int* base;    &#x2F;&#x2F; 栈底int* top;    &#x2F;&#x2F; 栈顶int stackMaxSize;    &#x2F;&#x2F; 当前已分配地存储空间&#125;SqStack;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="初始化堆栈"><a href="#初始化堆栈" class="headerlink" title="初始化堆栈"></a>初始化堆栈</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*创建堆栈*&#x2F;void Inistack(SqStack&amp; S)&#123;S.base &#x3D; (int*)malloc(stack_maxSize * sizeof(int));    &#x2F;&#x2F; 分配空间if (!S.base)exit(0);S.top &#x3D; S.base;S.stackMaxSize &#x3D; stack_maxSize;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="判断堆栈是否为空"><a href="#判断堆栈是否为空" class="headerlink" title="判断堆栈是否为空"></a>判断堆栈是否为空</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*判断堆栈是否为空*&#x2F;int isStackEmpty(SqStack S)&#123;if (S.base &#x3D;&#x3D; S.top)return 0;elsereturn 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="取栈顶元素"><a href="#取栈顶元素" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*取栈顶元素*&#x2F;int getTop(SqStack S)&#123;&#x2F;*判断非空*&#x2F;if (!isStackEmpty(S))return 0;return *(S.top - 1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="压入堆栈"><a href="#压入堆栈" class="headerlink" title="压入堆栈"></a>压入堆栈</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*压入堆栈*&#x2F;void push_Stack(SqStack&amp; S, int e)&#123;if (S.top - S.base &gt;&#x3D; S.stackMaxSize)&#123;int* temp &#x3D; (int*)realloc(S.base, (S.stackMaxSize + stack_increment) * sizeof(int));if (!temp)exit(0);S.base &#x3D; temp;S.top &#x3D; S.base + S.stackMaxSize;S.base +&#x3D; stack_increment;&#125;*S.top++ &#x3D; e;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="弹出栈顶元素"><a href="#弹出栈顶元素" class="headerlink" title="弹出栈顶元素"></a>弹出栈顶元素</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*弹出栈顶元素*&#x2F;int pop_stack(SqStack&amp; S)&#123;int temp;if (!isStackEmpty(S))return 0;temp &#x3D; *--S.top;return temp;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="清空栈元素，不释放空间"><a href="#清空栈元素，不释放空间" class="headerlink" title="清空栈元素，不释放空间"></a>清空栈元素，不释放空间</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*清空堆栈元素，不释放空间*&#x2F;void clear_stack(SqStack&amp; S)&#123;if (!isStackEmpty(S))return ;S.top &#x3D; S.base;printf(&quot;清空完成！\n&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="打印堆栈内容"><a href="#打印堆栈内容" class="headerlink" title="打印堆栈内容"></a>打印堆栈内容</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*打印堆栈内容*&#x2F;void show_stack(SqStack S)&#123;if (!isStackEmpty(S))return;while (S.top !&#x3D; S.base)&#123;printf(&quot;%d\t&quot;, *--S.top);&#125;printf(&quot;\n&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="返回堆栈元素个数"><a href="#返回堆栈元素个数" class="headerlink" title="返回堆栈元素个数"></a>返回堆栈元素个数</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*返回堆栈元素个数*&#x2F;int show_NumOfStack(SqStack S)&#123;return (S.top - S.base);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="销毁堆栈，释放空间"><a href="#销毁堆栈，释放空间" class="headerlink" title="销毁堆栈，释放空间"></a>销毁堆栈，释放空间</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*销毁堆栈，释放空间*&#x2F;void destroy_stack(SqStack&amp; S)&#123;if (S.base)&#123;free(S.base);S.base &#x3D; S.top &#x3D; NULL;printf(&quot;销毁成功！\n&quot;);&#125;elseprintf(&quot;销毁失败！\n&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#include &lt;stdlib.h&gt;#define stack_maxSize 100#define stack_increment 10typedef struct&#123;int* base;int* top;int stackMaxSize;&#125;SqStack;&#x2F;*创建堆栈*&#x2F;void Inistack(SqStack&amp; S)&#123;S.base &#x3D; (int*)malloc(stack_maxSize * sizeof(int));if (!S.base)exit(0);S.top &#x3D; S.base;S.stackMaxSize &#x3D; stack_maxSize;&#125;&#x2F;*判断堆栈是否为空*&#x2F;int isStackEmpty(SqStack S)&#123;if (S.base &#x3D;&#x3D; S.top)return 0;elsereturn 1;&#125;&#x2F;*取栈顶元素*&#x2F;int getTop(SqStack S)&#123;&#x2F;*判断非空*&#x2F;if (!isStackEmpty(S))return 0;return *(S.top - 1);&#125;&#x2F;*压入堆栈*&#x2F;void push_Stack(SqStack&amp; S, int e)&#123;if (S.top - S.base &gt;&#x3D; S.stackMaxSize)&#123;int* temp &#x3D; (int*)realloc(S.base, (S.stackMaxSize + stack_increment) * sizeof(int));if (!temp)exit(0);S.base &#x3D; temp;S.top &#x3D; S.base + S.stackMaxSize;S.base +&#x3D; stack_increment;&#125;*S.top++ &#x3D; e;&#125;&#x2F;*弹出栈顶元素*&#x2F;int pop_stack(SqStack&amp; S)&#123;int temp;if (!isStackEmpty(S))return 0;temp &#x3D; *--S.top;return temp;&#125;&#x2F;*清空堆栈元素，不释放空间*&#x2F;void clear_stack(SqStack&amp; S)&#123;if (!isStackEmpty(S))return ;S.top &#x3D; S.base;printf(&quot;清空完成！\n&quot;);&#125;&#x2F;*打印堆栈内容*&#x2F;void show_stack(SqStack S)&#123;if (!isStackEmpty(S))return;while (S.top !&#x3D; S.base)&#123;printf(&quot;%d\t&quot;, *--S.top);&#125;printf(&quot;\n&quot;);&#125;&#x2F;*返回堆栈元素个数*&#x2F;int show_NumOfStack(SqStack S)&#123;return (S.top - S.base);&#125;&#x2F;*销毁堆栈，释放空间*&#x2F;void destroy_stack(SqStack&amp; S)&#123;if (S.base)&#123;free(S.base);S.base &#x3D; S.top &#x3D; NULL;printf(&quot;销毁成功！\n&quot;);&#125;elseprintf(&quot;销毁失败！\n&quot;);&#125;int main()&#123;SqStack myStack;Inistack(myStack);for (int i &#x3D; 0; i &lt; 10; i++)&#123;push_Stack(myStack, i);&#125;show_stack(myStack);for (int i &#x3D; 0; i &lt; 10; i++)&#123;push_Stack(myStack, i);&#125;show_stack(myStack);destroy_stack(myStack);show_stack(myStack);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="堆栈实现（链式结构）"><a href="#堆栈实现（链式结构）" class="headerlink" title="堆栈实现（链式结构）"></a>堆栈实现（链式结构）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct StackNode&#123;int data;struct StackNode* next;&#125;StackNode, *LinkStack;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;*初始化*&#x2F;void InitStack(LinkStack&amp; S)&#123;S &#x3D; NULL;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="判断非空"><a href="#判断非空" class="headerlink" title="判断非空"></a>判断非空</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*判断是否为空*&#x2F;int isEmpty(LinkStack S)&#123;if (S &#x3D;&#x3D; NULL)return 0;return 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="进栈"><a href="#进栈" class="headerlink" title="进栈"></a>进栈</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;*进栈*&#x2F;void pushStack(LinkStack&amp; S, int x)&#123;StackNode* p &#x3D; new StackNode;p-&gt;data &#x3D; x;p-&gt;next &#x3D; S;S &#x3D; p;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*出栈*&#x2F;int popStack(LinkStack&amp; S)&#123;if (!isEmpty(S))exit(0);StackNode* p &#x3D; new StackNode;int x &#x3D; S-&gt;data;p &#x3D; S;S &#x3D; S-&gt;next;delete p;return x;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="取栈顶元素-1"><a href="#取栈顶元素-1" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*取栈顶元素*&#x2F;int getTop(LinkStack S)&#123;if (!isEmpty(S))exit(0);return S-&gt;data;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;*打印*&#x2F;void showStack(LinkStack S)&#123;if (!isEmpty(S))exit(0);StackNode* p &#x3D; new StackNode;p &#x3D; S;while (p !&#x3D; NULL)&#123;printf(&quot;%d\t&quot;, p-&gt;data);p &#x3D; p-&gt;next;&#125;printf(&quot;\n&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#include &lt;stdlib.h&gt;typedef struct StackNode&#123;int data;struct StackNode* next;&#125;StackNode, *LinkStack;&#x2F;*初始化*&#x2F;void InitStack(LinkStack&amp; S)&#123;S &#x3D; NULL;&#125;&#x2F;*判断是否为空*&#x2F;int isEmpty(LinkStack S)&#123;if (S &#x3D;&#x3D; NULL)return 0;return 1;&#125;&#x2F;*进栈*&#x2F;void pushStack(LinkStack&amp; S, int x)&#123;StackNode* p &#x3D; new StackNode;p-&gt;data &#x3D; x;p-&gt;next &#x3D; S;S &#x3D; p;&#125;&#x2F;*出栈*&#x2F;int popStack(LinkStack&amp; S)&#123;if (!isEmpty(S))exit(0);StackNode* p &#x3D; new StackNode;int x &#x3D; S-&gt;data;p &#x3D; S;S &#x3D; S-&gt;next;delete p;return x;&#125;&#x2F;*取栈顶元素*&#x2F;int getTop(LinkStack S)&#123;if (!isEmpty(S))exit(0);return S-&gt;data;&#125;&#x2F;*打印*&#x2F;void showStack(LinkStack S)&#123;if (!isEmpty(S))exit(0);StackNode* p &#x3D; new StackNode;p &#x3D; S;while (p !&#x3D; NULL)&#123;printf(&quot;%d\t&quot;, p-&gt;data);p &#x3D; p-&gt;next;&#125;printf(&quot;\n&quot;);&#125;int main()&#123;LinkStack S;InitStack(S);for (int i &#x3D; 0; i &lt; 10; i++)&#123;pushStack(S, i);&#125;showStack(S);printf(&quot;%d\n&quot;, popStack(S));showStack(S);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="队列实现（顺序结构）"><a href="#队列实现（顺序结构）" class="headerlink" title="队列实现（顺序结构）"></a>队列实现（顺序结构）</h2><p>循环队列</p><p><img src="/posts/14/2.png" alt="循环队列"></p><h3 id="定义队列"><a href="#定义队列" class="headerlink" title="定义队列"></a>定义队列</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define mSize 5typedef struct queue&#123;int front;    &#x2F;&#x2F; 队头元素的前一单元的位置下标int rear;     &#x2F;&#x2F; 队尾元素的位置下标int maxSize;  &#x2F;&#x2F; 队列空间的最大容量int* element; &#x2F;&#x2F; 队列元素的数组首地址&#125;Queue;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="初始化队列"><a href="#初始化队列" class="headerlink" title="初始化队列"></a>初始化队列</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*创建队列*&#x2F;void initQueue(Queue&amp; Q)&#123;Q.maxSize &#x3D; mSize;Q.element &#x3D; (int*)malloc(sizeof(int) * mSize);Q.front &#x3D; Q.rear &#x3D; 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="销毁队列，释放空间"><a href="#销毁队列，释放空间" class="headerlink" title="销毁队列，释放空间"></a>销毁队列，释放空间</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*销毁队列，释放空间*&#x2F;void destroy_Queue(Queue&amp; Q)&#123;free(Q.element);Q.maxSize &#x3D; -1;Q.front &#x3D; Q.rear &#x3D; -1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="清除队列"><a href="#清除队列" class="headerlink" title="清除队列"></a>清除队列</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*清除队列*&#x2F;void clear_queue(Queue&amp; Q)&#123;Q.front &#x3D; Q.rear &#x3D; 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="判断非空-1"><a href="#判断非空-1" class="headerlink" title="判断非空"></a>判断非空</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;*判断非空*&#x2F;int isQueueEmpty(Queue Q)&#123;return Q.front &#x3D;&#x3D; Q.rear;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="判断已满"><a href="#判断已满" class="headerlink" title="判断已满"></a>判断已满</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*判断已满*&#x2F;int isQueueFull(Queue Q)&#123;return ((Q.rear + 1) % Q.maxSize &#x3D;&#x3D; Q.front);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="获取队头元素"><a href="#获取队头元素" class="headerlink" title="获取队头元素"></a>获取队头元素</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;*获取队头元素*&#x2F;void getFront(Queue Q)&#123;if (isQueueEmpty(Q))exit(0);printf(&quot;%d\n&quot;, Q.element[(Q.front + 1) % Q.maxSize]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="队尾插入"><a href="#队尾插入" class="headerlink" title="队尾插入"></a>队尾插入</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*队尾插入*&#x2F;void enQueueRear(Queue&amp; Q, int temp)&#123;if (isQueueFull(Q))exit(0);Q.rear &#x3D; (Q.rear + 1) % Q.maxSize;Q.element[Q.rear] &#x3D; temp;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="队头删除"><a href="#队头删除" class="headerlink" title="队头删除"></a>队头删除</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;*队头删除*&#x2F;void deQueueFront(Queue&amp; Q)&#123;if (isQueueEmpty(Q))exit(0);Q.front &#x3D; (Q.front + 1) % Q.maxSize;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="打印队列"><a href="#打印队列" class="headerlink" title="打印队列"></a>打印队列</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;*打印队列*&#x2F;void show_Queue(Queue Q)&#123;int p &#x3D; Q.front;while (p !&#x3D; Q.rear)&#123;printf(&quot;%d\t&quot;, Q.element[++p]);&#125;printf(&quot;\n&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#include &lt;stdlib.h&gt;#define mSize 5typedef struct queue&#123;int front;int rear;int maxSize;int* element;&#125;Queue;&#x2F;*创建队列*&#x2F;void initQueue(Queue&amp; Q)&#123;Q.maxSize &#x3D; mSize;Q.element &#x3D; (int*)malloc(sizeof(int) * mSize);Q.front &#x3D; Q.rear &#x3D; 0;&#125;&#x2F;*销毁队列，释放空间*&#x2F;void destroy_Queue(Queue&amp; Q)&#123;free(Q.element);Q.maxSize &#x3D; -1;Q.front &#x3D; Q.rear &#x3D; -1;&#125;&#x2F;*清除队列*&#x2F;void clear_queue(Queue&amp; Q)&#123;Q.front &#x3D; Q.rear &#x3D; 0;&#125;&#x2F;*判断非空*&#x2F;int isQueueEmpty(Queue Q)&#123;return Q.front &#x3D;&#x3D; Q.rear;&#125;&#x2F;*判断已满*&#x2F;int isQueueFull(Queue Q)&#123;return ((Q.rear + 1) % Q.maxSize &#x3D;&#x3D; Q.front);&#125;&#x2F;*获取队头元素*&#x2F;void getFront(Queue Q)&#123;if (isQueueEmpty(Q))exit(0);printf(&quot;%d\n&quot;, Q.element[(Q.front + 1) % Q.maxSize]);&#125;&#x2F;*队尾插入*&#x2F;void enQueueRear(Queue&amp; Q, int temp)&#123;if (isQueueFull(Q))exit(0);Q.rear &#x3D; (Q.rear + 1) % Q.maxSize;Q.element[Q.rear] &#x3D; temp;&#125;&#x2F;*队头删除*&#x2F;void deQueueFront(Queue&amp; Q)&#123;if (isQueueEmpty(Q))exit(0);Q.front &#x3D; (Q.front + 1) % Q.maxSize;&#125;&#x2F;*打印队列*&#x2F;void show_Queue(Queue Q)&#123;int p &#x3D; Q.front;while (p !&#x3D; Q.rear)&#123;printf(&quot;%d\t&quot;, Q.element[++p]);&#125;printf(&quot;\n&quot;);&#125;int main()&#123;Queue myQueue;initQueue(myQueue);for (int i &#x3D; 0; i &lt; 4; i++)&#123;enQueueRear(myQueue, i);&#125;show_Queue(myQueue);destroy_Queue(myQueue);show_Queue(myQueue);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="队列实现（链式结构）"><a href="#队列实现（链式结构）" class="headerlink" title="队列实现（链式结构）"></a>队列实现（链式结构）</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct QNode&#123;int data;struct QNode* next;&#125;QNode, *QueuePtr;typedef struct&#123;QueuePtr front;QueuePtr rear;&#125;LinkQueue;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*初始化*&#x2F;void InitQueue(LinkQueue&amp; Q)&#123;Q.front &#x3D; Q.rear &#x3D; (QueuePtr)malloc(sizeof(QNode));if (!Q.front)exit(0);Q.front-&gt;next &#x3D; NULL;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="判断是否为空"><a href="#判断是否为空" class="headerlink" title="判断是否为空"></a>判断是否为空</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;*判断是否为空*&#x2F;int isEmpty(LinkQueue Q)&#123;return (Q.front &#x3D;&#x3D; Q.rear);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*销毁*&#x2F;void destroyQueue(LinkQueue&amp; Q)&#123;if (isEmpty(Q))exit(0);while (Q.front)&#123;Q.rear &#x3D; Q.front-&gt;next;free(Q.front);Q.front &#x3D; Q.rear;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="取队头元素"><a href="#取队头元素" class="headerlink" title="取队头元素"></a>取队头元素</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;*取队头元素*&#x2F;int getFront(LinkQueue Q)&#123;if (isEmpty(Q))exit(0);return Q.front-&gt;next-&gt;data;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;*入队*&#x2F;void enQueue(LinkQueue&amp; Q, int x)&#123;QNode* p &#x3D; (QueuePtr)malloc(sizeof(QNode));if (!p)exit(0);p-&gt;data &#x3D; x;p-&gt;next &#x3D; NULL;Q.rear-&gt;next &#x3D; p;Q.rear &#x3D; p;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;*出队*&#x2F;int deQueue(LinkQueue&amp; Q)&#123;if (isEmpty(Q))exit(0);QNode* p &#x3D; (QueuePtr)malloc(sizeof(QNode));p &#x3D; Q.front-&gt;next;int x &#x3D; p-&gt;data;Q.front-&gt;next &#x3D; p-&gt;next;if (Q.rear &#x3D;&#x3D; p)Q.rear &#x3D; Q.front;free(p);return x;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="打印-1"><a href="#打印-1" class="headerlink" title="打印"></a>打印</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;*打印*&#x2F;void show_Queue(LinkQueue Q)&#123;if (isEmpty(Q))exit(0);QNode* p &#x3D; (QueuePtr)malloc(sizeof(QNode));p &#x3D; Q.front-&gt;next;while (p !&#x3D; NULL)&#123;printf(&quot;%d\t&quot;, p-&gt;data);p &#x3D; p-&gt;next;&#125;printf(&quot;\n&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#include &lt;stdlib.h&gt;typedef struct QNode&#123;int data;struct QNode* next;&#125;QNode, *QueuePtr;typedef struct&#123;QueuePtr front;QueuePtr rear;&#125;LinkQueue;&#x2F;*初始化*&#x2F;void InitQueue(LinkQueue&amp; Q)&#123;Q.front &#x3D; Q.rear &#x3D; (QueuePtr)malloc(sizeof(QNode));if (!Q.front)exit(0);Q.front-&gt;next &#x3D; NULL;&#125;&#x2F;*判断是否为空*&#x2F;int isEmpty(LinkQueue Q)&#123;return (Q.front &#x3D;&#x3D; Q.rear);&#125;&#x2F;*销毁*&#x2F;void destroyQueue(LinkQueue&amp; Q)&#123;if (isEmpty(Q))exit(0);while (Q.front)&#123;Q.rear &#x3D; Q.front-&gt;next;free(Q.front);Q.front &#x3D; Q.rear;&#125;&#125;&#x2F;*取队头元素*&#x2F;int getFront(LinkQueue Q)&#123;if (isEmpty(Q))exit(0);return Q.front-&gt;next-&gt;data;&#125;&#x2F;*入队*&#x2F;void enQueue(LinkQueue&amp; Q, int x)&#123;QNode* p &#x3D; (QueuePtr)malloc(sizeof(QNode));if (!p)exit(0);p-&gt;data &#x3D; x;p-&gt;next &#x3D; NULL;Q.rear-&gt;next &#x3D; p;Q.rear &#x3D; p;&#125;&#x2F;*出队*&#x2F;int deQueue(LinkQueue&amp; Q)&#123;if (isEmpty(Q))exit(0);QNode* p &#x3D; (QueuePtr)malloc(sizeof(QNode));p &#x3D; Q.front-&gt;next;int x &#x3D; p-&gt;data;Q.front-&gt;next &#x3D; p-&gt;next;if (Q.rear &#x3D;&#x3D; p)Q.rear &#x3D; Q.front;free(p);return x;&#125;&#x2F;*打印*&#x2F;void show_Queue(LinkQueue Q)&#123;if (isEmpty(Q))exit(0);QNode* p &#x3D; (QueuePtr)malloc(sizeof(QNode));p &#x3D; Q.front-&gt;next;while (p !&#x3D; NULL)&#123;printf(&quot;%d\t&quot;, p-&gt;data);p &#x3D; p-&gt;next;&#125;printf(&quot;\n&quot;);&#125;int main()&#123;LinkQueue Q;InitQueue(Q);for (int i &#x3D; 0; i &lt; 10; i++)&#123;enQueue(Q, i);&#125;show_Queue(Q);printf(&quot;%d\n&quot;, deQueue(Q));show_Queue(Q);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Skimage库使用</title>
      <link href="posts/13.html"/>
      <url>posts/13.html</url>
      
        <content type="html"><![CDATA[<h1 id="Skimage库使用"><a href="#Skimage库使用" class="headerlink" title="Skimage库使用"></a>Skimage库使用</h1><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近发现Skimage库挺好用的，可以和OpenCV搭配一起使用，让图像处理更加灵活和方便。</p><p>本博客只对Skimage库做简单的介绍，细节使用的话推荐官网查看或百度寻找。<a href="https://scikit-image.org/">Skimage官方网站</a></p><p>本博客会不断更新的，尽量。</p><h2 id="实现连通区域染色"><a href="#实现连通区域染色" class="headerlink" title="实现连通区域染色"></a>实现连通区域染色</h2><p><strong>源代码程序：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import cv2from skimage import measure, colorpath &#x3D; &quot;C:\\Users\\17513\\Desktop\\test.jpg&quot;img &#x3D; cv2.imread(path)img_copy &#x3D; img.copy()img_gray &#x3D; cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)img_gauss &#x3D; cv2.GaussianBlur(img_gray, (5, 5), 1)img_temp &#x3D; cv2.threshold(img_gray, 127, 255, cv2.THRESH_BINARY)[1]labels &#x3D; measure.label(img_temp)dst &#x3D; color.label2rgb(labels, bg_label&#x3D;0)    # bg_label&#x3D;0要有，不然会有警告cv2.imshow(&quot;666&quot;, dst)cv2.waitKey(0)cv2.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/13/1.png" alt="效果图"></p><p><strong>代码函数分析：</strong></p><p>这段代码很少，其中需要讲解的只有 <code>measure.label</code>和<code>color.label2rgb</code>，其他均为OpenCV的基础代码。</p><ul><li><p>skimage.measure.label</p><p>功能描述：实现连通区域标记。<br>函数调用形式：skimage.measure.label(input, neighbors = None, background = None, return_num = False, connectivity =None)<br>参数描述：<br>input : Image to label 需要被标记的图片，输入的数据结构不作要求<br>neighbors : 这个参数将被移除，被下面的connectivity替代。可以忽略不看<br>background : 选择背景像素，指定像素作为背景，全部相同像素标记为0<br>return_num : 是一个bool值，如果为True的话返回值是一个元组（labels ，num ）；如果为False的话就只返回labels<br>connectivity : Maximum number of orthogonal hops to consider a pixel/voxel as a neighbor. Accepted values are ranging from 1 to input.ndim. If None, a full connectivity of input.ndim is used. [int, optional]。如果input是一个二维的图片，那么connectivity的值范围选择{1,2}，如果是None则默认是取最高的值，对于二维来说，当connectivity=1时代表4连通，当connectivity=2时代表8连通.<br>Returns:<br>labels : 和input形状一样，但是数值是标记号，所以这是一个已经标记的图片<br>num : 标记的种类数，如果输出0则只有背景，如果输出2则有两个种类或者说是连通域</p></li><li><p>skimage.color.label2rgb</p><p>Parameters<br>labelarray, shape (M, N)<br>Integer array of labels with the same shape as image.</p><p>imagearray, shape (M, N, 3), optional<br>Image used as underlay for labels. If the input is an RGB image, it’s converted to grayscale before coloring.</p><p>colorslist, optional<br>List of colors. If the number of labels exceeds the number of colors, then the colors are cycled.</p><p>alphafloat [0, 1], optional<br>Opacity of colorized labels. Ignored if image is None.</p><p>bg_labelint, optional<br>Label that’s treated as the background. If bg_label is specified, bg_color is None, and kind is overlay, background is not painted by any colors.</p><p>bg_colorstr or array, optional<br>Background color. Must be a name in color_dict or RGB float values between [0, 1].</p><p>image_alphafloat [0, 1], optional<br>Opacity of the image.</p><p>kindstring, one of {‘overlay’, ‘avg’}<br>The kind of color image desired. ‘overlay’ cycles over defined colors and overlays the colored labels over the original image. ‘avg’ replaces each labeled segment with its average color, for a stained-class or pastel painting appearance.</p><p>saturationfloat [0, 1], optional<br>Parameter to control the saturation applied to the original image between fully saturated (original RGB, saturation=1) and fully unsaturated (grayscale, saturation=0). Only applies when kind=’overlay’.</p><p>Returns<br>resultarray of float, shape (M, N, 3)<br>The result of blending a cycling colormap (colors) for each distinct value in label with the image, at a certain alpha value.</p><p>这段关于<code>color.label2rgb</code>是直接复制官网上的。大部分参数都保持默认即可，与<code>measure.label</code>结合使用可以达到对不同连通区域染色的效果。</p></li></ul><h2 id="Skimage-measure-regionprops介绍"><a href="#Skimage-measure-regionprops介绍" class="headerlink" title="Skimage.measure.regionprops介绍"></a>Skimage.measure.regionprops介绍</h2><ul><li><p>Skimage.measure.regionprops</p><p>功能描述：测量标记图像区域的属性。<br>函数调用形式：skimage.measure.regionprops(label_image, intensity_image=None, cache=True, coordinates=None)<br>参数描述：<br>label_image：（N,M）ndarray，标记输入图像；<br>intensity_image : (N, M) ndarray，可选参数，具有与标记图像相同大小的强度（即输入）图像，默认值为“None”；<br>cache：bool，可选参数，确定是否缓存计算的属性。对于缓存属性，计算速度要快得多，而内存消耗则会增加；<br>coordinates：’rc’或’xy‘，可选参数，协调2D图像的约定。（3D图像仅支持’rc‘坐标）<br>Return:<br>region：是一种列表的形式，每个连通域的标记区域。</p></li></ul><p>这个函数返回值是一个列表，内容是每个没标记的连通区域。</p><table><thead><tr><th>属性名称</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>area</td><td>int</td><td>区域内像素点总数</td></tr><tr><td>bbox</td><td>tuple</td><td>边界外接框(min_row, min_col, max_row, max_col)</td></tr><tr><td>centroid</td><td>array</td><td>质心坐标</td></tr><tr><td>convex_area</td><td>int</td><td>凸包内像素点总数</td></tr><tr><td>convex_image</td><td>ndarray</td><td>和边界外接框同大小的凸包</td></tr><tr><td>coords</td><td>ndarray</td><td>区域内像素点坐标</td></tr><tr><td>Eccentricity</td><td>float</td><td>离心率</td></tr><tr><td>equivalent_diameter</td><td>float</td><td>和区域面积相同的圆的直径</td></tr><tr><td>euler_number</td><td>int</td><td>区域欧拉数</td></tr><tr><td>extent</td><td>float</td><td>区域面积和边界外接框面积的比率</td></tr><tr><td>filled_area</td><td>int</td><td>区域和外接框之间填充的像素点总数</td></tr><tr><td>perimeter</td><td>float</td><td>区域周长</td></tr><tr><td>label</td><td>int</td><td>区域标记</td></tr></tbody></table><p>源程序代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import cv2from skimage import measurepath &#x3D; &quot;C:\\Users\\17513\\Desktop\\test.jpg&quot;img &#x3D; cv2.imread(path)img_copy &#x3D; img.copy()img_gray &#x3D; cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)img_gauss &#x3D; cv2.GaussianBlur(img_gray, (5, 5), 1)img_temp &#x3D; cv2.threshold(img_gray, 127, 255, cv2.THRESH_BINARY)[1]labels &#x3D; measure.label(img_temp)a &#x3D; measure.regionprops(labels)for (j, i) in enumerate(a):    (min_row, min_col, max_row, max_col) &#x3D; i.bbox    cv2.rectangle(img_copy, (min_col, min_row), (max_col, max_row), (0, 0, 255))cv2.imshow(&quot;666&quot;, img_copy)cv2.waitKey(0)cv2.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/13/2.png" alt="效果图"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV实现连通区域填充</title>
      <link href="posts/12.html"/>
      <url>posts/12.html</url>
      
        <content type="html"><![CDATA[<h1 id="OpenCV实现连通区域填充"><a href="#OpenCV实现连通区域填充" class="headerlink" title="OpenCV实现连通区域填充"></a>OpenCV实现连通区域填充</h1><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本博客主要解决的问题来源于数据结构老师的一次作业，作业内容如下图所示。</p><p><img src="/posts/12/1.png" alt="问题照片"></p><p>要处理的图像如下：</p><p><img src="/posts/12/2.jpg" alt="原图像"></p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><ul><li>VS2019</li><li>C++</li><li>OpenCV-4.1.0</li></ul><h2 id="第一部分：使用轮廓查找和漫水填充的方法实现区域染色"><a href="#第一部分：使用轮廓查找和漫水填充的方法实现区域染色" class="headerlink" title="第一部分：使用轮廓查找和漫水填充的方法实现区域染色"></a>第一部分：使用轮廓查找和漫水填充的方法实现区域染色</h2><p><strong>流程图：</strong></p><p><img src="/posts/12/3.png" alt="漫水填充"></p><p><strong>源程序代码：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void deal_test_1()&#123;    Mat test_1_gray, test_1_threshold, test_1_gauss;    Mat test_1_sobelx, test_1_sobely, test_1_sobelxy;    Mat test_1_origin &#x3D; imread(&quot;C:\\Users\\17513\\Desktop\\数据结构报告\\栈和队列\\test.jpg&quot;);    Mat test_1_copy &#x3D; test_1_origin.clone();    &#x2F;*转换为灰度图*&#x2F;    cvtColor(test_1_origin, test_1_gray, COLOR_BGR2GRAY);    &#x2F;*高斯滤波*&#x2F;    GaussianBlur(test_1_gray, test_1_gauss, Size(5, 5), 0, 0);    &#x2F;*二值化*&#x2F;    threshold(test_1_gauss, test_1_threshold, 127, 255, THRESH_BINARY);    &#x2F;*Sobel算子*&#x2F;    Sobel(test_1_threshold, test_1_sobelx, CV_64F, 1, 0, 3);    convertScaleAbs(test_1_sobelx, test_1_sobelx);    Sobel(test_1_threshold, test_1_sobely, CV_64F, 0, 1, 3);    convertScaleAbs(test_1_sobely, test_1_sobely);    addWeighted(test_1_sobelx, 1, test_1_sobely, 1, 0, test_1_sobelxy);    &#x2F;*再次二值化*&#x2F;    threshold(test_1_sobelxy, test_1_threshold, 127, 255, THRESH_BINARY);    &#x2F;*寻找轮廓*&#x2F;    vector&lt;vector&lt;Point&gt;&gt; contours;    findContours(test_1_threshold, contours, RETR_EXTERNAL, CHAIN_APPROX_NONE);    &#x2F;*最小外接矩形*&#x2F;Point2f rect[4];vector&lt;Rect&gt; boundRect(contours.size());  &#x2F;&#x2F;定义外接矩形集合    vector&lt;RotatedRect&gt; box(contours.size()); &#x2F;&#x2F;定义最小外接矩形集合    srand((int)time(0));    for (int i &#x3D; 0; i &lt; contours.size(); i++)    &#123;        box[i] &#x3D; minAreaRect(Mat(contours[i]));  &#x2F;&#x2F;计算每个轮廓最小外接矩形        box[i].points(rect);  &#x2F;&#x2F;把最小外接矩形四个端点复制给rect数组        floodFill(test_1_copy, Point(box[i].center.x, box[i].center.y), Scalar(rand() % 255, rand() &amp; 255, rand() % 255), &amp;boundRect[i], Scalar(20, 20, 20), Scalar(20, 20, 20));    &#125;    cv_show(&quot;666&quot;, test_1_copy);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代码分析：</strong></p><ol><li>   这部分代码比较基础。首先对图片进行基本的处理，再使用轮廓查找的方式找的图形的轮廓。再通过轮廓算出其最小外接矩形，这样就可以大致确定每个图形所在的区域，也就是ROI区域。</li><li>   在获取ROI区域后的难点是如何对图像进行染色，而且还要保证每个图形染的颜色是不同的。<br>对于染色方法我这里使用的是漫水填充的算法。这个算法参考<br><a href="https://blog.csdn.net/poem_qianmo/article/details/28261997">【OpenCV入门教程之十五】水漫金山：OpenCV漫水填充算法（Floodfill）</a><br>具体函数的使用方法也比较简单。函数需要提供seedPoint即漫水填充算法的起点，在程序中这个点我给的是每个图像最小外接矩形的中心点。此外还需要提供填充的颜色，为了保证颜色的不同，采用随机数的方式选择不用的BGR颜色，随机数的范围是0到255.</li></ol><p><strong>效果图：</strong></p><p><img src="/posts/12/4.png" alt="漫水填充效果图">\</p><p>程序最终效果还可以接受，但有些图形的外边明显没有进行染色，这可能是因为图像经过基本处理后发生改变与原图像不同导致。</p><h2 id="第二部分：使用队列实现种子填充法"><a href="#第二部分：使用队列实现种子填充法" class="headerlink" title="第二部分：使用队列实现种子填充法"></a>第二部分：使用队列实现种子填充法</h2><p><strong>流程图：</strong></p><p><img src="/posts/12/5.png" alt="种子填充法"></p><p><strong>源程序代码：</strong></p><p>基本的图像处理：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Mat labelImg;Mat colorLabelImg;Mat test_1_gray, test_1_threshold, test_1_gauss;Mat test_1_origin &#x3D; imread(&quot;C:\\Users\\17513\\Desktop\\数据结构报告\\栈和队列\\test.jpg&quot;);Mat test_1_copy;cvtColor(test_1_origin, test_1_gray, COLOR_BGR2GRAY);GaussianBlur(test_1_gray, test_1_gauss, Size(5, 5), 0, 0);threshold(test_1_gauss, test_1_threshold, 127, 255, THRESH_BINARY);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代码分析：</strong><br>一些基本的图像处理。灰度图、高斯滤波和二值化。</p><p>种子填充法相关代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void SeedFillOld(const Mat&amp; binImg, Mat&amp; lableImg)&#123;    if (binImg.empty() || binImg.type() !&#x3D; CV_8UC1)    &#123;        return;    &#125;    lableImg.release();    binImg.convertTo(lableImg, CV_32SC1);    int label &#x3D; 1;    int rows &#x3D; binImg.rows;    int cols &#x3D; binImg.cols;    for (int i &#x3D; 0; i &lt; rows; i++)    &#123;        for (int j &#x3D; 0; j &lt; cols; j++)        &#123;            if (lableImg.at&lt;int&gt;(i, j) &#x3D;&#x3D; 255)            &#123;                queue&lt;pair&lt;int, int&gt;&gt; neighborPixels;                neighborPixels.push(pair&lt;int, int&gt;(i, j));     &#x2F;&#x2F; 像素位置: &lt;i,j&gt;                ++label;                while (!neighborPixels.empty())                &#123;                    pair&lt;int, int&gt; curPixel &#x3D; neighborPixels.front();                    int curX &#x3D; curPixel.first;                    int curY &#x3D; curPixel.second;                    if (lableImg.at&lt;int&gt;(curX, curY) !&#x3D; label)                    &#123;                        lableImg.at&lt;int&gt;(curX, curY) &#x3D; label;                        neighborPixels.pop();                        if (lableImg.at&lt;int&gt;(curX, curY - 1) &#x3D;&#x3D; 255)                        &#123;                            neighborPixels.push(std::pair&lt;int, int&gt;(curX, curY - 1));                        &#125;                        if (lableImg.at&lt;int&gt;(curX, curY + 1) &#x3D;&#x3D; 255)                        &#123;                            neighborPixels.push(std::pair&lt;int, int&gt;(curX, curY + 1));                        &#125;                        if (lableImg.at&lt;int&gt;(curX - 1, curY) &#x3D;&#x3D; 255)                        &#123;                            neighborPixels.push(std::pair&lt;int, int&gt;(curX - 1, curY));                        &#125;                        if (lableImg.at&lt;int&gt;(curX + 1, curY) &#x3D;&#x3D; 255)                        &#123;                            neighborPixels.push(std::pair&lt;int, int&gt;(curX + 1, curY));                        &#125;                    &#125;                    else                    &#123;                        neighborPixels.pop();                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代码分析：</strong></p><ol><li>   种子填充法<br>参考博客：<br><a href="https://blog.csdn.net/icvpr/article/details/10259577">OpenCV_连通区域分析（Connected Component Analysis-Labeling）</a><br><a href="https://blog.csdn.net/qq_37059483/article/details/78018539">OpenCV-二值图像连通域分析</a><br>在上面这两个博客中的种子填充法都是使用堆栈来实现的，因此在本程序中需要考虑换成队列。</li><li>   算法的简单分析：<br>（1）    首先需要获取原图像的列数和行数方便后面对每个像素点的访问。<br>（2）    通过遍历访问像素点，如果像素点(i, j)的值等于255（白色点）则将其坐标点存入neighborPixels队列中，并且标签label加1。<br>（3）    如果neighborPixels队列非空，则取出neighborPixels队列的队头。判断队头代表的像素点是否与当前label相等，如果相等则直接删除并重复步骤（3），否则进行步骤（4）。如果neighborPixels队列为空则执行步骤（2）。<br>（4）    将队头点赋值为label并从队列中删除。对队头点进行4领域判断。上下左右四个点，哪个点的像素值为255哪个值就入队。重复步骤（3）。<br>（5）    当所有像素点被遍历完之后种子填充法结束。</li><li>   种子填充法比较容易理解，我认为难点在于将原本代码中的堆栈转换为队列。经过仔细分析，发现如果仅仅是把堆栈换成队列会导致代码重复，及会出现一个像素点被多次访问的情况。为了解决这个问题，我在程序中多加了一个判断（第135行）。因为一个像素点被访问后会被“贴上”值为label的“标签”，所以对像素点的“标签”进行判断就可以知道这个点有没有被访问过。如果访问过则直接删除，否则正常执行程序即可。</li><li>   本程序中使用的是4领域，还可以换成8领域，不过我没试过，不知道效果怎么样。</li></ol><h2 id="第三部分：对图像染色"><a href="#第三部分：对图像染色" class="headerlink" title="第三部分：对图像染色"></a>第三部分：对图像染色</h2><p><strong>源程序代码：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Scalar GetRandomColor()&#123;    uchar r &#x3D; 255 * (rand() &#x2F; (1.0 + RAND_MAX));    uchar g &#x3D; 255 * (rand() &#x2F; (1.0 + RAND_MAX));    uchar b &#x3D; 255 * (rand() &#x2F; (1.0 + RAND_MAX));    return Scalar(b, g, r);&#125;void LabelColor(const Mat&amp; labelImg, Mat&amp; colorLabelImg)&#123;    int num &#x3D; 0;    if (labelImg.empty() ||        labelImg.type() !&#x3D; CV_32SC1)    &#123;        return;    &#125;    map&lt;int, Scalar&gt; colors;    int rows &#x3D; labelImg.rows;    int cols &#x3D; labelImg.cols;    colorLabelImg.release();    colorLabelImg.create(rows, cols, CV_8UC3);    colorLabelImg &#x3D; Scalar::all(0);    for (int i &#x3D; 0; i &lt; rows; i++)    &#123;        const int* data_src &#x3D; (int*)labelImg.ptr&lt;int&gt;(i);        uchar* data_dst &#x3D; colorLabelImg.ptr&lt;uchar&gt;(i);        for (int j &#x3D; 0; j &lt; cols; j++)        &#123;            int pixelValue &#x3D; data_src[j];            if (pixelValue &gt; 1)            &#123;                if (colors.count(pixelValue) &lt;&#x3D; 0)                &#123;                    colors[pixelValue] &#x3D; GetRandomColor();                    num++;                &#125;                Scalar color &#x3D; colors[pixelValue];                *data_dst++ &#x3D; color[0];                *data_dst++ &#x3D; color[1];                *data_dst++ &#x3D; color[2];            &#125;            else            &#123;                data_dst++;                data_dst++;                data_dst++;            &#125;        &#125;    &#125;    printf(&quot;color num : %d \n&quot;, num);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代码分析：</strong></p><ol><li>   颜色BGR也是取的随机数，可以保证每个区域颜色不同。</li><li>   通过遍历进行染色，判断方式就是对每个像素点的值也就是标签进行染色。同一个标签的点染同一个颜色。</li></ol><p><strong>效果图：</strong></p><p><img src="/posts/12/6.png" alt="种子填充法"></p><p>从图中可以看出，效果比轮廓法要好，颜色填充比较饱满。</p><h2 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;opencv2&#x2F;opencv.hpp&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;list&gt;using namespace cv;using namespace std;void cv_show(string name, Mat img)&#123;&#x2F;*用于显示图像*&#x2F;imshow(name, img);waitKey(0);&#125;void deal_test_1()&#123;Mat test_1_gray, test_1_threshold, test_1_gauss;Mat test_1_sobelx, test_1_sobely, test_1_sobelxy;Mat test_1_origin &#x3D; imread(&quot;C:\\Users\\17513\\Desktop\\数据结构报告\\栈和队列\\test.jpg&quot;);Mat test_1_copy &#x3D; test_1_origin.clone();&#x2F;*转换为灰度图*&#x2F;cvtColor(test_1_origin, test_1_gray, COLOR_BGR2GRAY);&#x2F;*高斯滤波*&#x2F;GaussianBlur(test_1_gray, test_1_gauss, Size(5, 5), 0, 0);&#x2F;*二值化*&#x2F;threshold(test_1_gauss, test_1_threshold, 127, 255, THRESH_BINARY);&#x2F;*Sobel算子*&#x2F;Sobel(test_1_threshold, test_1_sobelx, CV_64F, 1, 0, 3);convertScaleAbs(test_1_sobelx, test_1_sobelx);Sobel(test_1_threshold, test_1_sobely, CV_64F, 0, 1, 3);convertScaleAbs(test_1_sobely, test_1_sobely);addWeighted(test_1_sobelx, 1, test_1_sobely, 1, 0, test_1_sobelxy);&#x2F;*再次二值化*&#x2F;threshold(test_1_sobelxy, test_1_threshold, 127, 255, THRESH_BINARY);&#x2F;*寻找轮廓*&#x2F;vector&lt;vector&lt;Point&gt;&gt; contours;findContours(test_1_threshold, contours, RETR_EXTERNAL, CHAIN_APPROX_NONE);&#x2F;*绘制轮廓*&#x2F;&#x2F;&#x2F;drawContours(test_1_copy, contours, -1, Scalar(0, 255, 255), 2);&#x2F;*最小外接矩形*&#x2F;Point2f rect[4];vector&lt;Rect&gt; boundRect(contours.size());  &#x2F;&#x2F;定义外接矩形集合vector&lt;RotatedRect&gt; box(contours.size()); &#x2F;&#x2F;定义最小外接矩形集合srand((int)time(0));for (int i &#x3D; 0; i &lt; contours.size(); i++)&#123;box[i] &#x3D; minAreaRect(Mat(contours[i]));  &#x2F;&#x2F;计算每个轮廓最小外接矩形&#x2F;&#x2F;boundRect[i] &#x3D; boundingRect(Mat(contours[i]));&#x2F;&#x2F;circle(test_1_copy, Point(box[i].center.x, box[i].center.y), 2, Scalar(0, 255, 0), -1, 8);&#x2F;&#x2F;绘制最小外接矩形的中心点&#x2F;*rectangle(test_1_copy, Point(boundRect[i].x, boundRect[i].y), Point(boundRect[i].x +boundRect[i].width, boundRect[i].y + boundRect[i].height), Scalar(0, 255, 0), 1, 8);*&#x2F;box[i].points(rect);  &#x2F;&#x2F;把最小外接矩形四个端点复制给rect数组floodFill(test_1_copy, Point(box[i].center.x, box[i].center.y), Scalar(rand() % 255, rand() &amp; 255, rand() % 255), &amp;boundRect[i], Scalar(20, 20, 20), Scalar(20, 20, 20));&#125;cv_show(&quot;666&quot;, test_1_copy);&#125;void deal_test_2()&#123;Mat img_origin &#x3D; imread(&quot;C:\\Users\\17513\\Desktop\\数据结构报告\\栈和队列\\test2.jpg&quot;);Mat img_copy &#x3D; img_origin.clone();Mat img_gray, img_gauss, img_threshold;Mat img_sobelx, img_sobely, img_sobelxy;Mat dstImage;Mat element &#x3D; getStructuringElement(MORPH_RECT, Size(3, 3));cvtColor(img_copy, img_gray, COLOR_BGR2GRAY);GaussianBlur(img_gray, img_gauss, Size(5, 5), 0, 0);threshold(img_gray, img_threshold, 127, 255, THRESH_BINARY);morphologyEx(img_threshold, dstImage, 0, element);&#x2F;&#x2F;Sobel(dstImage, img_sobelx, CV_64F, 1, 0, 3);&#x2F;&#x2F;convertScaleAbs(img_sobelx, img_sobelx);&#x2F;&#x2F;Sobel(img_threshold, img_sobely, CV_64F, 0, 1, 3);&#x2F;&#x2F;convertScaleAbs(img_sobely, img_sobely);&#x2F;&#x2F;addWeighted(img_sobelx, 1, img_sobely, 1, 0, img_sobelxy);threshold(dstImage, img_threshold, 127, 255, THRESH_BINARY);vector&lt;vector&lt;Point&gt;&gt; contours;vector&lt;vector&lt;Point&gt;&gt; cnts;vector&lt;vector&lt;Point&gt;&gt; cnts_max;findContours(img_threshold, contours, RETR_EXTERNAL, CHAIN_APPROX_NONE);for (int i &#x3D; 0; i &lt; contours.size(); i++)&#123;double size &#x3D; contourArea(contours[i]);if (size &gt;&#x3D; 10 &amp;&amp; size &lt; 1000)cnts.push_back(contours[i]);if (size &gt;&#x3D; 1000)cnts_max.push_back(contours[i]);&#x2F;&#x2F; cout &lt;&lt; i &lt;&lt; &quot;&#x3D;&quot; &lt;&lt; size &lt;&lt; endl;&#125;Mat img_copy2 &#x3D; img_copy.clone();int sum;sum &#x3D; cnts.size() + cnts_max.size() * 2;drawContours(img_copy2, cnts, -1, Scalar(0, 0, 255), 1);&#x2F;&#x2F;drawContours(img_copy, cnts, -1, Scalar(0, 0, 255), 2);&#x2F;&#x2F;cout &lt;&lt; &quot;contours &#x3D; &quot; &lt;&lt; contours.size() &lt;&lt; endl;&#x2F;&#x2F;cout &lt;&lt; &quot;cnts &#x3D; &quot; &lt;&lt; cnts.size() &lt;&lt; endl;&#x2F;&#x2F;cout &lt;&lt; &quot;cnts_max &#x3D; &quot; &lt;&lt; cnts_max.size() &lt;&lt; endl;cout &lt;&lt; &quot;sum &#x3D; &quot; &lt;&lt; sum &lt;&lt; endl;&#x2F;&#x2F;cout &lt;&lt; &quot;一共有&quot; &lt;&lt; cnts.size() &lt;&lt; &quot;个米粒&quot; &lt;&lt; endl;imshow(&quot;米粒轮廓&quot;, img_copy2);waitKey(0);&#125;void SeedFillOld(const Mat&amp; binImg, Mat&amp; lableImg)&#123;if (binImg.empty() || binImg.type() !&#x3D; CV_8UC1)&#123;return;&#125;lableImg.release();binImg.convertTo(lableImg, CV_32SC1);int label &#x3D; 1;int rows &#x3D; binImg.rows;int cols &#x3D; binImg.cols;for (int i &#x3D; 0; i &lt; rows; i++)&#123;for (int j &#x3D; 0; j &lt; cols; j++)&#123;if (lableImg.at&lt;int&gt;(i, j) &#x3D;&#x3D; 255)&#123;queue&lt;pair&lt;int, int&gt;&gt; neighborPixels;neighborPixels.push(pair&lt;int, int&gt;(i, j));     &#x2F;&#x2F; 像素位置: &lt;i,j&gt;++label;while (!neighborPixels.empty())&#123;pair&lt;int, int&gt; curPixel &#x3D; neighborPixels.front();int curX &#x3D; curPixel.first;int curY &#x3D; curPixel.second;if (lableImg.at&lt;int&gt;(curX, curY) !&#x3D; label)&#123;lableImg.at&lt;int&gt;(curX, curY) &#x3D; label;neighborPixels.pop();if (lableImg.at&lt;int&gt;(curX, curY - 1) &#x3D;&#x3D; 255)&#123;neighborPixels.push(std::pair&lt;int, int&gt;(curX, curY - 1));&#125;if (lableImg.at&lt;int&gt;(curX, curY + 1) &#x3D;&#x3D; 255)&#123;neighborPixels.push(std::pair&lt;int, int&gt;(curX, curY + 1));&#125;if (lableImg.at&lt;int&gt;(curX - 1, curY) &#x3D;&#x3D; 255)&#123;neighborPixels.push(std::pair&lt;int, int&gt;(curX - 1, curY));&#125;if (lableImg.at&lt;int&gt;(curX + 1, curY) &#x3D;&#x3D; 255)&#123;neighborPixels.push(std::pair&lt;int, int&gt;(curX + 1, curY));&#125;&#125;else&#123;neighborPixels.pop();&#125;&#125;&#125;&#125;&#125;&#125;Scalar GetRandomColor()&#123;uchar r &#x3D; 255 * (rand() &#x2F; (1.0 + RAND_MAX));uchar g &#x3D; 255 * (rand() &#x2F; (1.0 + RAND_MAX));uchar b &#x3D; 255 * (rand() &#x2F; (1.0 + RAND_MAX));return Scalar(b, g, r);&#125;void LabelColor(const Mat&amp; labelImg, Mat&amp; colorLabelImg)&#123;int num &#x3D; 0;if (labelImg.empty() ||labelImg.type() !&#x3D; CV_32SC1)&#123;return;&#125;map&lt;int, Scalar&gt; colors;int rows &#x3D; labelImg.rows;int cols &#x3D; labelImg.cols;colorLabelImg.release();colorLabelImg.create(rows, cols, CV_8UC3);colorLabelImg &#x3D; Scalar::all(0);for (int i &#x3D; 0; i &lt; rows; i++)&#123;const int* data_src &#x3D; (int*)labelImg.ptr&lt;int&gt;(i);uchar* data_dst &#x3D; colorLabelImg.ptr&lt;uchar&gt;(i);for (int j &#x3D; 0; j &lt; cols; j++)&#123;int pixelValue &#x3D; data_src[j];if (pixelValue &gt; 1)&#123;if (colors.count(pixelValue) &lt;&#x3D; 0)&#123;colors[pixelValue] &#x3D; GetRandomColor();num++;&#125;Scalar color &#x3D; colors[pixelValue];*data_dst++ &#x3D; color[0];*data_dst++ &#x3D; color[1];*data_dst++ &#x3D; color[2];&#125;else&#123;data_dst++;data_dst++;data_dst++;&#125;&#125;&#125;printf(&quot;color num : %d \n&quot;, num);&#125;void deal_test_3()&#123;Mat labelImg;Mat colorLabelImg;Mat test_1_gray, test_1_threshold, test_1_gauss;Mat test_1_origin &#x3D; imread(&quot;C:\\Users\\17513\\Desktop\\数据结构报告\\栈和队列\\test.jpg&quot;);Mat test_1_copy;cvtColor(test_1_origin, test_1_gray, COLOR_BGR2GRAY);GaussianBlur(test_1_gray, test_1_gauss, Size(5, 5), 0, 0);threshold(test_1_gauss, test_1_threshold, 127, 255, THRESH_BINARY);SeedFillOld(test_1_threshold, labelImg);LabelColor(labelImg, colorLabelImg);cv_show(&quot;666&quot;, colorLabelImg);&#125;int main()&#123;int mode;cout &lt;&lt; &quot;请输入要执行的程序编号：&quot;;cin &gt;&gt; mode;if (mode &#x3D;&#x3D; 1)deal_test_1();else if (mode &#x3D;&#x3D; 2)deal_test_2();else if (mode &#x3D;&#x3D; 3)deal_test_3();elsecout &lt;&lt; &quot;请输入正确的编号！&quot; &lt;&lt; endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV模板匹配识别图片中的数字</title>
      <link href="posts/11.html"/>
      <url>posts/11.html</url>
      
        <content type="html"><![CDATA[<h1 id="OpenCV模板匹配识别图片中的数字"><a href="#OpenCV模板匹配识别图片中的数字" class="headerlink" title="OpenCV模板匹配识别图片中的数字"></a>OpenCV模板匹配识别图片中的数字</h1><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本博客主要实现利用OpenCV的模板匹配识别图像中的数字，然后把识别出来的数字输出到txt文件中，如果识别失败则输出“读取失败”。</p><p><strong>操作环境：</strong></p><ul><li>OpenCV - 4.1.0</li><li>Python 3.8.1</li></ul><h2 id="程序目标"><a href="#程序目标" class="headerlink" title="程序目标"></a>程序目标</h2><p>单个数字模板：（这些单个模板是我自己直接从图片上截取下来的）</p><p><img src="/posts/11/4.png" alt="单个数字模板"></p><p>要处理的图片：</p><p><img src="/posts/11/7.png" alt="要处理的图片"></p><p>终端输出：</p><p><img src="/posts/11/2.png" alt="终端输出"></p><p>文本输出：</p><p><img src="/posts/11/3.png" alt="文本输出"></p><h2 id="思路讲解"><a href="#思路讲解" class="headerlink" title="思路讲解"></a>思路讲解</h2><p><img src="/posts/11/1.jpg" alt="思路讲解"></p><h2 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h2><p>首先定义两个会用到的函数</p><p>第一个是显示图片的函数，这样的话在显示图片的时候就比较方便了</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def cv_show(name, img):    cv2.imshow(name, img)    cv2.waitKey(0)    cv2.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第二个是图片缩放的函数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def resize(image, width&#x3D;None, height&#x3D;None, inter&#x3D;cv2.INTER_AREA):    dim &#x3D; None    (h, w) &#x3D; image.shape[:2]    if width is None and height is None:        return image    if width is None:        r &#x3D; height &#x2F; float(h)        dim &#x3D; (int(w * r), height)    else:        r &#x3D; width &#x2F; float(w)        dim &#x3D; (width, int(h * r))    resized &#x3D; cv2.resize(image, dim, interpolation&#x3D;inter)    return resized<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先把这个代码贴出来，方便后面单个函数代码的理解。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    # 存放数字模板列表    digits &#x3D; []    # 当前运行目录    now_dir &#x3D; os.getcwd()    print(&quot;当前运行目录：&quot; + now_dir)    numbers_address &#x3D; now_dir + &quot;\\numbers&quot;    load_digits()    times &#x3D; input(&quot;请输入程序运行次数：&quot;)    for i in range(1, int(times) + 1):        demo(i)    print(&quot;输出成功，请检查本地temp.txt文件&quot;)    while True:        if input(&quot;输入小写‘q’并回车退出&quot;) &#x3D;&#x3D; &#39;q&#39;:            break<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来是第一个主要函数，功能是加载数字模板并进行处理。</p><p>这个函数使用到了<code>os</code>模块，所以需要在开头<code>import os</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def load_digits():    # 加载数字模板    path &#x3D; numbers_address    # 这个地方就是获取当前运行目录 获取函数在主函数里面    filename &#x3D; os.listdir(path)    # 获取文件夹文件    for file in filename:        img &#x3D; cv2.imread(numbers_address + &quot;\\&quot; + file)    # 读取图片        img_gray &#x3D; cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)    # 灰度处理        # 自动阈值二值化 把图片处理成黑底白字        img_temp &#x3D; cv2.threshold(img_gray, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]        # 寻找数字轮廓        cnt &#x3D; cv2.findContours(img_temp, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)[0]        # 获取数字矩形轮廓        x, y, w, h &#x3D; cv2.boundingRect(cnt[0])        # 将单个数字区域进行缩放并存到列表中以备后面使用        digit_roi &#x3D; cv2.resize(img_temp[y:y+h, x:x+w], (57, 88))        digits.append(digit_roi)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后一个函数是程序的重点，实现功能就是识别出数字并输出。</p><p>不过这里把这个大函数分开两部分来讲解。</p><p>第一部分是对图片进行处理，最终把图片中的数字区域圈出来。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 这两个都是核，参数可以改变rectKernel &#x3D; cv2.getStructuringElement(cv2.MORPH_RECT, (25, 25))sqKernel &#x3D; cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))# 这个就是读取图片的，可以暂时不理解target_path &#x3D; now_dir + &quot;\\&quot; + &quot;demo_&quot; + str(index) + &quot;.png&quot;img_origin &#x3D; cv2.imread(target_path)# 对图片进行缩放处理img_origin &#x3D; resize(img_origin, width&#x3D;300)# 灰度图img_gray &#x3D; cv2.cvtColor(img_origin, cv2.COLOR_BGR2GRAY)# 高斯滤波  参数可以改变，选择效果最好的就可以gaussian &#x3D; cv2.GaussianBlur(img_gray, (5, 5), 1)、# 自动二值化处理，黑底白字img_temp &#x3D; cv2.threshold(    gaussian, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]# 顶帽操作img_top &#x3D; cv2.morphologyEx(img_temp, cv2.MORPH_TOPHAT, rectKernel)# sobel操作img_sobel_x &#x3D; cv2.Sobel(img_top, cv2.CV_64F, 1, 0, ksize&#x3D;7)img_sobel_x &#x3D; cv2.convertScaleAbs(img_sobel_x)img_sobel_y &#x3D; cv2.Sobel(img_top, cv2.CV_64F, 0, 1, ksize&#x3D;7)img_sobel_y &#x3D; cv2.convertScaleAbs(img_sobel_y)img_sobel_xy &#x3D; cv2.addWeighted(img_sobel_x, 1, img_sobel_y, 1, 0)# 闭操作img_closed &#x3D; cv2.morphologyEx(img_sobel_xy, cv2.MORPH_CLOSE, rectKernel)# 自动二值化thresh &#x3D; cv2.threshold(    img_closed, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]# 闭操作img_closed &#x3D; cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, sqKernel)# 寻找数字轮廓cnts &#x3D; cv2.findContours(    img_closed.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)[0]# 轮廓排序(cnts, boundingBoxes) &#x3D; contours.sort_contours(cnts, &quot;top-to-bottom&quot;)# 存放正确数字序列（包含逗号）的轮廓，即过滤掉不需要的轮廓right_loc &#x3D; []# 下面这个循环是对轮廓进行筛选，只有长宽比例大于2的才可以被添加到列表中# 这个比例可以根据具体情况来改变。除此之外，还可以通过轮廓周长和轮廓面积等对轮廓进行筛选for c in cnts:    x, y, w, h &#x3D; cv2.boundingRect(c)    ar &#x3D; w&#x2F;float(h)    if ar &gt; 2:        right_loc.append((x, y, w, h))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>部分步骤的效果图：</p><p><img src="/posts/11/5.png" alt="效果图"></p><p>可以看到在进行完最后一次闭操作后，一串数字全部变成白色区域，这样再进行轮廓检测就可以框出每一行数字的大致范围，这样就可以缩小数字处理的范围，可以在这些具体的区域内部对单个数字进行处理。</p><p>轮廓效果：</p><p><img src="/posts/11/6.png" alt="轮廓效果"></p><p>在这样进行以上步骤之后，就可以确定一行数字的范围了，下面就进行轮廓筛选把符合条件的轮廓存入列表。</p><p><strong>注意：在代码中使用了<code>(cnts, boundingBoxes) = contours.sort_contours(cnts, &quot;top-to-bottom&quot;)</code></strong></p><p><strong>这个函数的使用需要导入<code>imutils</code>，这个模块具体使用方法可以浏览我的另一篇博客<a href="https://lightningleader.github.io/posts/6.html">OpenCV学习笔记</a></strong></p><p>函数的最后一部分就是对每个数字轮廓进行分割，取出单个数字的区域然后进行模板匹配。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">for (gx, gy, gw, gh) in right_loc:        # 用于存放识别到的数字        digit_out &#x3D; []        # 下面两个判断主要是防止出现越界的情况发生，如果发生的话图片读取会出错        if (gy-10 &lt; 0):            now_gy &#x3D; gy        else:            now_gy &#x3D; gy-10        if (gx - 10 &lt; 0):            now_gx &#x3D; gx        else:            now_gx &#x3D; gx-10        # 选择图片兴趣区域        img_digit &#x3D; gaussian[now_gy:gy+gh+10, now_gx:gx+gw+10]        # 二值化处理        img_thresh &#x3D; cv2.threshold(            img_digit, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]        # 寻找所有轮廓 找出每个数字的轮廓（包含逗号） 正确的话应该有9个轮廓        digitCnts &#x3D; cv2.findContours(            img_thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)[0]        # 从左到右排列轮廓        # 这样排列的好处是，正常情况下可以确定逗号的位置方便后面删除逗号        (cnts, boundingBoxes) &#x3D; contours.sort_contours(digitCnts, &quot;left-to-right&quot;)        # cnts是元组，需要先转换成列表，因为后面会对元素进行删除处理        cnts &#x3D; list(cnts)        flag &#x3D; 0        # 判断轮廓数量是否有9个        if len(cnts) &#x3D;&#x3D; 9:            # 删除逗号位置            del cnts[1]            del cnts[2]            del cnts[3]            del cnts[4]            # 可以在转成元组            cnts &#x3D; tuple(cnts)            # 存放单个数字的矩形区域            num_roi &#x3D; []            for c in cnts:                x, y, w, h &#x3D; cv2.boundingRect(c)                num_roi.append((x, y, w, h))            # 对数字区域进行处理，把尺寸缩放到与数字模板相同            # 对其进行简单处理，方便与模板匹配，增加匹配率            for (rx, ry, rw, rh) in num_roi:                roi &#x3D; img_digit[ry:ry+rh, rx:rx+rw]                roi &#x3D; cv2.resize(roi, (57, 88))                # 高斯滤波                roi &#x3D; cv2.GaussianBlur(roi, (5, 5), 1)                # 二值化                roi &#x3D; cv2.threshold(                    roi, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]                # 用于存放匹配率                source &#x3D; []                # 遍历数字模板                for digitROI in digits:                    # 进行模板匹配                    res &#x3D; cv2.matchTemplate(                        roi, digitROI, cv2.TM_CCOEFF_NORMED)                    max_val &#x3D; cv2.minMaxLoc(res)[1]                    source.append(max_val)                # 这个需要仔细理解 这个就是把0-9数字中匹配度最高的数字存放到列表中                digit_out.append(str(source.index(max(source))))            # 打印最终输出值            print(digit_out)        else:            print(&quot;读取失败&quot;)            flag &#x3D; 1        # 将数字输出到txt文本中        t &#x3D; &#39;&#39;        with open(now_dir + &quot;\\temp.txt&quot;, &#39;a+&#39;) as q:            if flag &#x3D;&#x3D; 0:                for content in digit_out:                    t &#x3D; t + str(content) + &quot; &quot;                q.write(t.strip(&quot; &quot;))                q.write(&#39;\n&#39;)                t &#x3D; &#39;&#39;            else:                q.write(&quot;读取失败&quot;)                q.write(&#39;\n&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意理解：<code>digit_out.append(str(source.index(max(source))))</code></strong></p><p><strong>这个是很重要的，列表source存放模板匹配的每个数字的匹配率，求出其中最大值的索引值，因为数字模板是按照0-9排列的，索引source的匹配率也是按照0-9排列的，所以每个元素的索引值就与相匹配的数字相同。这样的话，取得最大值的索引值就相当于取到了匹配率最高的数字。</strong></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">from imutils import contoursimport cv2import osdef cv_show(name, img):    cv2.imshow(name, img)    cv2.waitKey(0)    cv2.destroyAllWindows()def resize(image, width&#x3D;None, height&#x3D;None, inter&#x3D;cv2.INTER_AREA):    dim &#x3D; None    (h, w) &#x3D; image.shape[:2]    if width is None and height is None:        return image    if width is None:        r &#x3D; height &#x2F; float(h)        dim &#x3D; (int(w * r), height)    else:        r &#x3D; width &#x2F; float(w)        dim &#x3D; (width, int(h * r))    resized &#x3D; cv2.resize(image, dim, interpolation&#x3D;inter)    return resizeddef load_digits():    # 加载数字模板    path &#x3D; numbers_address    filename &#x3D; os.listdir(path)    for file in filename:        # print(file)        img &#x3D; cv2.imread(            numbers_address + &quot;\\&quot; + file)        img_gray &#x3D; cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)        img_temp &#x3D; cv2.threshold(            img_gray, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]        cnt &#x3D; cv2.findContours(img_temp, cv2.RETR_EXTERNAL,                               cv2.CHAIN_APPROX_NONE)[0]        x, y, w, h &#x3D; cv2.boundingRect(cnt[0])        digit_roi &#x3D; cv2.resize(img_temp[y:y+h, x:x+w], (57, 88))        # 将数字模板存到列表中        digits.append(digit_roi)def demo(index):    rectKernel &#x3D; cv2.getStructuringElement(cv2.MORPH_RECT, (25, 25))    sqKernel &#x3D; cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))    target_path &#x3D; now_dir + &quot;\\&quot; + &quot;demo_&quot; + str(index) + &quot;.png&quot;    img_origin &#x3D; cv2.imread(target_path)    img_origin &#x3D; resize(img_origin, width&#x3D;300)    img_gray &#x3D; cv2.cvtColor(img_origin, cv2.COLOR_BGR2GRAY)    gaussian &#x3D; cv2.GaussianBlur(img_gray, (5, 5), 1)    img_temp &#x3D; cv2.threshold(        gaussian, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]    img_top &#x3D; cv2.morphologyEx(img_temp, cv2.MORPH_TOPHAT, rectKernel)    img_sobel_x &#x3D; cv2.Sobel(img_top, cv2.CV_64F, 1, 0, ksize&#x3D;7)    img_sobel_x &#x3D; cv2.convertScaleAbs(img_sobel_x)    img_sobel_y &#x3D; cv2.Sobel(img_top, cv2.CV_64F, 0, 1, ksize&#x3D;7)    img_sobel_y &#x3D; cv2.convertScaleAbs(img_sobel_y)    img_sobel_xy &#x3D; cv2.addWeighted(img_sobel_x, 1, img_sobel_y, 1, 0)    img_closed &#x3D; cv2.morphologyEx(img_sobel_xy, cv2.MORPH_CLOSE, rectKernel)    thresh &#x3D; cv2.threshold(        img_closed, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]    img_closed &#x3D; cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, sqKernel)    cnts &#x3D; cv2.findContours(        img_closed.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)[0]    (cnts, boundingBoxes) &#x3D; contours.sort_contours(cnts, &quot;top-to-bottom&quot;)    draw_img &#x3D; img_origin.copy()    draw_img &#x3D; cv2.drawContours(draw_img, cnts, -1, (0, 0, 255), 1)    cv_show(&quot;666&quot;, draw_img)    # 存放正确数字序列（包含逗号）的轮廓，即过滤掉不需要的轮廓    right_loc &#x3D; []    for c in cnts:        x, y, w, h &#x3D; cv2.boundingRect(c)        ar &#x3D; w&#x2F;float(h)        if ar &gt; 2:            right_loc.append((x, y, w, h))    for (gx, gy, gw, gh) in right_loc:        # 用于存放识别到的数字        digit_out &#x3D; []        if (gy-10 &lt; 0):            now_gy &#x3D; gy        else:            now_gy &#x3D; gy-10        if (gx - 10 &lt; 0):            now_gx &#x3D; gx        else:            now_gx &#x3D; gx-10        img_digit &#x3D; gaussian[now_gy:gy+gh+10, now_gx:gx+gw+10]        # 二值化处理        img_thresh &#x3D; cv2.threshold(            img_digit, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]        # 寻找轮廓 找出每个数字的轮廓（包含逗号） 正确的话应该有9个轮廓        digitCnts &#x3D; cv2.findContours(            img_thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)[0]        # 从左到右排列        (cnts, boundingBoxes) &#x3D; contours.sort_contours(digitCnts, &quot;left-to-right&quot;)        cnts &#x3D; list(cnts)        flag &#x3D; 0        if len(cnts) &#x3D;&#x3D; 9:            del cnts[1]            del cnts[2]            del cnts[3]            del cnts[4]            cnts &#x3D; tuple(cnts)            num_roi &#x3D; []            for c in cnts:                x, y, w, h &#x3D; cv2.boundingRect(c)                num_roi.append((x, y, w, h))            for (rx, ry, rw, rh) in num_roi:                roi &#x3D; img_digit[ry:ry+rh, rx:rx+rw]                roi &#x3D; cv2.resize(roi, (57, 88))                roi &#x3D; cv2.GaussianBlur(roi, (5, 5), 1)                roi &#x3D; cv2.threshold(                    roi, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]                source &#x3D; []                for digitROI in digits:                    res &#x3D; cv2.matchTemplate(                        roi, digitROI, cv2.TM_CCOEFF_NORMED)                    max_val &#x3D; cv2.minMaxLoc(res)[1]                    source.append(max_val)                digit_out.append(str(source.index(max(source))))            cv2.rectangle(img_origin, (gx-5, gy-5),                          (gx+gw+5, gy+gh+5), (0, 0, 255), 1)            print(digit_out)        else:            print(&quot;读取失败&quot;)            flag &#x3D; 1        t &#x3D; &#39;&#39;        with open(now_dir + &quot;\\temp.txt&quot;, &#39;a+&#39;) as q:            if flag &#x3D;&#x3D; 0:                for content in digit_out:                    t &#x3D; t + str(content) + &quot; &quot;                q.write(t.strip(&quot; &quot;))                q.write(&#39;\n&#39;)                t &#x3D; &#39;&#39;            else:                q.write(&quot;读取失败&quot;)                q.write(&#39;\n&#39;)if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    # 存放数字模板列表    digits &#x3D; []    # 当前运行目录    now_dir &#x3D; os.getcwd()    print(&quot;当前运行目录：&quot; + now_dir)    numbers_address &#x3D; now_dir + &quot;\\numbers&quot;    load_digits()    times &#x3D; input(&quot;请输入程序运行次数：&quot;)    for i in range(1, int(times) + 1):        demo(i)    print(&quot;输出成功，请检查本地temp.txt文件&quot;)    cv2.waitKey(0)    cv2.destroyAllWindows()    while True:        if input(&quot;输入小写‘q’并回车退出&quot;) &#x3D;&#x3D; &#39;q&#39;:            break<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>整个文件下载地址：<a href="https://wwe.lanzous.com/iLSDunf850b">https://wwe.lanzous.com/iLSDunf850b</a></strong></p><p><strong>注意：如果想同时识别多个图片话，需要将图片统一改名为“demo_ + 数字序号.png”  例如：demo_1.png demo_2.png 同时在运行代码时输入图片个数即可。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个程序代码相对来说不算复杂，主要是对图像的一些基础处理需要注意。因为不同的图像想要识别成功需要进行不同程度的基础处理，所以在做的时候可以多输出几张图片检查一下那一步效果不太好并及时进行修改调整，这样才能达到最终比较好的效果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言数据结构-链表</title>
      <link href="posts/10.html"/>
      <url>posts/10.html</url>
      
        <content type="html"><![CDATA[<h1 id="C语言数据结构-链表"><a href="#C语言数据结构-链表" class="headerlink" title="C语言数据结构-链表"></a>C语言数据结构-链表</h1><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>这篇博客属于学习笔记，是博主在学习链表时的一些笔记，所以不保证内容的完全正确性和严谨性以及简洁等。</strong></p><p><strong>此外由于属于学习笔记所以不会对原理性知识进行讲解，博客重点放在代码上。</strong></p><p>使用环境：</p><ul><li>C语言</li><li>VS2019</li></ul><h2 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h2><p>创建链表的方法可能会有很多种，博主这里使用的是把头结点空出来也就是不给头节点赋值的一种创建方式。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;*结点结构体*&#x2F;struct Node&#123;int data;struct Node* next;&#125;;typedef struct Node Node;&#x2F;*创建链表*&#x2F;Node* createNode()&#123;&#x2F;* head,tail分别指向链表的头结点和尾结点*&#x2F;Node* head, * tail, * p;int num;head &#x3D; (Node*)malloc(sizeof(Node));    &#x2F;*申请内存*&#x2F;tail &#x3D; head;printf(&quot;请输入一组数据，结尾使用&#39;-9999&#39;\n&quot;);(void)scanf(&quot;%d&quot;, &amp;num);while (num !&#x3D; -9999)&#123;p &#x3D; (Node*)malloc(sizeof(Node));    &#x2F;*申请内存*&#x2F;p-&gt;data &#x3D; num;    &#x2F;*结点赋值*&#x2F;tail-&gt;next &#x3D; p;    &#x2F;*当前链表尾指向结点p*&#x2F;tail &#x3D; p;    &#x2F;*将结点p设为尾结点*&#x2F;(void)scanf(&quot;%d&quot;, &amp;num);&#125;tail-&gt;next &#x3D; NULL;    &#x2F;*最后一个结点指向NULL*&#x2F;    printf(&quot;链表创建成功\n&quot;);return head;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="打印链表内容"><a href="#打印链表内容" class="headerlink" title="打印链表内容"></a>打印链表内容</h2><p>因为创建链表是从首结点开始的（从首结点开始赋值），所以打印的时候也要从首结点开始。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;*打印链表*&#x2F;void displayNode(Node* head)&#123;if (head-&gt;next &#x3D;&#x3D; NULL)    &#x2F;*判断链表是否为空*&#x2F;printf(&quot;链表为空\n&quot;);else&#123;Node* p;p &#x3D; head-&gt;next;    &#x2F;*从首结点开始*&#x2F;printf(&quot;链表如下\n&quot;);while (p !&#x3D; NULL)    &#x2F;*遍历打印*&#x2F;&#123;printf(&quot;%d    &quot;, p-&gt;data);p &#x3D; p-&gt;next;&#125;        printf(&quot;\n&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/10/1.jpg" alt="打印链表内容-效果图"></p><p>在这里为了更好的理解代码引用其他博主的博客中的一句话，（出处原地址:<a href="https://blog.csdn.net/qq_41481924/article/details/85340787">C语言链表操作详解</a>)</p><p><strong>我在这着重解释一下p-&gt;next = NULL和p!=NULL的区别，因为我刚开始也经常弄错！！<br>while(p-&gt;next ！= NULL) 循环结束时，此时p的位置是尾节点的位置，但如果用于输出函数的判断条件，则尾节点的数据不会输出。<br>while(p!=NULL) 循环结束时， 此时p指向的位置为尾节点的下一个节点，因为没有申请内存空间，所以是一个未知的区域。</strong></p><p>理解这两句话的话就可以继续下面的学习了。</p><h2 id="释放链表内存"><a href="#释放链表内存" class="headerlink" title="释放链表内存"></a>释放链表内存</h2><p>在结束链表使用的时候需要释放一下内存。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;*释放链表内存*&#x2F;void releaseNode(Node* head)&#123;Node* p1, * p2;p1 &#x3D; head;while (p1 !&#x3D; NULL)&#123;p2 &#x3D; p1;p1 &#x3D; p1-&gt;next;free(p2);&#125;printf(&quot;链表释放内存成功\n&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h2><p>这里提供两种不同目的的删除方式，一种是根据结点值删除，另一种是根据结点位置删除。</p><h3 id="根据结点值删除"><a href="#根据结点值删除" class="headerlink" title="根据结点值删除"></a>根据结点值删除</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*根据结点的值删除链表中结点*&#x2F;void deleteNode_val(Node* head)&#123;if (head-&gt;next &#x3D;&#x3D; NULL)printf(&quot;链表为空\n&quot;);else&#123;Node* p1, * p2;int num;printf(&quot;请输入要删除的结点数值：\n&quot;);(void)scanf(&quot;%d&quot;, &amp;num);p1 &#x3D; head-&gt;next;    &#x2F;*使用p1逐个寻找数据*&#x2F;p2 &#x3D; NULL;while ((p1-&gt;data !&#x3D; num) &amp;&amp; (p1-&gt;next !&#x3D; NULL))    &#x2F;*遍历寻找*&#x2F;&#123;p2 &#x3D; p1;    &#x2F;*用p2记录p1原来的位置*&#x2F;p1 &#x3D; p1-&gt;next;&#125;if (p1-&gt;data &#x3D;&#x3D; num)&#123;if (p1 &#x3D;&#x3D; head-&gt;next)    &#x2F;*判断p1是否为首结点*&#x2F;&#123;head-&gt;next &#x3D; p1-&gt;next;    &#x2F;*如果是则将头结点与首结点的下一个结点链接*&#x2F;&#125;elsep2-&gt;next &#x3D; p1-&gt;next;   &#x2F;*将p1前一个结点p2直接与p1下一个结点链接*&#x2F;free(p1);    &#x2F;*释放p1的内存*&#x2F;printf(&quot;删除成功\n&quot;);&#125;elseprintf(&quot;删除失败\n&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/10/2.jpg" alt="根据结点值删除结点-效果图"></p><h3 id="根据结点位置删除"><a href="#根据结点位置删除" class="headerlink" title="根据结点位置删除"></a>根据结点位置删除</h3><p>这里的位置索引是从“1”开始的，可以通过修改变量<code>now_pos</code>改变位置索引。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*根据结点位置删除结点*&#x2F;void deleteNode_pos(Node* head)&#123;if (head-&gt;next &#x3D;&#x3D; NULL)printf(&quot;链表为空\n&quot;);else&#123;Node* p1, * p2;int  now_pos&#x3D; 1, pos;printf(&quot;请输入要输出结点的位置：\n&quot;);(void)scanf(&quot;%d&quot;, &amp;pos);p1 &#x3D; head-&gt;next;p2 &#x3D; NULL;while ((now_pos !&#x3D; pos) &amp;&amp; (p1-&gt;next !&#x3D; NULL))&#123;p2 &#x3D; p1;p1 &#x3D; p1-&gt;next;now_pos++;&#125;if (now_pos &#x3D;&#x3D; pos)&#123;if (p1 &#x3D;&#x3D; head-&gt;next)head-&gt;next &#x3D; p1-&gt;next;elsep2-&gt;next &#x3D; p1-&gt;next;free(p1);printf(&quot;删除成功\n&quot;);&#125;elseprintf(&quot;删除失败\n&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/10/3.jpg" alt="根据结点位置删除-效果图"></p><h2 id="根据结点位置插入新的结点"><a href="#根据结点位置插入新的结点" class="headerlink" title="根据结点位置插入新的结点"></a>根据结点位置插入新的结点</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;*根据结点位置插入新的结点*&#x2F;void insertNode(Node* head)&#123;if (head-&gt;next !&#x3D; NULL)&#123;int pos, val, now_pos &#x3D; 1;Node* p, * p1, * p2;p &#x3D; (Node*)malloc(sizeof(Node));printf(&quot;请输入要插入的值和位置\n&quot;);(void)scanf(&quot;%d %d&quot;, &amp;val, &amp;pos);p-&gt;data &#x3D; val;p-&gt;next &#x3D; NULL;p1 &#x3D; head-&gt;next;p2 &#x3D; NULL;while ((now_pos !&#x3D; pos) &amp;&amp; (p1 !&#x3D; NULL))    &#x2F;*注意这里，如果使用p1-&gt;next则没办法在插入到最后*&#x2F;&#123;p2 &#x3D; p1;p1 &#x3D; p1-&gt;next;now_pos++;&#125;if (now_pos &#x3D;&#x3D; pos)&#123;if (p1 &#x3D;&#x3D; head-&gt;next)&#123;head-&gt;next &#x3D; p;p-&gt;next &#x3D; p1;&#125;else&#123;p2-&gt;next &#x3D; p;p-&gt;next &#x3D; p1;&#125;printf(&quot;插入成功\n&quot;);&#125;elseprintf(&quot;插入失败\n&quot;);&#125;elseprintf(&quot;链表为空\n&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/10/4.jpg" alt="根据结点位置插入新的结点-效果图"></p><h2 id="根据结点位置修改结点的值"><a href="#根据结点位置修改结点的值" class="headerlink" title="根据结点位置修改结点的值"></a>根据结点位置修改结点的值</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*根据结点位置修改结点的值*&#x2F;void changeNode(Node* head)&#123;if (head-&gt;next &#x3D;&#x3D; NULL)printf(&quot;链表为空\n&quot;);else&#123;int now_pos &#x3D; 1, pos, val;Node* p1;printf(&quot;请输入要修改的值和位置\n&quot;);(void)scanf(&quot;%d %d&quot;, &amp;val, &amp;pos);p1 &#x3D; head-&gt;next;while ((now_pos !&#x3D; pos) &amp;&amp; (p1-&gt;next !&#x3D; NULL))&#123;p1 &#x3D; p1-&gt;next;now_pos++;&#125;if (now_pos &#x3D;&#x3D; pos)&#123;p1-&gt;data &#x3D; val;printf(&quot;修改成功\n&quot;);&#125;elseprintf(&quot;修改失败\n&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/10/5.jpg" alt="根据结点位置修改结点的值-效果图"></p><h2 id="根据结点的值查找结点位置"><a href="#根据结点的值查找结点位置" class="headerlink" title="根据结点的值查找结点位置"></a>根据结点的值查找结点位置</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*根据结点的值查找结点位置*&#x2F;void checkNode(Node* head)&#123;if (head-&gt;next &#x3D;&#x3D; NULL)printf(&quot;链表为空\n&quot;);else&#123;Node* p1;int val, now_pos &#x3D; 1;printf(&quot;请输入要查询的值：\n&quot;);(void)scanf(&quot;%d&quot;, &amp;val);p1 &#x3D; head-&gt;next;while ((p1-&gt;data !&#x3D; val) &amp;&amp; (p1-&gt;next !&#x3D; NULL))&#123;now_pos++;p1 &#x3D; p1-&gt;next;&#125;if (p1-&gt;data &#x3D;&#x3D; val)printf(&quot;位置为：%d\n&quot;, now_pos);elseprintf(&quot;未找到\n&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/10/6.jpg" alt="根据结点的值查找结点位置-效果图"></p><h2 id="根据结点的位置查找结点的值"><a href="#根据结点的位置查找结点的值" class="headerlink" title="根据结点的位置查找结点的值"></a>根据结点的位置查找结点的值</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*根据结点的位置查找结点的值*&#x2F;void checkNode_pos(Node* head)&#123;if (head-&gt;next &#x3D;&#x3D; NULL)printf(&quot;链表为空\n&quot;);else&#123;Node* p1;int pos, now_pos &#x3D; 1;printf(&quot;请输入要查询的位置：\n&quot;);(void)scanf(&quot;%d&quot;, &amp;pos);p1 &#x3D; head-&gt;next;while ((now_pos !&#x3D; pos) &amp;&amp; (p1-&gt;next !&#x3D; NULL))&#123;p1 &#x3D; p1-&gt;next;now_pos++;&#125;if (now_pos &#x3D;&#x3D; pos)printf(&quot;结点值为：%d\n&quot;, p1-&gt;data);elseprintf(&quot;未找到\n&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/10/7.jpg" alt="根据结点的位置查找结点的值-效果图"></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#include &lt;stdlib.h&gt;struct Node&#123;int data;struct Node* next;&#125;;typedef struct Node Node;&#x2F;*创建链表*&#x2F;Node* createNode()&#123;&#x2F;* head,tail分别指向链表的头结点和尾结点*&#x2F;Node* head, * tail, * p;int num;head &#x3D; (Node*)malloc(sizeof(Node));tail &#x3D; head;printf(&quot;请输入一组数据，结尾使用&#39;-9999&#39;\n&quot;);(void)scanf(&quot;%d&quot;, &amp;num);while (num !&#x3D; -9999)&#123;p &#x3D; (Node*)malloc(sizeof(Node));    &#x2F;*申请内存*&#x2F;&#x2F;&#x2F;if (p &#x3D;&#x3D; NULL)&#x2F;&#x2F;exit(0);p-&gt;data &#x3D; num;tail-&gt;next &#x3D; p;tail &#x3D; p;(void)scanf(&quot;%d&quot;, &amp;num);&#125;tail-&gt;next &#x3D; NULL;return head;&#125;&#x2F;*打印链表*&#x2F;void displayNode(Node* head)&#123;if (head-&gt;next &#x3D;&#x3D; NULL)printf(&quot;链表为空\n&quot;);else&#123;Node* p;p &#x3D; head-&gt;next;    &#x2F;*从首结点开始*&#x2F;printf(&quot;链表如下\n&quot;);while (p !&#x3D; NULL)&#123;printf(&quot;%d    &quot;, p-&gt;data);p &#x3D; p-&gt;next;&#125;printf(&quot;\n&quot;);&#125;&#125;&#x2F;*释放链表内存*&#x2F;void releaseNode(Node* head)&#123;Node* p1, * p2;p1 &#x3D; head;while (p1 !&#x3D; NULL)&#123;p2 &#x3D; p1;p1 &#x3D; p1-&gt;next;free(p2);&#125;printf(&quot;链表释放内存成功\n&quot;);&#125;&#x2F;*根据结点的值删除链表中结点*&#x2F;void deleteNode_val(Node* head)&#123;if (head-&gt;next &#x3D;&#x3D; NULL)printf(&quot;链表为空\n&quot;);else&#123;Node* p1, * p2;int num;printf(&quot;请输入要删除的结点数值：\n&quot;);(void)scanf(&quot;%d&quot;, &amp;num);p1 &#x3D; head-&gt;next;    &#x2F;*使用p1逐个寻找数据*&#x2F;p2 &#x3D; NULL;while ((p1-&gt;data !&#x3D; num) &amp;&amp; (p1-&gt;next !&#x3D; NULL))&#123;p2 &#x3D; p1;    &#x2F;*用p2记录p1原来的位置*&#x2F;p1 &#x3D; p1-&gt;next;&#125;if (p1-&gt;data &#x3D;&#x3D; num)&#123;if (p1 &#x3D;&#x3D; head-&gt;next)&#123;head-&gt;next &#x3D; p1-&gt;next;&#125;elsep2-&gt;next &#x3D; p1-&gt;next;   &#x2F;*将p1前一个结点p2直接与p1下一个结点链接*&#x2F;free(p1);printf(&quot;删除成功\n&quot;);&#125;elseprintf(&quot;删除失败\n&quot;);&#125;&#x2F;&#x2F; return head;&#125;&#x2F;*根据结点位置删除结点*&#x2F;void deleteNode_pos(Node* head)&#123;if (head-&gt;next &#x3D;&#x3D; NULL)printf(&quot;链表为空\n&quot;);else&#123;Node* p1, * p2;int  now_pos&#x3D; 1, pos;printf(&quot;请输入要输出结点的位置：\n&quot;);(void)scanf(&quot;%d&quot;, &amp;pos);p1 &#x3D; head-&gt;next;p2 &#x3D; NULL;while ((now_pos !&#x3D; pos) &amp;&amp; (p1-&gt;next !&#x3D; NULL))&#123;p2 &#x3D; p1;p1 &#x3D; p1-&gt;next;now_pos++;&#125;if (now_pos &#x3D;&#x3D; pos)&#123;if (p1 &#x3D;&#x3D; head-&gt;next)head-&gt;next &#x3D; p1-&gt;next;elsep2-&gt;next &#x3D; p1-&gt;next;free(p1);printf(&quot;删除成功\n&quot;);&#125;elseprintf(&quot;删除失败\n&quot;);&#125;&#125;&#x2F;*根据结点位置插入新的结点*&#x2F;void insertNode(Node* head)&#123;if (head-&gt;next !&#x3D; NULL)&#123;int pos, val, now_pos &#x3D; 1;Node* p, * p1, * p2;p &#x3D; (Node*)malloc(sizeof(Node));printf(&quot;请输入要插入的值和位置\n&quot;);(void)scanf(&quot;%d %d&quot;, &amp;val, &amp;pos);p-&gt;data &#x3D; val;p-&gt;next &#x3D; NULL;p1 &#x3D; head-&gt;next;p2 &#x3D; NULL;while ((now_pos !&#x3D; pos) &amp;&amp; (p1 !&#x3D; NULL))&#123;p2 &#x3D; p1;p1 &#x3D; p1-&gt;next;now_pos++;&#125;if (now_pos &#x3D;&#x3D; pos)&#123;if (p1 &#x3D;&#x3D; head-&gt;next)&#123;head-&gt;next &#x3D; p;p-&gt;next &#x3D; p1;&#125;else&#123;p2-&gt;next &#x3D; p;p-&gt;next &#x3D; p1;&#125;printf(&quot;插入成功\n&quot;);&#125;elseprintf(&quot;插入失败\n&quot;);&#125;elseprintf(&quot;链表为空\n&quot;);&#125;&#x2F;*根据结点位置修改结点的值*&#x2F;void changeNode(Node* head)&#123;if (head-&gt;next &#x3D;&#x3D; NULL)printf(&quot;链表为空\n&quot;);else&#123;int now_pos &#x3D; 1, pos, val;Node* p1;printf(&quot;请输入要修改的值和位置\n&quot;);(void)scanf(&quot;%d %d&quot;, &amp;val, &amp;pos);p1 &#x3D; head-&gt;next;while ((now_pos !&#x3D; pos) &amp;&amp; (p1-&gt;next !&#x3D; NULL))&#123;p1 &#x3D; p1-&gt;next;now_pos++;&#125;if (now_pos &#x3D;&#x3D; pos)&#123;p1-&gt;data &#x3D; val;printf(&quot;修改成功\n&quot;);&#125;elseprintf(&quot;修改失败\n&quot;);&#125;&#125;&#x2F;*根据结点的值查找结点位置*&#x2F;void checkNode_val(Node* head)&#123;if (head-&gt;data &#x3D;&#x3D; NULL)printf(&quot;链表为空\n&quot;);else&#123;Node* p1;int val, now_pos &#x3D; 1;printf(&quot;请输入要查询的值：\n&quot;);(void)scanf(&quot;%d&quot;, &amp;val);p1 &#x3D; head-&gt;next;while ((p1-&gt;data !&#x3D; val) &amp;&amp; (p1-&gt;next !&#x3D; NULL))&#123;now_pos++;p1 &#x3D; p1-&gt;next;&#125;if (p1-&gt;data &#x3D;&#x3D; val)printf(&quot;位置为：%d\n&quot;, now_pos);elseprintf(&quot;未找到\n&quot;);&#125;&#125;&#x2F;*根据结点的位置查找结点的值*&#x2F;void checkNode_pos(Node* head)&#123;if (head-&gt;next &#x3D;&#x3D; NULL)printf(&quot;链表为空\n&quot;);else&#123;Node* p1;int pos, now_pos &#x3D; 1;printf(&quot;请输入要查询的位置：\n&quot;);(void)scanf(&quot;%d&quot;, &amp;pos);p1 &#x3D; head-&gt;next;while ((now_pos !&#x3D; pos) &amp;&amp; (p1-&gt;next !&#x3D; NULL))&#123;p1 &#x3D; p1-&gt;next;now_pos++;&#125;if (now_pos &#x3D;&#x3D; pos)printf(&quot;结点值为：%d\n&quot;, p1-&gt;data);elseprintf(&quot;未找到\n&quot;);&#125;&#125;int main()&#123;Node* head;head &#x3D; createNode();    &#x2F;&#x2F; 创建列表displayNode(head);    &#x2F;&#x2F; 打印&#x2F;&#x2F; releaseNode(head);&#x2F;&#x2F; deleteNode_val(head);&#x2F;&#x2F; deleteNode_pos(head);&#x2F;&#x2F; insertNode(head);&#x2F;&#x2F; changeNode(head);&#x2F;&#x2F; checkNode_val(head);checkNode_pos(head);displayNode(head);releaseNode(head);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整理收藏好用的宝藏网站</title>
      <link href="posts/9.html"/>
      <url>posts/9.html</url>
      
        <content type="html"><![CDATA[<h1 id="整理收藏好用的宝藏网站"><a href="#整理收藏好用的宝藏网站" class="headerlink" title="整理收藏好用的宝藏网站"></a>整理收藏好用的宝藏网站</h1><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇博客里面的所有网站均是来源于网络收集，是博主个人看到好玩或者有用的网站才收集的。</p><p>这些网站有些需要科学上网的手段才能进入，所以懂的都懂。</p><p>本篇博客会持续更新的，更新时间可以从博客上方看到。</p><hr><h2 id="推荐网站"><a href="#推荐网站" class="headerlink" title="推荐网站"></a>推荐网站</h2><ul><li><p>壁纸网站：<a href="https://wallhaven.cc/">https://wallhaven.cc/</a></p><p>介绍：这个网站上面有很多精美壁纸。懂的都懂。</p></li><li><p>Al捏人：<a href="https://artbreeder.com/">https://artbreeder.com/</a></p><p>介绍：算是AI合成图片的一种吧，可以随意合成自己想要的图片。可以合成之后用来当头像，毕竟是AI合成的，在一定程度上可以保证“独一无二”的特点。并且合成方向还可以根据自己喜好改变。挺好的。</p></li><li><p>网易见外：<a href="https://jianwai.netease.com/">https://jianwai.netease.com/</a></p><p>介绍：翻译网站。可以把视频翻译。</p></li><li><p>商用图片：<a href="https://www.pexels.com/zh-cn/">https://www.pexels.com/zh-cn/</a></p><p>介绍：顾名思义。免费的商用图片，懂的都懂。</p></li><li><p>把人声和伴奏分开：<a href="https://vocalremover.org/">https://vocalremover.org</a></p><p>介绍：懂的都懂。分伴奏的，效果挺好的。不用挂梯子就能进。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 资源分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习入门笔记</title>
      <link href="posts/8.html"/>
      <url>posts/8.html</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习入门笔记"><a href="#机器学习入门笔记" class="headerlink" title="机器学习入门笔记"></a>机器学习入门笔记</h1><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个是根据“黑马程序员”的一套机器学习课程编写的博客。这篇博客上的案例均为课程里面的，但并没有包含所有案例，只是记录了部分。</p><p><a href="https://www.bilibili.com/video/BV1nt411r7tj">B站视频原地址</a></p><h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><h3 id="Tf-idf文本特征提取"><a href="#Tf-idf文本特征提取" class="headerlink" title="Tf-idf文本特征提取"></a>Tf-idf文本特征提取</h3><h4 id="Tf-idf介绍"><a href="#Tf-idf介绍" class="headerlink" title="Tf-idf介绍"></a>Tf-idf介绍</h4><ul><li><p>TF-IDF的主要思想是：如果<strong>某个词或短语在一篇文章中出现的概率高，并且在其他文章中很少出现</strong>，则认为此词或者短语具有很好的类别区分能力，适合用来分类。</p></li><li><p><strong>TF-IDF作用：用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。</strong></p></li><li><p>词频（term frequency，tf）指的是某一个给定的词语在该文件中出现的频率</p></li><li><p>逆向文档频率（inverse document frequency，idf）是一个词语普遍重要性的度量。某一特定词语的idf，可以<strong>由总文件数目除以包含该词语之文件的数目，再将得到的商取以10为底的对数得到</strong></p></li></ul><p><img src="/posts/8/1.png" alt="tfidf公式"></p><p>最终得出结果可以理解为重要程度。</p><p>注：假如一篇文件的总词语数是100个，而词语”非常”出现了5次，那么”非常”一词在该文件中的词频就是5/100=0.05。而计算文件频率（IDF）的方法是以文件集的文件总数，除以出现”非常”一词的文件数。所以，如果”非常”一词在1,000份文件出现过，而文件总数是10,000,000份的话，其逆向文件频率就是lg（10,000,000 / 1,0000）=3。最后”非常”对于这篇文档的tf-idf的分数为0.05 * 3=0.15</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from sklearn.feature_extraction.text import TfidfVectorizer    # Tf-idf文本特征提取import jieba    # 分词模块def cut_word(text):    &quot;&quot;&quot;    对中文进行分词    &quot;我爱北京天安门&quot;————&gt;&quot;我 爱 北京 天安门&quot;    :param text:    :return: text    &quot;&quot;&quot;    # 用结巴对中文字符串进行分词    text &#x3D; &quot; &quot;.join(list(jieba.cut(text)))    return textdef text_chinese_tfidf_demo():    &quot;&quot;&quot;    对中文进行特征抽取    :return: None    &quot;&quot;&quot;    data &#x3D; [&quot;一种还是一种今天很残酷，明天更残酷，后天很美好，但绝对大部分是死在明天晚上，所以每个人不要放弃今天。&quot;,            &quot;我们看到的从很远星系来的光是在几百万年之前发出的，这样当我们看到宇宙时，我们是在看它的过去。&quot;,            &quot;如果只用一种方式了解某样事物，你就不会真正了解它。了解事物真正含义的秘密取决于如何将其与我们所了解的事物相联系。&quot;]    # 将原始数据转换成分好词的形式    text_list &#x3D; []    for sent in data:        text_list.append(cut_word(sent))    print(text_list)    # 1、实例化一个转换器类    # transfer &#x3D; CountVectorizer(sparse&#x3D;False)    transfer &#x3D; TfidfVectorizer(stop_words&#x3D;[&#39;一种&#39;, &#39;不会&#39;, &#39;不要&#39;])    # 2、调用fit_transform    data &#x3D; transfer.fit_transform(text_list)    print(&quot;文本特征抽取的结果：\n&quot;, data.toarray())    print(&quot;返回特征名字：\n&quot;, transfer.get_feature_names())    return None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Building prefix dict from the default dictionary ...Loading model from cache &#x2F;var&#x2F;folders&#x2F;mz&#x2F;tzf2l3sx4rgg6qpglfb035_r0000gn&#x2F;T&#x2F;jieba.cacheLoading model cost 0.856 seconds.Prefix dict has been built succesfully.[&#39;一种 还是 一种 今天 很 残酷 ， 明天 更 残酷 ， 后天 很 美好 ， 但 绝对 大部分 是 死 在 明天 晚上 ， 所以 每个 人 不要 放弃 今天 。&#39;, &#39;我们 看到 的 从 很 远 星系 来 的 光是在 几百万年 之前 发出 的 ， 这样 当 我们 看到 宇宙 时 ， 我们 是 在 看 它 的 过去 。&#39;, &#39;如果 只用 一种 方式 了解 某样 事物 ， 你 就 不会 真正 了解 它 。 了解 事物 真正 含义 的 秘密 取决于 如何 将 其 与 我们 所 了解 的 事物 相 联系 。&#39;]文本特征抽取的结果： [[ 0.          0.          0.          0.43643578  0.          0.          0.   0.          0.          0.21821789  0.          0.21821789  0.          0.   0.          0.          0.21821789  0.21821789  0.          0.43643578   0.          0.21821789  0.          0.43643578  0.21821789  0.          0.   0.          0.21821789  0.21821789  0.          0.          0.21821789   0.        ] [ 0.2410822   0.          0.          0.          0.2410822   0.2410822   0.2410822   0.          0.          0.          0.          0.          0.   0.          0.2410822   0.55004769  0.          0.          0.          0.   0.2410822   0.          0.          0.          0.          0.48216441   0.          0.          0.          0.          0.          0.2410822   0.          0.2410822 ] [ 0.          0.644003    0.48300225  0.          0.          0.          0.   0.16100075  0.16100075  0.          0.16100075  0.          0.16100075   0.16100075  0.          0.12244522  0.          0.          0.16100075   0.          0.          0.          0.16100075  0.          0.          0.   0.3220015   0.16100075  0.          0.          0.16100075  0.          0.   0.        ]]返回特征名字： [&#39;之前&#39;, &#39;了解&#39;, &#39;事物&#39;, &#39;今天&#39;, &#39;光是在&#39;, &#39;几百万年&#39;, &#39;发出&#39;, &#39;取决于&#39;, &#39;只用&#39;, &#39;后天&#39;, &#39;含义&#39;, &#39;大部分&#39;, &#39;如何&#39;, &#39;如果&#39;, &#39;宇宙&#39;, &#39;我们&#39;, &#39;所以&#39;, &#39;放弃&#39;, &#39;方式&#39;, &#39;明天&#39;, &#39;星系&#39;, &#39;晚上&#39;, &#39;某样&#39;, &#39;残酷&#39;, &#39;每个&#39;, &#39;看到&#39;, &#39;真正&#39;, &#39;秘密&#39;, &#39;绝对&#39;, &#39;美好&#39;, &#39;联系&#39;, &#39;过去&#39;, &#39;还是&#39;, &#39;这样&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Tf-idf的重要性"><a href="#Tf-idf的重要性" class="headerlink" title="Tf-idf的重要性"></a>Tf-idf的重要性</h4><p><strong>分类机器学习算法进行文章分类中前期数据处理方式</strong></p><h3 id="无量纲化处理—标准化"><a href="#无量纲化处理—标准化" class="headerlink" title="无量纲化处理—标准化"></a>无量纲化处理—标准化</h3><p><strong>注意：无量纲化包括归一化和标准化，因为经常使用标准化所以这里只介绍标准化。</strong></p><h4 id="为什么我们要进行标准化？"><a href="#为什么我们要进行标准化？" class="headerlink" title="为什么我们要进行标准化？"></a>为什么我们要进行标准化？</h4><ul><li>特征的<strong>单位或者大小相差较大，或者某特征的方差相比其他的特征要大出几个数量级</strong>，<strong>容易影响（支配）目标结果</strong>，使得一些算法无法学习到其它的特征</li></ul><p><img src="/posts/8/2.png" alt="约会对象数据"></p><p>我们需要用到一些方法进行<strong>无量纲化</strong>，<strong>使不同规格的数据转换到同一规格</strong></p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>通过对原始数据进行变换把数据变换到均值为0,标准差为1范围内</li></ul><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><ul><li>sklearn.preprocessing.StandardScaler( )<ul><li>处理之后每列来说所有数据都聚集在均值0附近标准差差为1</li><li>StandardScaler.fit_transform(X)<ul><li>X:numpy array格式的数据[n_samples,n_features]</li></ul></li><li>返回值：转换后的形状相同的array</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pandas as pdfrom sklearn.preprocessing import StandardScaler    # 标准化def stand_demo():    &quot;&quot;&quot;    标准化演示    :return: None    &quot;&quot;&quot;    data &#x3D; pd.read_csv(&quot;dating.txt&quot;)    print(data)    # 1、实例化一个转换器类    transfer &#x3D; StandardScaler()    # 2、调用fit_transform    data &#x3D; transfer.fit_transform(data[[&#39;milage&#39;,&#39;Liters&#39;,&#39;Consumtime&#39;]])    print(&quot;标准化的结果:\n&quot;, data)    print(&quot;每一列特征的平均值：\n&quot;, transfer.mean_)    print(&quot;每一列特征的方差：\n&quot;, transfer.var_)    return None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">     milage     Liters  Consumtime  target0     40920   8.326976    0.953952       31     14488   7.153469    1.673904       22     26052   1.441871    0.805124       1..      ...        ...         ...     ...997   26575  10.650102    0.866627       3998   48111   9.134528    0.728045       3999   43757   7.882601    1.332446       3[1000 rows x 4 columns]标准化的结果: [[ 0.33193158  0.41660188  0.24523407] [-0.87247784  0.13992897  1.69385734] [-0.34554872 -1.20667094 -0.05422437] ...,  [-0.32171752  0.96431572  0.06952649] [ 0.65959911  0.60699509 -0.20931587] [ 0.46120328  0.31183342  1.00680598]]每一列特征的平均值： [  3.36354210e+04   6.55996083e+00   8.32072997e-01]每一列特征的方差： [  4.81628039e+08   1.79902874e+01   2.46999554e-01]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="标准化总结"><a href="#标准化总结" class="headerlink" title="标准化总结"></a>标准化总结</h4><p>在已有样本足够多的情况下比较稳定，适合现代嘈杂大数据场景。</p><h2 id="PCA降维"><a href="#PCA降维" class="headerlink" title="PCA降维"></a>PCA降维</h2><h4 id="什么是主成分分析-PCA"><a href="#什么是主成分分析-PCA" class="headerlink" title="什么是主成分分析(PCA)"></a>什么是主成分分析(PCA)</h4><ul><li>定义：<strong>高维数据转化为低维数据的过程</strong>，在此过程中<strong>可能会舍弃原有数据、创造新的变量</strong></li><li>作用：<strong>是数据维数压缩，尽可能降低原数据的维数（复杂度），损失少量信息。</strong></li><li>应用：回归分析或者聚类分析当中</li></ul><blockquote><p>对于信息一词，在决策树中会进行介绍</p></blockquote><p>那么更好的理解这个过程呢？我们来看一张图</p><p><img src="/posts/8/3.png" alt="PCA解释图"></p><h4 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h4><ul><li>sklearn.decomposition.PCA(n_components=None)<ul><li>将数据分解为较低维数空间</li><li>n_components:<ul><li><strong>小数：表示保留百分之多少的信息</strong></li><li><strong>整数：减少到多少特征</strong></li></ul></li><li>PCA.fit_transform(X) X:numpy array格式的数据[n_samples,n_features]</li><li>返回值：转换后指定维度的array</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">from sklearn.decomposition import PCA    # PCAdef pca_demo():    &quot;&quot;&quot;    对数据进行PCA降维    :return: None    &quot;&quot;&quot;    data &#x3D; [[2,8,4,5], [6,3,0,8], [5,4,9,1]]    # 1、实例化PCA, 小数——保留多少信息    transfer &#x3D; PCA(n_components&#x3D;0.9)    # 2、调用fit_transform    data1 &#x3D; transfer.fit_transform(data)    print(&quot;保留90%的信息，降维结果为：\n&quot;, data1)    # 1、实例化PCA, 整数——指定降维到的维数    transfer2 &#x3D; PCA(n_components&#x3D;3)    # 2、调用fit_transform    data2 &#x3D; transfer2.fit_transform(data)    print(&quot;降维到3维的结果：\n&quot;, data2)    return None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">保留90%的信息，降维结果为： [[ -3.13587302e-16   3.82970843e+00] [ -5.74456265e+00  -1.91485422e+00] [  5.74456265e+00  -1.91485422e+00]]降维到3维的结果： [[ -3.13587302e-16   3.82970843e+00   4.59544715e-16] [ -5.74456265e+00  -1.91485422e+00   4.59544715e-16] [  5.74456265e+00  -1.91485422e+00   4.59544715e-16]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分类算法"><a href="#分类算法" class="headerlink" title="分类算法"></a>分类算法</h2><h3 id="数据集划分"><a href="#数据集划分" class="headerlink" title="数据集划分"></a>数据集划分</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>机器学习一般的数据集会划分为两个部分：</p><ul><li>训练数据：用于训练，构建模型</li><li>测试数据：在模型检验时使用，用于评估模型是否有效</li></ul><p>划分比例：</p><ul><li>训练集：70% 80% 75%</li><li>测试集：30% 20% 30%</li></ul><h4 id="API-2"><a href="#API-2" class="headerlink" title="API"></a>API</h4><ul><li>sklearn.model_selection.train_test_split(arrays, *options)<ul><li>x 数据集的特征值</li><li>y 数据集的标签值</li><li>test_size 测试集的大小，一般为float</li><li>random_state 随机数种子,不同的种子会造成不同的随机采样结果。相同的种子采样结果相同。</li><li>return ，测试集特征训练集特征值值，训练标签，测试标签(默认随机取)</li></ul></li></ul><p>结合后面的数据集作介绍</p><h3 id="K-近邻算法"><a href="#K-近邻算法" class="headerlink" title="K-近邻算法"></a>K-近邻算法</h3><h4 id="K-近邻算法定义"><a href="#K-近邻算法定义" class="headerlink" title="K-近邻算法定义"></a>K-近邻算法定义</h4><ul><li>如果一个样本在特征空间中的<strong>k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别</strong>，则该样本也属于这个类别。</li></ul><h4 id="距离公式"><a href="#距离公式" class="headerlink" title="距离公式"></a>距离公式</h4><ul><li>两个样本的距离可以通过如下公式计算，又叫欧式距离</li></ul><p><img src="/posts/8/4.png" alt="距离公式"></p><h4 id="API-3"><a href="#API-3" class="headerlink" title="API"></a>API</h4><p>sklearn.neighbors.KNeighborsClassifier(n_neighbors=5,algorithm=’auto’)</p><ul><li>n_neighbors：int,可选（默认= 5），k_neighbors查询默认使用的邻居数</li><li>algorithm：{‘auto’，‘ball_tree’，‘kd_tree’，‘brute’}，可选用于计算最近邻居的算法：‘ball_tree’将会使用 BallTree，‘kd_tree’将使用 KDTree。‘auto’将尝试根据传递给fit方法的值来决定最合适的算法。 (不同实现方式影响效率)<pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;1. 获取数据2. 数据集划分3. 特征工程---标准化4. KNN预估器流程5. 模型评估&quot;&quot;&quot;from sklearn.datasets import load_iris    # 数据集from sklearn.model_selection import train_test_split    # 数据集划分from sklearn.preprocessing import StandardScaler    # 标准化from sklearn.neighbors import KNeighborsClassifier    # KNN算法def knn_iris():    &quot;&quot;&quot;    用KNN算法对鸢尾花进行分类    &quot;&quot;&quot;    # 1. 获取数据    iris &#x3D; load_iris()    # 2. 数据集划分    &quot;&quot;&quot;    x是特征值 y是目标值    训练集的特征值x_train 测试集的特征值x_test 训练集的目标值y_train 测试集的目标值y_test    &quot;&quot;&quot;    # random_state 随机数种子,不同的种子会造成不同的随机采样结果。相同的种子采样结果相同。    x_train, x_test, y_train, y_test &#x3D; train_test_split(        iris.data, iris.target, random_state&#x3D;6)    # 3. 特征工程---标准化    # 训练集和测试集都要进行标准化    transfer &#x3D; StandardScaler()    # 训练集标准化    x_train &#x3D; transfer.fit_transform(x_train)    # 测试集标准化    注意与训练集标准化的区分    x_test &#x3D; transfer.transform(x_test)    # 4. KNN预估器流程    # n_neighbors就是k值    estimator &#x3D; KNeighborsClassifier(n_neighbors&#x3D;3)    estimator.fit(x_train, y_train)    # 5. 模型评估    # 方法1：直接比对真实值和预测值    y_predict &#x3D; estimator.predict(x_test)    print(&quot;y_predict:\n&quot;, y_predict)    print(&quot;直接比对真实值和预测值:\n&quot;, y_test &#x3D;&#x3D; y_predict)    # 方法2：计算准确率    score &#x3D; estimator.score(x_test, y_test)    print(&quot;准确率为：\n&quot;, score)    return Noneif __name__ &#x3D;&#x3D; &quot;__main__&quot;:    knn_iris()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>结果：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">y_predict: [0 2 0 0 2 1 1 0 2 1 2 1 2 2 1 1 2 1 1 0 0 2 0 0 1 1 1 2 0 1 0 1 0 0 1 2 1 2]直接比对真实值和预测值: [ True  True  True  True  True  True False  True  True  True  True  True  True  True  True False  True  True  True  True  True  True  True  True  True  True  True  True  True  True  True  True  True  True False  True  True  True]准确率为： 0.9210526315789473<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="模型选择与调优"><a href="#模型选择与调优" class="headerlink" title="模型选择与调优"></a>模型选择与调优</h3><p>模型选择与调优这里有”交叉验证“和”超参数搜索（网格搜索）“两种，通过调用sklearn中的函数可以直接同时实现这两种功能。</p><h4 id="API-4"><a href="#API-4" class="headerlink" title="API"></a>API</h4><ul><li>sklearn.model_selection.GridSearchCV(estimator, param_grid=None,cv=None)<ul><li>对估计器的指定参数值进行详尽搜索</li><li>estimator：估计器对象</li><li>param_grid：估计器参数(dict){“n_neighbors”:[1,3,5]}</li><li>cv：指定几折交叉验证</li><li></li><li>fit：输入训练数据</li><li>score：准确率</li><li>结果分析：<ul><li>best<em>score</em>:在交叉验证中验证的最好结果_</li><li>best<em>estimator</em>：最好的参数模型</li><li>cv<em>results</em>:每次交叉验证后的验证集准确率结果和训练集准确率结果</li></ul></li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;1. 获取数据2. 数据集划分3. 特征工程---标准化4. KNN预估器流程5. 模型评估&quot;&quot;&quot;from sklearn.datasets import load_iris    # 数据集from sklearn.model_selection import train_test_split    # 数据集划分from sklearn.preprocessing import StandardScaler    # 标准化from sklearn.neighbors import KNeighborsClassifier    # KNN算法from sklearn.model_selection import GridSearchCV    # 模型优化def knn_iris_gscv():    &quot;&quot;&quot;    用KNN算法对鸢尾花进行分类    使用交叉验证和网格搜索进行模型优化与调优    &quot;&quot;&quot;    iris &#x3D; load_iris()    x_train, x_test, y_train, y_test &#x3D; train_test_split(        iris.data, iris.target, random_state&#x3D;6)    transfer &#x3D; StandardScaler()    x_train &#x3D; transfer.fit_transform(x_train)    x_test &#x3D; transfer.transform(x_test)    estimator &#x3D; KNeighborsClassifier()    # 加入网格搜索与交叉验证    param_dict &#x3D; &#123;&quot;n_neighbors&quot;: [1, 3, 5, 7, 9, 11]&#125;    # param_grid：估计器参数(dict) 例如：&#123;“n_neighbors”:[1,3,5]&#125;    # cv：指定几折交叉验证    estimator &#x3D; GridSearchCV(estimator, param_grid&#x3D;param_dict, cv&#x3D;10)    estimator.fit(x_train, y_train)    # 模型评估    # 方法1：直接比对真实值和预测值    y_predict &#x3D; estimator.predict(x_test)    print(&quot;y_predict:\n&quot;, y_predict)    print(&quot;直接比对真实值和预测值:\n&quot;, y_test &#x3D;&#x3D; y_predict)    # 方法2：计算准确率    score &#x3D; estimator.score(x_test, y_test)    print(&quot;准确率为：\n&quot;, score)    # 最佳参数：best_params_    print(&quot;最佳参数：\n&quot;, estimator.best_params_)    # 最佳结果：best_score_    print(&quot;最佳结果：\n&quot;, estimator.best_score_)    # 最佳估计器：best_estimator_    print(&quot;最佳估计器:\n&quot;, estimator.best_estimator_)    # 交叉验证结果：cv_results_    print(&quot;交叉验证结果:\n&quot;, estimator.cv_results_)    return Noneif __name__ &#x3D;&#x3D; &quot;__main__&quot;:    knn_iris_gscv()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">y_predict: [0 2 0 0 2 1 2 0 2 1 2 1 2 2 1 1 2 1 1 0 0 2 0 0 1 1 1 2 0 1 0 1 0 0 1 2 1 2]直接比对真实值和预测值: [ True  True  True  True  True  True  True  True  True  True  True  True  True  True  True False  True  True  True  True  True  True  True  True  True  True  True  True  True  True  True  True  True  True False  True  True  True]准确率为： 0.9473684210526315最佳参数： &#123;&#39;n_neighbors&#39;: 11&#125;最佳结果： 0.9734848484848484最佳估计器: KNeighborsClassifier(n_neighbors&#x3D;11)交叉验证结果: &#123;&#39;mean_fit_time&#39;: array([0.00069556, 0.00049865, 0.0005944 , 0.00069988, 0.00059845,       0.0003933 ]), &#39;std_fit_time&#39;: array([0.00045544, 0.00049865, 0.00048581, 0.00045873, 0.00048918,       0.00048186]), &#39;mean_score_time&#39;: array([0.00119884, 0.00119665, 0.00120168, 0.00109487, 0.0012959 ,       0.00129161]), &#39;std_score_time&#39;: array([0.00039571, 0.00039928, 0.00038471, 0.00030016, 0.00044617,       0.00045765]), &#39;param_n_neighbors&#39;: masked_array(data&#x3D;[1, 3, 5, 7, 9, 11],             mask&#x3D;[False, False, False, False, False, False],       fill_value&#x3D;&#39;?&#39;,            dtype&#x3D;object), &#39;params&#39;: [&#123;&#39;n_neighbors&#39;: 1&#125;, &#123;&#39;n_neighbors&#39;: 3&#125;, &#123;&#39;n_neighbors&#39;: 5&#125;, &#123;&#39;n_neighbors&#39;: 7&#125;, &#123;&#39;n_neighbors&#39;: 9&#125;, &#123;&#39;n_neighbors&#39;: 11&#125;], &#39;split0_test_score&#39;: array([1., 1., 1., 1., 1., 1.]), &#39;split1_test_score&#39;: array([0.91666667, 0.91666667, 1.        , 0.91666667, 0.91666667,       0.91666667]), &#39;split2_test_score&#39;: array([1., 1., 1., 1., 1., 1.]), &#39;split3_test_score&#39;: array([1.        , 1.        , 1.        , 1.        , 0.90909091,       1.        ]), &#39;split4_test_score&#39;: array([1., 1., 1., 1., 1., 1.]), &#39;split5_test_score&#39;: array([0.90909091, 0.90909091, 1.        , 1.        , 1.        ,       1.        ]), &#39;split6_test_score&#39;: array([1., 1., 1., 1., 1., 1.]), &#39;split7_test_score&#39;: array([0.90909091, 0.90909091, 0.90909091, 0.90909091, 1.        ,       1.        ]), &#39;split8_test_score&#39;: array([1., 1., 1., 1., 1., 1.]), &#39;split9_test_score&#39;: array([0.90909091, 0.81818182, 0.81818182, 0.81818182, 0.81818182,       0.81818182]), &#39;mean_test_score&#39;: array([0.96439394, 0.95530303, 0.97272727, 0.96439394, 0.96439394,       0.97348485]), &#39;std_test_score&#39;: array([0.04365767, 0.0604591 , 0.05821022, 0.05965639, 0.05965639,       0.05742104]), &#39;rank_test_score&#39;: array([5, 6, 2, 3, 3, 1])&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与不使用模型优化的KNN算法相对比，可以发现使用模型优化的KNN算法的结果更好。</p><h3 id="朴素贝叶斯算法"><a href="#朴素贝叶斯算法" class="headerlink" title="朴素贝叶斯算法"></a>朴素贝叶斯算法</h3><p>朴素贝叶斯算法多用于文本分类。</p><h4 id="API-5"><a href="#API-5" class="headerlink" title="API"></a>API</h4><ul><li>sklearn.naive_bayes.MultinomialNB(alpha = 1.0)<ul><li>朴素贝叶斯分类</li><li>alpha：拉普拉斯平滑系数</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;朴素贝叶斯算法应用场景：文本分类  单词作为特征优点：    对缺失数据不太敏感，算法也比较简单，常用于文本分类。    分类准确度高，速度快缺点：    由于使用了样本属性独立性的假设，所以如果特征属性有关联时其效果不好&quot;&quot;&quot;from sklearn.datasets import fetch_20newsgroups    # 获取数据集from sklearn.model_selection import train_test_split    # 数据集划分from sklearn.model_selection import GridSearchCV    # 模型优化from sklearn.naive_bayes import MultinomialNB    # 朴素贝叶斯from sklearn.feature_extraction.text import TfidfVectorizer    # 文本特征抽取def nb_news():    # 1. 获取数据    news &#x3D; fetch_20newsgroups(subset&#x3D;&quot;all&quot;)    # 2.划分数据集    x_train, x_test, y_train, y_test &#x3D; train_test_split(news.data, news.target)    transfer &#x3D; TfidfVectorizer()    # 标准化    x_train &#x3D; transfer.fit_transform(x_train)    x_test &#x3D; transfer.transform(x_test)    estimator &#x3D; MultinomialNB()    # 模型优化    param_dict &#x3D; &#123;&quot;alpha&quot;: [1, 3, 5, 7, 9, 11]&#125;    estimator &#x3D; GridSearchCV(estimator, param_grid&#x3D;param_dict, cv&#x3D;10)    estimator.fit(x_train, y_train)    # 5. 模型评估    # 方法1：直接比对真实值和预测值    y_predict &#x3D; estimator.predict(x_test)    print(&quot;y_predict:\n&quot;, y_predict)    print(&quot;直接比对真实值和预测值:\n&quot;, y_test &#x3D;&#x3D; y_predict)    # 方法2：计算准确率    score &#x3D; estimator.score(x_test, y_test)    print(&quot;准确率为：\n&quot;, score)    return Noneif __name__ &#x3D;&#x3D; &quot;__main__&quot;:    nb_news()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">y_predict: [ 9  4 17 ...  8  2  0]直接比对真实值和预测值: [ True  True  True ...  True  True  True]准确率为： 0.8548387096774194<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><h4 id="API-6"><a href="#API-6" class="headerlink" title="API"></a>API</h4><ul><li>class sklearn.tree.DecisionTreeClassifier(criterion=’gini’, max_depth=None,random_state=None)<ul><li>决策树分类器</li><li>criterion:默认是’gini’系数，也可以选择信息增益的熵’entropy’</li><li>max_depth:树的深度大小</li><li>random_state:随机数种子</li></ul></li><li>其中会有些超参数：max_depth:树的深度大小<ul><li>其它超参数我们会结合随机森林讲解</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">from sklearn.datasets import load_iris    # 数据集from sklearn.model_selection import train_test_split    # 数据集划分from sklearn.tree import DecisionTreeClassifier    # 决策树def decision_iris():    &quot;&quot;&quot;    用决策树对鸢尾花进行分类    优点：可视化 - 可解释能力强    缺点：如果数据很多还不设置树的深度这样可能会产生过拟合。    &quot;&quot;&quot;    # 1. 获取数据集    iris &#x3D; load_iris()    # 2. 划分数据集    x_train, x_test, y_train, y_test &#x3D; train_test_split(iris.data, iris.target)    # 3. 决策树预估器    # 参数max_depth:树的深度大小 如果数据集大则树的深度也大这样可能会导致准确率降低    # 所以如果有必要的话可以设置树的深度来提高准确率    estimator &#x3D; DecisionTreeClassifier(criterion&#x3D;&quot;entropy&quot;)    estimator.fit(x_train, y_train)    # 4. 模型评估    # 方法1：直接比对真实值和预测值    y_predict &#x3D; estimator.predict(x_test)    print(&quot;y_predict:\n&quot;, y_predict)    print(&quot;直接比对真实值和预测值:\n&quot;, y_test &#x3D;&#x3D; y_predict)    # 方法2：计算准确率    score &#x3D; estimator.score(x_test, y_test)    print(&quot;准确率为：\n&quot;, score)    return Noneif __name__ &#x3D;&#x3D; &quot;__main__&quot;:    decision_iris()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">y_predict: [0 2 1 0 1 0 0 0 2 1 2 1 2 2 1 1 1 0 0 1 2 2 0 0 2 1 0 2 1 2 1 0 1 1 0 1 1 1]直接比对真实值和预测值: [ True  True  True  True  True  True  True  True  True  True  True  True  True  True  True False  True  True  True False  True  True  True  True  True  True  True  True False False  True  True  True  True  True False  True  True]准确率为： 0.868421052631579<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><h4 id="随机森林原理过程"><a href="#随机森林原理过程" class="headerlink" title="随机森林原理过程"></a>随机森林原理过程</h4><p>学习算法根据下列算法而建造每棵树：</p><ul><li>用N来表示训练用例（样本）的个数，M表示特征数目。<ul><li>1、一次随机选出一个样本，重复N次， （有可能出现重复的样本）</li><li>2、随机去选出m个特征, m &lt;&lt;M，建立决策树</li></ul></li><li>采取bootstrap抽样</li></ul><h4 id="为什么采用BootStrap抽样"><a href="#为什么采用BootStrap抽样" class="headerlink" title="为什么采用BootStrap抽样"></a>为什么采用BootStrap抽样</h4><ul><li>为什么要随机抽样训练集？　　<ul><li>如果不进行随机抽样，每棵树的训练集都一样，那么最终训练出的树分类结果也是完全一样的</li></ul></li><li>为什么要有放回地抽样？<ul><li>如果不是有放回的抽样，那么每棵树的训练样本都是不同的，都是没有交集的，这样每棵树都是“有偏的”，都是绝对“片面的”（当然这样说可能不对），也就是说每棵树训练出来都是有很大的差异的；而随机森林最后分类取决于多棵树（弱分类器）的投票表决。</li></ul></li></ul><h4 id="API-7"><a href="#API-7" class="headerlink" title="API"></a>API</h4><ul><li><p>class sklearn.ensemble.RandomForestClassifier(n_estimators=10, criterion=’gini’, max_depth=None, bootstrap=True, random_state=None, min_samples_split=2)</p><ul><li>随机森林分类器</li><li>n_estimators：integer，optional（default = 10）森林里的树木数量120,200,300,500,800,1200</li><li>criteria：string，可选（default =“gini”）分割特征的测量方法</li><li>max_depth：integer或None，可选（默认=无）树的最大深度 5,8,15,25,30</li><li>max_features=”auto”,每个决策树的最大特征数量<ul><li>If “auto”, then <code>max_features=sqrt(n_features)</code>.</li><li>If “sqrt”, then <code>max_features=sqrt(n_features)</code> (same as “auto”).</li><li>If “log2”, then <code>max_features=log2(n_features)</code>.</li><li>If None, then <code>max_features=n_features</code>.</li></ul></li><li>bootstrap：boolean，optional（default = True）是否在构建树时使用放回抽样</li><li>min_samples_split:节点划分最少样本数</li><li>min_samples_leaf:叶子节点的最小样本数</li></ul></li><li><p>超参数：n_estimator, max_depth, min_samples_split,min_samples_leaf</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">from sklearn.datasets import load_iris    # 数据集from sklearn.model_selection import train_test_split    # 数据集划分from sklearn.ensemble import RandomForestClassifier    # 随机森林from sklearn.model_selection import GridSearchCV    # 模型优化def iris_demo():    # 加载数据集    iris &#x3D; load_iris()    # 数据集划分    x_train, x_test, y_train, y_test &#x3D; train_test_split(iris.data, iris.target)    # 随机森林    estimator &#x3D; RandomForestClassifier()    # 网格化搜索    param_dict &#x3D; &#123;&quot;n_estimators&quot;: [10, 20, 30, 40, 50, 100]&#125;    estimator &#x3D; GridSearchCV(estimator, param_grid&#x3D;param_dict, cv&#x3D;10)    # 训练    estimator.fit(x_train, y_train)    # 模型评估    # 方法1：直接比对真实值和预测值    y_predict &#x3D; estimator.predict(x_test)    print(&quot;y_predict:\n&quot;, y_predict)    print(&quot;直接比对真实值和预测值:\n&quot;, y_test &#x3D;&#x3D; y_predict)    # 方法2：计算准确率    score &#x3D; estimator.score(x_test, y_test)    print(&quot;准确率为：\n&quot;, score)    # 最佳参数：best_params_    print(&quot;最佳参数：\n&quot;, estimator.best_params_)    # 最佳结果：best_score_    print(&quot;最佳结果：\n&quot;, estimator.best_score_)    # 最佳估计器：best_estimator_    print(&quot;最佳估计器:\n&quot;, estimator.best_estimator_)    # 交叉验证结果：cv_results_    print(&quot;交叉验证结果:\n&quot;, estimator.cv_results_)    return Noneif __name__ &#x3D;&#x3D; &quot;__main__&quot;:    iris_demo()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">y_predict: [0 1 2 2 1 2 2 1 2 2 0 0 0 0 0 0 1 2 0 2 1 2 2 0 0 0 1 2 2 2 1 1 1 1 0 2 1 2]直接比对真实值和预测值: [ True  True  True  True  True  True  True  True  True  True  True  True    True  True  True  True  True  True  True  True  True  True  True  True     True  True  True  True  True  True False  True  True  True  True  True     True  True]准确率为： 0.9736842105263158最佳参数： &#123;&#39;n_estimators&#39;: 30&#125;最佳结果： 0.9553030303030303最佳估计器: RandomForestClassifier(n_estimators&#x3D;30)交叉验证结果: &#123;&#39;mean_fit_time&#39;: array([0.01545861, 0.0299505 , 0.04111712, 0.05707047, 0.06866693,       0.145067  ]), &#39;std_fit_time&#39;: array([0.00215007, 0.00540963, 0.00032881, 0.00359371, 0.00326092,       0.0084516 ]), &#39;mean_score_time&#39;: array([0.00159588, 0.0027936 , 0.00379615, 0.00488796, 0.00544808,       0.01146989]), &#39;std_score_time&#39;: array([0.00048815, 0.00040718, 0.00039285, 0.00054974, 0.00046851,       0.00091972]), &#39;param_n_estimators&#39;: masked_array(data&#x3D;[10, 20, 30, 40, 50, 100],             mask&#x3D;[False, False, False, False, False, False],       fill_value&#x3D;&#39;?&#39;,            dtype&#x3D;object), &#39;params&#39;: [&#123;&#39;n_estimators&#39;: 10&#125;, &#123;&#39;n_estimators&#39;: 20&#125;, &#123;&#39;n_estimators&#39;: 30&#125;, &#123;&#39;n_estimators&#39;: 40&#125;, &#123;&#39;n_estimators&#39;: 50&#125;, &#123;&#39;n_estimators&#39;: 100&#125;], &#39;split0_test_score&#39;: array([0.91666667, 0.91666667, 0.91666667, 0.91666667, 0.91666667,       0.91666667]), &#39;split1_test_score&#39;: array([1., 1., 1., 1., 1., 1.]), &#39;split2_test_score&#39;: array([0.90909091, 1.        , 1.        , 1.        , 1.        ,       1.        ]), &#39;split3_test_score&#39;: array([0.90909091, 0.90909091, 0.90909091, 0.90909091, 0.90909091,       0.90909091]), &#39;split4_test_score&#39;: array([0.81818182, 0.81818182, 0.81818182, 0.81818182, 0.81818182,       0.81818182]), &#39;split5_test_score&#39;: array([1., 1., 1., 1., 1., 1.]), &#39;split6_test_score&#39;: array([1., 1., 1., 1., 1., 1.]), &#39;split7_test_score&#39;: array([0.90909091, 0.90909091, 1.        , 0.90909091, 1.        ,       1.        ]), &#39;split8_test_score&#39;: array([1.        , 0.90909091, 1.        , 0.90909091, 1.        ,       1.        ]), &#39;split9_test_score&#39;: array([0.90909091, 0.90909091, 0.90909091, 0.90909091, 0.90909091,       0.90909091]), &#39;mean_test_score&#39;: array([0.93712121, 0.93712121, 0.95530303, 0.93712121, 0.95530303,       0.95530303]), &#39;std_test_score&#39;: array([0.05789881, 0.05789881, 0.0604591 , 0.05789881, 0.0604591 ,       0.0604591 ]), &#39;rank_test_score&#39;: array([4, 4, 1, 4, 1, 1])&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>在当前所有算法中，具有极好的准确率</li><li>能够有效地运行在大数据集上，处理具有高维特征的输入样本，而且不需要降维</li><li>能够评估各个特征在分类问题上的重要性</li></ul><h2 id="回归与聚类算法"><a href="#回归与聚类算法" class="headerlink" title="回归与聚类算法"></a>回归与聚类算法</h2><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><h4 id="线性回归API"><a href="#线性回归API" class="headerlink" title="线性回归API"></a>线性回归API</h4><ul><li>sklearn.linear_model.LinearRegression(fit_intercept=True)<ul><li>通过正规方程优化</li><li>fit_intercept：是否计算偏置</li><li>LinearRegression.coef_：回归系数</li><li>LinearRegression.intercept_：偏置</li></ul></li><li>sklearn.linear_model.SGDRegressor(loss=”squared_loss”, fit_intercept=True, learning_rate =’invscaling’, eta0=0.01)<ul><li>SGDRegressor类实现了随机梯度下降学习，它支持不同的<strong>loss函数和正则化惩罚项</strong>来拟合线性回归模型。</li><li>loss:损失类型<ul><li><strong>loss=”squared_loss”: 普通最小二乘法</strong></li></ul></li><li>fit_intercept：是否计算偏置</li><li>learning_rate : string, optional<ul><li>学习率填充</li><li><strong>‘constant’: eta = eta0</strong></li><li><strong>‘optimal’: eta = 1.0 / (alpha * (t + t0)) [default]</strong></li><li>‘invscaling’: eta = eta0 / pow(t, power_t)<ul><li><strong>power_t=0.25:存在父类当中</strong></li></ul></li><li><strong>对于一个常数值的学习率来说，可以使用learning_rate=’constant’ ，并使用eta0来指定学习率。</strong></li></ul></li><li>SGDRegressor.coef_：回归系数</li><li>SGDRegressor.intercept_：偏置</li></ul></li></ul><blockquote><p>sklearn提供给我们两种实现的API， 可以根据选择使用</p></blockquote><h4 id="回归性能评估"><a href="#回归性能评估" class="headerlink" title="回归性能评估"></a>回归性能评估</h4><p>sklearn.metrics.mean_squared_error(y_true, y_pred)</p><ul><li>均方误差回归损失</li><li>y_true:真实值</li><li>y_pred:预测值</li><li>return:浮点数结果</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">from sklearn.datasets import load_boston    # 加载数据集from sklearn.model_selection import train_test_split    # 数据集划分from sklearn.preprocessing import StandardScaler    # 特征工程 标准化from sklearn.linear_model import LinearRegression, SGDRegressor    # 正规方程 梯度下降from sklearn.metrics import mean_squared_error    # 回归评估 均方误差（值越小越好）def linear1():    &quot;&quot;&quot;    正规方程的优化方法对波士顿房价进行预测    &quot;&quot;&quot;    boston &#x3D; load_boston()    x_train, x_test, y_train, y_test &#x3D; train_test_split(        boston.data, boston.target, random_state&#x3D;22)    transfer &#x3D; StandardScaler()    x_train &#x3D; transfer.fit_transform(x_train)    x_test &#x3D; transfer.transform(x_test)    estimator &#x3D; LinearRegression()    estimator.fit(x_train, y_train)    print(&quot;正规方程-权重系数为：\n&quot;, estimator.coef_)    print(&quot;正规方程-偏置为：\n&quot;, estimator.intercept_)    y_predict &#x3D; estimator.predict(x_test)    print(&quot;正规方程-预测房价：\n&quot;, y_predict)    error &#x3D; mean_squared_error(y_test, y_predict)    print(&quot;正规方程-均方误差：\n&quot;, error)    return Nonedef linear2():    &quot;&quot;&quot;    梯度下降的优化方法对波士顿房价进行预测    &quot;&quot;&quot;    boston &#x3D; load_boston()    x_train, x_test, y_train, y_test &#x3D; train_test_split(        boston.data, boston.target, random_state&#x3D;22)    transfer &#x3D; StandardScaler()    x_train &#x3D; transfer.fit_transform(x_train)    x_test &#x3D; transfer.transform(x_test)    estimator &#x3D; SGDRegressor()    estimator.fit(x_train, y_train)    print(&quot;梯度下降-权重系数为：\n&quot;, estimator.coef_)    print(&quot;梯度下降-偏置为：\n&quot;, estimator.intercept_)    y_predict &#x3D; estimator.predict(x_test)    print(&quot;梯度下降-预测房价：\n&quot;, y_predict)    error &#x3D; mean_squared_error(y_test, y_predict)    print(&quot;梯度下降-均方误差：\n&quot;, error)    return Noneif __name__ &#x3D;&#x3D; &quot;__main__&quot;:    linear1()    linear2()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">正规方程-权重系数为： [-0.64817766  1.14673408 -0.05949444  0.74216553 -1.95515269  2.70902585 -0.07737374 -3.29889391  2.50267196 -1.85679269 -1.75044624  0.87341624  -3.91336869]正规方程-偏置为： 22.62137203166228正规方程-预测房价： [28.22944896 31.5122308  21.11612841 32.6663189  20.0023467  19.07315705 21.09772798 19.61400153 19.61907059 32.87611987 20.97911561 27.52898011  15.54701758 19.78630176 36.88641203 18.81202132  9.35912225 18.49452615  30.66499315 24.30184448 19.08220837 34.11391208 29.81386585 17.51775647  34.91026707 26.54967053 34.71035391 27.4268996  19.09095832 14.92742976  30.86877936 15.88271775 37.17548808  7.72101675 16.24074861 17.19211608   7.42140081 20.0098852  40.58481466 28.93190595 25.25404307 17.74970308  38.76446932  6.87996052 21.80450956 25.29110265 20.427491   20.4698034   17.25330064 26.12442519  8.48268143 27.50871869 30.58284841 16.56039764   9.38919181 35.54434377 32.29801978 21.81298945 17.60263689 22.0804256   23.49262401 24.10617033 20.1346492  38.5268066  24.58319594 19.78072415  13.93429891  6.75507808 42.03759064 21.9215625  16.91352899 22.58327744  40.76440704 21.3998946  36.89912238 27.19273661 20.97945544 20.37925063  25.3536439  22.18729123 31.13342301 20.39451125 23.99224334 31.54729547  26.74581308 20.90199941 29.08225233 21.98331503 26.29101202 20.17329401  25.49225305 24.09171045 19.90739221 16.35154974 15.25184758 18.40766132  24.83797801 16.61703662 20.89470344 26.70854061 20.7591883  17.88403312  24.28656105 23.37651493 21.64202047 36.81476219 15.86570054 21.42338732  32.81366203 33.74086414 20.61688336 26.88191023 22.65739323 17.35731771  21.67699248 21.65034728 27.66728556 25.04691687 23.73976625 14.6649641   15.17700342  3.81620663 29.18194848 20.68544417 22.32934783 28.01568563  28.58237108]正规方程-均方误差： 20.6275137630954梯度下降-权重系数为： [-0.52844184  0.94742828 -0.43896185  0.80011052 -1.70094588  2.83803954 -0.15173308 -3.15314827  1.64459185 -0.92057374 -1.72092516  0.85822999 -3.89079621]梯度下降-偏置为： [22.62848948]梯度下降-预测房价： [28.32292485 31.65691921 21.4754174  32.74532796 20.21502727 19.05803274 21.38012862 19.40598106 19.65928004 32.83684983 21.37788237 27.27547404 15.58434744 19.9543843  37.052139   18.66414622  9.64694632 18.60831548 30.78911441 24.28055663 19.04506654 34.16527664 29.53666782 17.39899068 34.86763757 26.51961514 34.42685759 27.38498522 19.1234001  15.69443705 30.90416755 14.4629764  37.60886681  8.70471496 16.38818819 16.8388242  7.70173349 19.7726613  40.59036302 29.18080616 25.25730687 17.82216674 39.37499484  6.67884528 21.54796917 25.04507005 20.88378703 20.64882236 17.03224546 26.32629603  9.6471961  27.18516688 30.67565735 16.69940767  9.58964556 35.55768574 31.59626177 22.93550937 17.57965025 21.83043993 23.62551177 23.94527301 20.3319314  38.24324246 25.72953353 19.68070738 14.15726975  6.66109511 42.53435973 21.82504626 16.74834226 22.55184196 41.01385643 21.71857114 36.98704919 27.16545173 21.83161702 20.78576019 25.30987444 23.77003724 31.53599899 20.19287298 24.00693276 31.56432429 27.2645538  20.86527222 29.1081147  21.95286144 26.74924411 18.76781794 25.26458575 24.01985914 19.93042174 17.68510263 15.50813547 18.27522698 24.59223379 16.73277678 20.66946955 26.79190915 20.72655782 17.97463708 24.13232421 23.25410362 20.27914227 36.64368885 15.98551815 22.46864296 32.71528599 33.73484378 20.54324486 25.9984172  23.32481418 17.74521574 21.46651544 21.79381137 27.55126895 25.28602934 23.65813339 14.43211265 15.64622064  3.64461024 29.25332792 20.65259117 22.31013756 28.06226938 28.3763949 ]梯度下降-均方误差： 21.168264510208296<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：均方误差越小表示效果越好。</p><h3 id="岭回归—线性回归的改进"><a href="#岭回归—线性回归的改进" class="headerlink" title="岭回归—线性回归的改进"></a>岭回归—线性回归的改进</h3><h4 id="API-8"><a href="#API-8" class="headerlink" title="API"></a>API</h4><p>sklearn.linear_model.Ridge(alpha=1.0, fit_intercept=True,solver=”auto”, normalize=False)</p><ul><li>具有l2正则化的线性回归</li><li>alpha:正则化力度，也叫 λ<ul><li><strong>λ取值：0<del>1 1</del>10</strong></li></ul></li><li>solver:会根据数据自动选择优化方法<ul><li><strong>sag:如果数据集、特征都比较大，选择该随机梯度下降优化</strong></li></ul></li><li>normalize:数据是否进行标准化<ul><li>normalize=False:可以在fit之前调用preprocessing.StandardScaler标准化数据</li></ul></li><li>Ridge.coef_:回归权重</li><li>Ridge.intercept_:回归偏置</li></ul><p><strong>Ridge方法相当于SGDRegressor(penalty=’l2’, loss=”squared_loss”),只不过SGDRegressor实现了一个普通的随机梯度下降学习，推荐使用Ridge(实现了SAG)</strong></p><ul><li>sklearn.linear_model.RidgeCV(_BaseRidgeCV, RegressorMixin)<ul><li>具有l2正则化的线性回归，可以进行交叉验证</li><li>coef_:回归系数</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">from sklearn.datasets import load_boston  # 加载数据集from sklearn.linear_model import Ridge  # 岭回归from sklearn.metrics import mean_squared_error  # 回归评估 均方误差（值越小越好）from sklearn.model_selection import train_test_split  # 数据集划分from sklearn.preprocessing import StandardScaler  # 特征工程 标准化def linear3():    # 加载数据集    boston &#x3D; load_boston()    # 数据集划分    x_train, x_test, y_train, y_test &#x3D; train_test_split(        boston.data, boston.target, random_state&#x3D;22)    # 数据集标准化    transfer &#x3D; StandardScaler()    x_train &#x3D; transfer.fit_transform(x_train)    x_test &#x3D; transfer.transform(x_test)    # 预估器    estimator &#x3D; Ridge()    estimator.fit(x_train, y_train)    # 得出模型    print(&quot;岭回归-权重系数为：\n&quot;, estimator.coef_)    print(&quot;岭回归-偏置为：\n&quot;, estimator.intercept_)    # 模型评估    y_predict &#x3D; estimator.predict(x_test)    print(&quot;岭回归-预测房价：\n&quot;, y_predict)    error &#x3D; mean_squared_error(y_test, y_predict)    print(&quot;岭回归-均方误差：\n&quot;, error)    return Noneif __name__ &#x3D;&#x3D; &quot;__main__&quot;:    linear3()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">岭回归-权重系数为： [-0.63591916  1.12109181 -0.09319611  0.74628129 -1.91888749  2.71927719 -0.08590464 -3.25882705  2.41315949 -1.76930347 -1.74279405  0.87205004  -3.89758657]岭回归-偏置为： 22.62137203166228岭回归-预测房价： [28.22119941 31.49858594 21.14690941 32.64962343 20.03976087 19.07187629 21.11827061 19.61935024 19.64669848 32.83666525 21.01034708 27.47939935 15.55875601 19.80406014 36.86415472 18.79442579  9.42343608 18.5205955 30.67129766 24.30659711 19.07820077 34.08772738 29.77396117 17.50394928 34.87750492 26.52508961 34.65566473 27.42939944 19.08639183 15.04854291 30.84974343 15.76894723 37.18814441  7.81864035 16.27847433 17.15510852  7.46590141 19.98474662 40.55565604 28.96103939 25.25570196 17.7598197 38.78171653  6.87935126 21.76805062 25.25888823 20.47319256 20.48808719 17.24949519 26.11755181  8.61005188 27.47070495 30.57806886 16.57080888  9.42312214 35.50731907 32.20467352 21.93128073 17.62011278 22.08454636 23.50121152 24.08248876 20.16840581 38.47001591 24.69276673 19.7638548 13.96547058  6.76070715 42.04033544 21.9237625  16.88030656 22.60637682 40.74664535 21.44631815 36.86936185 27.17135794 21.09470367 20.40689317 25.35934079 22.35676321 31.1513028  20.39303322 23.99948991 31.54251155 26.77734347 20.89368871 29.05880401 22.00850263 26.31965286 20.04852734 25.46476799 24.08084537 19.90846889 16.47030743 15.27936372 18.39475348 24.80822272 16.62280764 20.86393724 26.70418608 20.74534996 17.89544942 24.25949423 23.35743497 21.51817773 36.76202304 15.90293344 21.52915882 32.78684766 33.68666117 20.61700911 26.78345059 22.72685584 17.40478038 21.67136433 21.6912557  27.66684993 25.08825085 23.72539867 14.64260535 15.21105331  3.81916568 29.16662813 20.67913144 22.33386579 28.01241753 28.531445  ]岭回归-均方误差： 20.65644821435496<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="逻辑回归与二分类—分类算法"><a href="#逻辑回归与二分类—分类算法" class="headerlink" title="逻辑回归与二分类—分类算法"></a>逻辑回归与二分类—分类算法</h3><h4 id="逻辑回归API"><a href="#逻辑回归API" class="headerlink" title="逻辑回归API"></a>逻辑回归API</h4><ul><li>sklearn.linear_model.LogisticRegression(solver=’liblinear’, penalty=‘l2’, C = 1.0)<ul><li>solver:优化求解方式（默认开源的liblinear库实现，内部使用了坐标轴下降法来迭代优化损失函数）<ul><li>sag：根据数据集自动选择，随机平均梯度下降</li></ul></li><li>penalty：正则化的种类</li><li>C：正则化力度</li></ul></li></ul><blockquote><p><strong>默认将类别数量少的当做正例</strong></p></blockquote><p><strong>LogisticRegression方法相当于 SGDClassifier(loss=”log”, penalty=” “),SGDClassifier实现了一个普通的随机梯度下降学习，也支持平均随机梯度下降法（ASGD），可以通过设置average=True。而使用LogisticRegression(实现了SAG)</strong></p><h4 id="分类评估报告API"><a href="#分类评估报告API" class="headerlink" title="分类评估报告API"></a>分类评估报告API</h4><ul><li>sklearn.metrics.classification_report(y_true, y_pred, labels=[], target_names=None )</li><li><ul><li>y_true：真实目标值</li><li>y_pred：估计器预测目标值</li><li>labels:指定类别对应的数字</li><li>target_names：目标类别名称</li><li>return：每个类别精确率与召回率</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">import numpy as npimport pandas as pdfrom sklearn.linear_model import LogisticRegression  # 逻辑回归from sklearn.metrics import classification_report, roc_auc_score    # 分类评估from sklearn.model_selection import train_test_split  # 数据集划分from sklearn.preprocessing import StandardScaler  # 特征工程 标准化if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    # 加载数据    column_name &#x3D; [&#39;Sample code number&#39;, &#39;Clump Thickness&#39;,                   &#39;Uniformity of Cell Size&#39;, &#39;Uniformity of Cell Shape&#39;,                   &#39;Marginal Adhesion&#39;, &#39;Single Epithelial Cell Size&#39;,                   &#39;Bare Nuclei&#39;, &#39;Bland Chromatin&#39;,                   &#39;Normal Nucleoli&#39;, &#39;Mitoses&#39;, &#39;Class&#39;]    path &#x3D; r&quot;D:\痛苦の资料\不会真的有人学编程吧\机器学习\黑马程序员\自己的整理\day3\breast-cancer-wisconsin.data&quot;    data &#x3D; pd.read_csv(path, names&#x3D;column_name)    # 数据处理  因为数据中有缺失值，缺失的地方使用 ? 替代，目标是删掉缺失值    data &#x3D; data.replace(to_replace&#x3D;&#39;?&#39;, value&#x3D;np.nan)    data.dropna(inplace&#x3D;True)    # 数据处理  获取特征值和目标值    x &#x3D; data.iloc[:, 1:-1]    y &#x3D; data[&quot;Class&quot;]    # 数据集划分    x_train, x_test, y_train, y_test &#x3D; train_test_split(x, y)    # 数据标准化    transfer &#x3D; StandardScaler()    x_train &#x3D; transfer.fit_transform(x_train)    x_test &#x3D; transfer.transform(x_test)    # 预估器    estimator &#x3D; LogisticRegression()    estimator.fit(x_train, y_train)    # 模型    print(&quot;逻辑回归-权重系数为：\n&quot;, estimator.coef_)    print(&quot;逻辑回归-偏置为：\n&quot;, estimator.intercept_)    y_predict &#x3D; estimator.predict(x_test)    print(&quot;y_predict：\n&quot;, y_predict)    print(&quot;直接比对真实值和预测值：\n&quot;, y_test &#x3D;&#x3D; y_predict)    score &#x3D; estimator.score(x_test, y_test)    print(&quot;准确率：\n&quot;, score)    # 查看精确率、召回率、F1-score    report &#x3D; classification_report(y_test, y_predict, labels&#x3D;[                                   2, 4], target_names&#x3D;[&#39;良性&#39;, &#39;恶性&#39;])    # y_true:每个样本的真实类别，必须为0(反例),1(正例)标记    # 将y_test 转换成 0 1    y_true &#x3D; np.where(y_test &gt; 3, 1, 0)    print(roc_auc_score(y_true, y_predict))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">逻辑回归-权重系数为： [[1.51911637 0.06401522 0.69614721 0.76445915 0.50264081 1.37783828  1.13432057 0.6161716  0.85294448]]逻辑回归-偏置为： [-0.90973535]y_predict： [2 4 2 4 2 2 2 2 4 2 2 2 2 2 2 2 2 4 2 2 2 2 2 2 2 2 2 2 2 4 4 4 2 2 2 2 4 2 4 2 4 4 2 2 4 4 4 4 4 2 2 2 4 2 4 4 2 2 2 2 4 2 2 2 4 2 4 4 2 2 2 2 2 2 2 2 4 2 2 2 4 2 2 2 2 2 2 2 2 4 2 2 2 2 2 2 2 4 4 4 2 2 2 2 4 4 2 4 4 2 4 2 4 4 4 2 2 2 2 2 2 4 2 4 2 2 2 2 2 4 2 4 4 2 4 2 2 4 4 4 2 2 2 2 2 2 2 2 2 2 2 2 4 4 2 2 2 4 2 4 2 2 2 2 2 2 2 2 4 4 2]直接比对真实值和预测值： 137    True506    True578    True100    True600    True       ...426    True390    True336    True289    True444    TrueName: Class, Length: 171, dtype: bool准确率： 0.96491228070175440.9585488041370394<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="无监督学习—K-means算法"><a href="#无监督学习—K-means算法" class="headerlink" title="无监督学习—K-means算法"></a>无监督学习—K-means算法</h3><h4 id="K-meansAPI"><a href="#K-meansAPI" class="headerlink" title="K-meansAPI"></a>K-meansAPI</h4><ul><li>sklearn.cluster.KMeans(n_clusters=8,init=‘k-means++’)<ul><li>k-means聚类</li><li>n_clusters:开始的聚类中心数量</li><li>init:初始化方法，默认为’k-means ++’</li><li>labels_:默认标记的类型，可以和真实值比较（不是值比较）</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV颜色识别 物体追踪</title>
      <link href="posts/7.html"/>
      <url>posts/7.html</url>
      
        <content type="html"><![CDATA[<h1 id="OpenCV颜色识别-物体追踪"><a href="#OpenCV颜色识别-物体追踪" class="headerlink" title="OpenCV颜色识别 物体追踪"></a>OpenCV颜色识别 物体追踪</h1><a id="more"></a><p>对于颜色识别和<code>imutils</code>包的用法请浏览我得另一篇博客：<a href="https://lightningleader.github.io/posts/6.html">OpenCV学习笔记</a></p><h2 id="代码原理"><a href="#代码原理" class="headerlink" title="代码原理"></a>代码原理</h2><p>这是个比较简单的代码。代码实现的就是简单的物体追踪，将物体用方框框出。</p><p>简单来讲就是先进行颜色识别，正确识别到物体后获取物体的外接矩形再画出外接矩形即可。</p><p>详细的解释可以看代码注释，应该是容易理解的。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">import cv2import numpy as npimport imutilsfrom imutils import contours# 颜色阈值lower &#x3D; np.array([130, 62, 72])upper &#x3D; np.array([170, 255, 148])# 内核kernel &#x3D; np.ones((5, 5), np.uint8)# 打开摄像头vc &#x3D; cv2.VideoCapture(0)if vc.isOpened():    flag, frame &#x3D; vc.read()    # 翻转图像    # 这一步可以忽略，博主的摄像头是反着的    # 所以加上这句话可以让摄像头的图像正过来    frame &#x3D; imutils.rotate(frame, 180)    cv2.imshow(&quot;frame&quot;, frame)else:    flag &#x3D; Falsewhile flag:    flag, frame &#x3D; vc.read()    # 翻转图像    frame &#x3D; imutils.rotate(frame, 180)    draw_frame &#x3D; frame.copy()    if frame is None:        break    if flag is True:        &#39;&#39;&#39;下面对摄像头读取到的图像进行处理，这个步骤是比较重要的&#39;&#39;&#39;        # 转换颜色空间HSV        frame_hsv &#x3D; cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)        # 颜色识别        img &#x3D; cv2.inRange(frame_hsv, lower, upper)        # 膨胀操作        dilation &#x3D; cv2.dilate(img, kernel, iterations&#x3D;1)        # 闭操作        closing &#x3D; cv2.morphologyEx(dilation, cv2.MORPH_CLOSE, kernel)        # 高斯滤波        closing &#x3D; cv2.GaussianBlur(closing, (5, 5), 0)        # 边缘检测        edges &#x3D; cv2.Canny(closing, 10, 20)        &#39;&#39;&#39;上面进行那么多操作就是为了得到更好的目标图形，具体效果因环境而异&#39;&#39;&#39;        # 寻找轮廓        cnts, _ &#x3D; cv2.findContours(            edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)        # 判断轮廓数量也就是判断是否寻找到轮廓，如果没有找到轮廓就不继续进行操作        if len(cnts) &gt; 0:            # 存放轮廓面积的列表            s &#x3D; []            # 存放最大轮廓的索引            max_index &#x3D; 0            # 获得排序后的轮廓列表以及每个轮廓对应的外接矩形            (cnts, boundingRects) &#x3D; contours.sort_contours(cnts)            # 寻找面积最大的轮廓的索引            for cnt in cnts:                s.append(cv2.contourArea(cnt))            max_index &#x3D; s.index(max(s))            # 根据面积最大轮廓的索引找到它的外接矩形的信息            (x, y, w, h) &#x3D; boundingRects[max_index]            # 画矩形            frame_out &#x3D; cv2.rectangle(                         draw_frame, (x, y), (x+w, y+h), (0, 255, 0), 2)        cv2.imshow(&quot;frame&quot;, draw_frame)        if cv2.waitKey(10) &#x3D;&#x3D; 27:            breakvc.release()cv2.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体解释都在代码注释里面了，下面我要提一些注意的地方。</p><ol><li>获得过图像之后可能需要进行一系列的形态学操作，这样可以让获得的图像更加接近目的图像。这些操作虽然不是必需的但如果正常取得的图像效果不好的时候可以加上。</li><li>函数<code>contours.sort_contours</code> 和 <code>imutils.rotate</code>是<code>imutils</code>包里面的，使用起来比较方便，具体用法可以看博主的另一篇博客：<a href="https://lightningleader.github.io/posts/6.html">OpenCV学习笔记</a>。外接矩形也可以通过<code>cv2.boundingRect</code>函数获得。</li><li>代码中博主是以轮廓的最大面积为条件画的图，但这个条件应该根据自己想要的效果而定。这里除了寻找最大面积以外还可以寻找最大周长、最长的边之类的。</li></ol><h2 id="最终效果图"><a href="#最终效果图" class="headerlink" title="最终效果图"></a>最终效果图</h2><p><img src="/posts/7/1.jpg" alt="最终效果图"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV学习笔记</title>
      <link href="posts/6.html"/>
      <url>posts/6.html</url>
      
        <content type="html"><![CDATA[<h1 id="OpenCV学习笔记"><a href="#OpenCV学习笔记" class="headerlink" title="OpenCV学习笔记"></a>OpenCV学习笔记</h1><a id="more"></a><h2 id="图像翻转"><a href="#图像翻转" class="headerlink" title="图像翻转"></a>图像翻转</h2><p>使用Python的一个包，imutils。使用下面的指令可以安装。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pip install imutils<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>imutils包的Github地址：<a href="https://github.com/jrosebr1/imutils">https://github.com/jrosebr1/imutils</a></p><p>CSDN镜像：<a href="https://codechina.csdn.net/mirrors/jrosebr1/imutils">https://codechina.csdn.net/mirrors/jrosebr1/imutils</a></p><p>可以在上面这个地址里面学习更多的使用方式。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import cv2import imutils&#39;&#39;&#39;imutils.rotate第一个参数是翻转的图像，第二个参数的翻转角度函数还提供翻转中心的设置，但默认就是中心翻转。&#39;&#39;&#39;vc &#x3D; cv2.VideoCapture(0)if vc.isOpened():    flag, frame &#x3D; vc.read()    img &#x3D; imutils.rotate(frame, 180)    # 图像翻转     cv2.imshow(&quot;frame&quot;, img)else:    flag &#x3D; Falsewhile flag:    flag, frame &#x3D; vc.read()    if frame is None:        break    if flag is True:        img &#x3D; imutils.rotate(frame, 180)    # 图像翻转        cv2.imshow(&quot;frame&quot;, img)        if cv2.waitKey(10) &#x3D;&#x3D; 27:            breakvc.release()cv2.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样写的话，最后的输出图像就是翻转180度的。</p><p>imutils包里还有其他好用的函数，resizing、4-point Perspective Transform、Sorting Contours等等。</p><h2 id="图像轮廓排序"><a href="#图像轮廓排序" class="headerlink" title="图像轮廓排序"></a>图像轮廓排序</h2><p>这个效果同样也是依靠imutils包完成。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from imutils import contoursimport cv2&#39;&#39;&#39;contours.sort_contours可选排序方式：&quot;left-to-right&quot;, &quot;right-to-left&quot;, &quot;top-to-bottom&quot;, &quot;bottom-to-top&quot;返回值为轮廓和外接矩形contours.label_contourcontours包内自带的画轮廓的函数，可以直接用，然后可以在图片上标出轮廓序号也可以直接使用cv2.drawContours直接画轮廓&#39;&#39;&#39;img &#x3D; cv2.imread(r&quot;D:\opencv-workspace\Opencv\test17--VScode\shapes.png&quot;)draw_img &#x3D; img.copy()img_rect &#x3D; img.copy()gray &#x3D; cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)img &#x3D; cv2.Canny(gray, 10, 20)    # Canny边缘检测cnts, hierarchy &#x3D; cv2.findContours(img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)    # 获得轮廓(cnts, boundingBoxes) &#x3D; contours.sort_contours(cnts, &quot;top-to-bottom&quot;)    # 对轮廓进行排序处理for (i, c) in enumerate(cnts):    sortedImage &#x3D; contours.label_contour(draw_img, c, i, color&#x3D;(240, 0, 159))# img_out &#x3D; cv2.drawContours(draw_img, cnts, -1, (240, 0, 159), 2)# 根据boundingBoxes画外接矩形for (x, y, w, h) in boundingBoxes:    img_rect &#x3D; cv2.rectangle(img_rect, (x, y), (x+w, y+h), (240, 0, 159), 2)cv2.imshow(&quot;top-to-bottom&quot;, sortedImage)cv2.imshow(&quot;rect&quot;, img_rect)cv2.waitKey(0)cv2.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/6/1.jpg" alt="处理效果"></p><h2 id="颜色识别"><a href="#颜色识别" class="headerlink" title="颜色识别"></a>颜色识别</h2><h3 id="基础颜色识别"><a href="#基础颜色识别" class="headerlink" title="基础颜色识别"></a>基础颜色识别</h3><p>颜色识别是在HSV空间内进行的，因此在使用之前先进行颜色空间的转换。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;使用下面这个函数进行转换，第一个参数填写要转换的图片，第二个参数填写cv2.COLOR_BGR2HSV&#39;&#39;&#39;cv2.cvtColor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">import cv2import numpy as np&#39;&#39;&#39;cv2.inRange函数很简单，参数有三个第一个参数：hsv指的是原图第二个参数：lower_red指的是图像中低于这个lower_red的值，图像值变为0第三个参数：upper_red指的是图像中高于这个upper_red的值，图像值变为0而在lower_red～upper_red之间的值变成255&#39;&#39;&#39;# 阈值lower_green &#x3D; np.array([50, 255, 255])upper_green &#x3D; np.array([70, 255, 255])img &#x3D; cv2.imread(r&quot;D:\opencv-workspace\Opencv\test16--VScode\photo.jpg&quot;)img_hsv &#x3D; cv2.cvtColor(img, cv2.COLOR_BGR2HSV)mask_green &#x3D; cv2.inRange(img_hsv, lower_green, upper_green)cv2.imshow(&quot;img_or&quot;, mask_green)# 使用下面这个函数能显示原来的颜色。res_green &#x3D; cv2.bitwise_and(img, img, mask&#x3D;mask_green)cv2.imshow(&quot;img&quot;, res_green)cv2.waitKey(0)cv2.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/6/2.jpg" alt="原图"></p><p><img src="/posts/6/4.jpg" alt="mask_green"></p><p><img src="/posts/6/3.jpg" alt="res_green"></p><p>在进行颜色识别时，难免会出现“漏颜色”的现象，也就是会出现没识别全的现象。这个时候可以再对图像进行处理，比如说进行形态学处理，让图像更加饱满之类的。</p><h3 id="根据BGR获取HSV"><a href="#根据BGR获取HSV" class="headerlink" title="根据BGR获取HSV"></a>根据BGR获取HSV</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">import cv2color &#x3D; np.uint8([[[193, 189, 147]]])    # 参数填写BGR的值hsv &#x3D; cv2.cvtColor(color, cv2.COLOR_BGR2HSV)print(hsv)    # 打印出来的数值就是对应的HSV值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序运行的结果是</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">[[[ 93  61 193]]]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个就是对应的HSV的值。</p><p>根据之前写的颜色识别，就需要把对应的阈值写出。具体写法就是<strong>保持S和V不变，H加减10。</strong>这样的话就可以写出高低阈值然后应用到颜色识别里面就可以了。</p><h3 id="阈值编辑器"><a href="#阈值编辑器" class="headerlink" title="阈值编辑器"></a>阈值编辑器</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">import cv2import numpy as npdef function(x):    lowH &#x3D; cv2.getTrackbarPos(&quot;lowH&quot;, &quot;img_666&quot;)    lowS &#x3D; cv2.getTrackbarPos(&quot;lowS&quot;, &quot;img_666&quot;)    lowV &#x3D; cv2.getTrackbarPos(&quot;lowV&quot;, &quot;img_666&quot;)    HighH &#x3D; cv2.getTrackbarPos(&quot;HighH&quot;, &quot;img_666&quot;)    HighS &#x3D; cv2.getTrackbarPos(&quot;HighS&quot;, &quot;img_666&quot;)    HighV &#x3D; cv2.getTrackbarPos(&quot;HighV&quot;, &quot;img_666&quot;)    # print(lowH, lowS, lowV, HighH, HighS, HighV)    lower &#x3D; np.uint8([lowH, lowS, lowV])    upper &#x3D; np.uint8([HighH, HighS, HighV])    mask &#x3D; cv2.inRange(img_hsv, lower, upper)    res &#x3D; cv2.bitwise_and(img, img, mask&#x3D;mask)    cv2.imshow(&quot;img&quot;, res)img &#x3D; cv2.imread(r&quot;D:\opencv-workspace\Opencv\test16--VScode\test.jpg&quot;)img_hsv &#x3D; cv2.cvtColor(img, cv2.COLOR_BGR2HSV)cv2.namedWindow(&quot;img_666&quot;)cv2.createTrackbar(&quot;lowH&quot;, &quot;img_666&quot;, 0, 179, function)cv2.createTrackbar(&quot;lowS&quot;, &quot;img_666&quot;, 0, 255, function)cv2.createTrackbar(&quot;lowV&quot;, &quot;img_666&quot;, 0, 255, function)cv2.createTrackbar(&quot;HighH&quot;, &quot;img_666&quot;, 0, 179, function)cv2.createTrackbar(&quot;HighS&quot;, &quot;img_666&quot;, 0, 255, function)cv2.createTrackbar(&quot;HighV&quot;, &quot;img_666&quot;, 0, 255, function)cv2.imshow(&quot;img&quot;, img)cv2.waitKey(0)cv2.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>写了一个比较垃圾的阈值编辑器。。。就不多解释了。。</p><p><img src="/posts/6/5.jpg" alt="阈值编辑器"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派串口通信 USB串口通信</title>
      <link href="posts/5.html"/>
      <url>posts/5.html</url>
      
        <content type="html"><![CDATA[<h1 id="树莓派串口通信-USB串口通信"><a href="#树莓派串口通信-USB串口通信" class="headerlink" title="树莓派串口通信 USB串口通信"></a>树莓派串口通信 USB串口通信</h1><a id="more"></a><p>如果不知道树莓派怎么使用USB串口通信的，欢迎浏览我的另一篇博客文章：<a href="https://lightningleader.github.io/posts/4.html">树莓派使用USB串口通信 CH340</a></p><p>这篇文章就以USB串口为例，简单的说下串口通信时常用的几个命令。注意：代码均为Python编写。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>树莓派4</li><li>两个CH340</li><li>串口助手</li></ul><h2 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h2><ol><li><p>最基础的发送数据方式</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;ser.write(data)    # 发送数据data，data为字节型&#39;&#39;&#39;import serialser &#x3D; serial.Serial(&quot;&#x2F;dev&#x2F;ttyUSB0&quot;, 115200)ser.flushInput()    # 清除缓存ser.write(&quot;LightningMaster\r\n&quot;.encode())    # 发送数据  \r\n可以实现换行  encode()默认是&#39;utf-8&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行这个代码就可以在串口助手上收到数据。</p><p><img src="/posts/5/1.jpg" alt="最基础发送数据"></p></li><li><p>发送中文</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import serialser &#x3D; serial.Serial(&quot;&#x2F;dev&#x2F;ttyUSB0&quot;, 115200)ser.flushInput()    # 清除缓存ser.write(&quot;闪电丶教主\r\n&quot;.encode(&#39;gb2312&#39;))    # 发送数据  \r\n可以实现换行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/5/2.jpg" alt="发送中文"></p></li><li><p>发送数据包 十六进制</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import serialimport structser &#x3D; serial.Serial(&quot;&#x2F;dev&#x2F;ttyUSB0&quot;, 115200)ser.flushInput()    # 清除缓存pack &#x3D; struct.pack(&#39;BBBB&#39;, 0xaa, 6, 7, 0x55)    # 将数据打包 格式是unsigned charser.write(pack)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/5/3.jpg" alt="发送数据包"></p><p>这个地方使用到了struct.pack，具体有啥作用可以自行百度去看看，我在这就不多说了。这里的作用就是将数据打包，返回格式是unsigned char 的字节串。</p><p>可以使用这个函数给数据加上“头”“尾”之类的东西。</p></li></ol><h2 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;ser.read(num)    # 读取收到的num个字节的数据ser.inWaiting()    # 可以获取还未读出的数据&#39;&#39;&#39;import serialimport structimport timeser &#x3D; serial.Serial(&quot;&#x2F;dev&#x2F;ttyUSB0&quot;, 115200)ser.flushInput()    # 清除缓存while True:    count &#x3D; ser.inWaiting()    # 获取还有多少字符未读    if count !&#x3D; 0:        data &#x3D; ser.read(count)    # 读取数据存到data中        print(data)    # 打印接受到的数据    time.sleep(0.1)    # 系统等待<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行代码，使用串口助手发送数据，可以在树莓派中看到返回值。</p><p><img src="/posts/5/4.jpg" alt="接收数据"></p><p>可以看到树莓派成功接收到了数据。</p><p>如果想把b’ ‘去掉可以使用代码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(data.decode(&#39;utf-8&#39;))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/5/5.jpg" alt="去掉b&#39;&#39;"></p><p>接收中文的话需要使用下面的代码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(data.decode(&#39;gb2312&#39;))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/5/6.jpg" alt="接收中文"></p><p>具体为什么使用encode和decode，可以自行查阅Python相关资料。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派使用USB串口通信 CH340</title>
      <link href="posts/4.html"/>
      <url>posts/4.html</url>
      
        <content type="html"><![CDATA[<h1 id="树莓派使用USB串口通信-CH340"><a href="#树莓派使用USB串口通信-CH340" class="headerlink" title="树莓派使用USB串口通信 CH340"></a>树莓派使用USB串口通信 CH340</h1><a id="more"></a><p>因为需要使用树莓派做自控方向的东西，所以需要使用树莓派串口与各种外设进行通信。使用串口的话个人比较喜欢直接使用USB串口，用起来比较方便。下面就介绍一下怎么使用树莓派的USB串口通信。</p><p>对于不会使用串口通信的hxd可以康康我的这篇文章，里面详细讲解了常用的串口通信的命令：<a href="https://lightningleader.github.io/posts/5.html">树莓派串口通信 USB串口通信</a></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>树莓派4</li><li>CH340</li><li>串口助手</li></ul><h2 id="树莓派正确识别CH340"><a href="#树莓派正确识别CH340" class="headerlink" title="树莓派正确识别CH340"></a>树莓派正确识别CH340</h2><p>首先正常开启树莓派，不要插入CH340，然后进入树莓派桌面，打开命令行，输入命令lsusb，可以查看本机的USB设备列表，以及USB设备的详细信息。</p><p><img src="/posts/4/1.jpg" alt="输入命令lsusb"></p><p>正常的话，就会像上图那样。</p><p>然后插入CH340，再次运行lsusb命令，这个时候应该会出现下面这个界面。</p><p><img src="/posts/4/2.jpg" alt="再次输入命令lsusb"></p><p>从上图可以明显看出多了一个设备，后面的设备详情也明确表示这个是CH340，这就表明树莓派正确识别到了插入的CH340。</p><p>接着在命令行输入命令 ls -l /dev/tty* </p><p><img src="/posts/4/3.jpg" alt="USB"></p><p>如上图所示，不出意外的话最后一个就是你插入的ch340，然后就记住这个黄色字体即/dev/ttyUSB0。这里的USB0也可能是USB1，这个是不确定的。</p><p>到了这里就代表你的树莓派可以正常识别CH34，下面就是写代码来验证效果了。</p><h2 id="代码实现通信"><a href="#代码实现通信" class="headerlink" title="代码实现通信"></a>代码实现通信</h2><p>这里我的代码是Python的。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import serialser &#x3D; serial.Serial(&quot;&#x2F;dev&#x2F;ttyUSB0&quot;, 115200)    # 第一个参数就是上面那个黄色字体  第二个参数填波特率ser.flushInput()    # 清除缓存ser.write(&quot;LightningMaster\r\n&quot;.encode())   # 发送<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：这个教程是默认树莓派已经进行了串口配置的。比如说安装pyserial包，如果没安装的话，可以使用下面的命令进行安装</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pip3 install pyserial<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为了测试，我使用两个CH340，一个连接树莓派另一个连接电脑，这样就可以直接在电脑上通过串口助手看到发送的数据了。</p><p>运行代码后就可以在串口助手上看到树莓派发送的数据了。</p><p><img src="/posts/4/4.jpg" alt="串口助手"></p><p>这样就可以正常使用USB串口进行通信了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循迹智能小车 循黑线</title>
      <link href="posts/3.html"/>
      <url>posts/3.html</url>
      
        <content type="html"><![CDATA[<h1 id="循迹智能小车-循黑线"><a href="#循迹智能小车-循黑线" class="headerlink" title="循迹智能小车 循黑线"></a>循迹智能小车 循黑线</h1><a id="more"></a><h2 id="硬件菜单"><a href="#硬件菜单" class="headerlink" title="硬件菜单"></a>硬件菜单</h2><ul><li><p>单片机型号：STC16F40K128</p></li><li><p>4路红外循迹模块</p></li><li><p>小车底盘套件（一个底盘、两个TT马达、两个轮胎）</p></li><li><p>12V航模电池</p></li><li><p>降压模块</p></li><li><p>A4950双路电机驱动</p></li><li><p>杜邦线等</p></li></ul><h2 id="硬件使用"><a href="#硬件使用" class="headerlink" title="硬件使用"></a>硬件使用</h2><p><img src="/posts/3/1.png" alt="4路红外循迹模块"></p><ul><li>关于4路红外循迹模块的使用教程，我之前写过一篇博客，里面有详细的介绍。如果有不会的可以先去浏览学习一下。<a href="https://lightningleader.github.io/posts/2.html">跳转至教程</a></li><li>A4950双路电机驱动使用方式不多说了，比较简单。大部分人应该都是用L298N的。</li></ul><h2 id="硬件组装"><a href="#硬件组装" class="headerlink" title="硬件组装"></a>硬件组装</h2><p><img src="/posts/3/2.jpg" alt="循迹小车1"></p><p><img src="/posts/3/3.jpg" alt="循迹小车2"></p><p>硬件组装大概按照上面两张图片组装就行。  </p><ul><li>不过要注意的是红外传感器之间的距离和单个传感器的测量精度。在组装完成后，要通电试一试传感器的工作情况，用它检测黑线，康康是不是能够正常工作。如果无法正常工作需要及时调整传感器的精度或者其他东西。总之要保证传感器能正常检测黑线。</li><li>另一点就是传感器的安装位置。受到传感器数量的限制，所以传感器的安装位置需要仔细考虑。我这里一共有4个传感器所以就像图中那样安装的。中间两个之间留有空隙，空隙的宽度大概为黑线宽度（可以稍微比黑线宽点），其他两个的位置也不要离得太远。具体为什么这样设计再后面讲解。</li></ul><h2 id="程序设计前的理解"><a href="#程序设计前的理解" class="headerlink" title="程序设计前的理解"></a>程序设计前的理解</h2><ul><li>接上面挖下的坑，说一下中间两个传感器之间空隙的问题。</li></ul><p>前提是小车在没有检测到黑线的时候会直线行驶。中间的空隙宽度略微大于黑线宽度，这样就可以满足当黑线处于这个缝隙间的时候传感器不会有反应，小车会直线行驶，在一定程度上满足循线的基础操作。肯定会出现黑线移出这个空隙的情况，这样的话黑线就会被两侧的传感器检测到，然后由单片机做出应对。如果是左侧的传感器检测到黑线（设定小车前进方向为正方向），代表车头右偏了，因此小车需要左转；于此类似，右侧的传感器也是一个道理。理解了这些就可以完成最基本的循线了。</p><ul><li>最外侧两个传感器的作用  </li></ul><p>因为传感器反应速度等等一系列可能的原因会出现黑线在移出中央空隙的时间很短导致传感器没有检测到等的情况，这样的话小车肯定会继续前进而导致无法继续循线。如果在中间两个传感器两侧又安装了两个传感器的话，这样就相当于多了一个保险，如果中间两个没有检测到的话，最外侧的传感器正常工作仍能让小车重新回到循线轨迹上来。不过要注意的是，因为当最外侧的传感器检测到黑线时就意味着车头已经偏的比较严重了，所以要想让车头偏正就需要给更大的“力”，也就是给更大的PWM。</p><h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;headfile.h&quot;&#x2F;******************** 用于初始化PWM的*******************&#x2F;void All_Init(void)&#123;pwm_init(PWMA_CH1P_P60, 10000, 0);pwm_init(PWMA_CH2P_P62, 10000, 0);pwm_init(PWMA_CH3P_P64, 10000, 0);pwm_init(PWMA_CH4P_P66, 10000, 0);&#125;&#x2F;******************** 车子左转*******************&#x2F;void turn_left(int duty)&#123;pwm_duty(PWMA_CH1P_P60, duty);pwm_duty(PWMA_CH2P_P62, 0);pwm_duty(PWMA_CH3P_P64, 0);pwm_duty(PWMA_CH4P_P66, duty);&#125;&#x2F;******************** 车子右转*******************&#x2F;void turn_right(int duty)&#123;pwm_duty(PWMA_CH1P_P60, 0);pwm_duty(PWMA_CH2P_P62, duty);pwm_duty(PWMA_CH3P_P64, duty);pwm_duty(PWMA_CH4P_P66, 0);&#125;&#x2F;******************** 车子直行*******************&#x2F;void go_straight(void)&#123;pwm_duty(PWMA_CH1P_P60, 7000);pwm_duty(PWMA_CH2P_P62, 0);pwm_duty(PWMA_CH3P_P64, 7000);pwm_duty(PWMA_CH4P_P66, 0);&#125;&#x2F;******************** 车子停止*******************&#x2F;void go_stop(void)&#123;pwm_duty(PWMA_CH1P_P60, 0);pwm_duty(PWMA_CH2P_P62, 0);pwm_duty(PWMA_CH3P_P64, 0);pwm_duty(PWMA_CH4P_P66, 0);&#125;&#x2F;****************************************** OUT1 P27* OUT2 P26* OUT3 P25* OUT4 P24* 如图循迹小车2所示，从左到右分别为OUT1、2、3、4* 检测到黑线或悬空LED灭，输出高电平* 对单片机的IO口状态进行判断，这样可以得到是哪个* 传感器检测到了黑线，然后再* 做出相对应的行为。*****************************************&#x2F;void scan(void)&#123;if ((P26 &#x3D;&#x3D; 0)&amp;&amp;(P25 &#x3D;&#x3D; 0)&amp;&amp;(P27 &#x3D;&#x3D; 0)&amp;&amp;(P24 &#x3D;&#x3D; 0))&#123;&#x2F;&#x2F; 未检测到黑线go_straight();&#125;else if ((P26 &#x3D;&#x3D; 1)&amp;&amp;(P25 &#x3D;&#x3D; 1)&amp;&amp;(P27 &#x3D;&#x3D; 1)&amp;&amp;(P24 &#x3D;&#x3D; 1))&#123;&#x2F;&#x2F; 悬空go_stop();&#125;else if ((P26 &#x3D;&#x3D; 0)&amp;&amp;(P25 &#x3D;&#x3D; 1)&amp;&amp;(P27 &#x3D;&#x3D; 0)&amp;&amp;(P24 &#x3D;&#x3D; 0))&#123;&#x2F;&#x2F; 车头右偏（相对于前进方向） 向左转（幅度较小）turn_left(7000);&#125;else if ((P26 &#x3D;&#x3D; 1)&amp;&amp;(P25 &#x3D;&#x3D; 0)&amp;&amp;(P27 &#x3D;&#x3D; 0)&amp;&amp;(P24 &#x3D;&#x3D; 0))&#123;&#x2F;&#x2F; 车头左偏 向右转（幅度较小）turn_right(7000);&#125;else if ((P26 &#x3D;&#x3D; 0)&amp;&amp;(P25 &#x3D;&#x3D; 0)&amp;&amp;(P27 &#x3D;&#x3D; 1)&amp;&amp;(P24 &#x3D;&#x3D; 0))&#123;&#x2F;&#x2F; 向左转（幅度较大）turn_left(9500);&#125;else if ((P26 &#x3D;&#x3D; 0)&amp;&amp;(P25 &#x3D;&#x3D; 0)&amp;&amp;(P27 &#x3D;&#x3D; 0)&amp;&amp;(P24 &#x3D;&#x3D; 1))&#123;&#x2F;&#x2F; 向右转（幅度较大）turn_right(9500);&#125;&#125;void main()&#123;DisableGlobalIRQ();&#x2F;&#x2F;关闭总中断board_init();&#x2F;&#x2F;初始化寄存器All_Init();&#x2F;&#x2F;总中断最后开启EnableGlobalIRQ();&#x2F;&#x2F;开启总中断    while(1)&#123;scan();  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序代码大概就像上面那样。其中有些参数，比如说小车行进速度和转弯占空比该给多少。这个东西需要自己测试然后填写，也就是自己慢慢调参测试，找到合适的数值就行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4路红外循迹模块使用教程</title>
      <link href="posts/2.html"/>
      <url>posts/2.html</url>
      
        <content type="html"><![CDATA[<h1 id="4路红外循迹模块使用教程"><a href="#4路红外循迹模块使用教程" class="headerlink" title="4路红外循迹模块使用教程"></a>4路红外循迹模块使用教程</h1><a id="more"></a><h2 id="模块详细信息："><a href="#模块详细信息：" class="headerlink" title="模块详细信息："></a>模块详细信息：</h2><p>工作电压：DC 3.3V~5V</p><p>工作电流：尽量选择1A以上电源供电</p><p>工作温度：-10℃~+50℃</p><p>安装孔径：M3螺丝</p><p>检测距离：1mm~30cm可调，距离越近2性能越稳定，白色反射距离远</p><p>尺寸大小：中控板42mmX38mmX12mm（长X宽X高）；小板向前25mmX12mmX12mm（长X宽X高）</p><p>输出接口：6线制接口（1、2、3、4为4路信号输出端，VCC接正电源，GND接GND）</p><p>输出信号：TTL电平，可直接连接单片机IO口，感应到传感器反射回来的红外光时，红指示灯亮，输出低电平；没有红外光时，指示灯不亮，输出高电平。</p><h2 id="模块接线"><a href="#模块接线" class="headerlink" title="模块接线"></a>模块接线</h2><p><img src="/posts/2/1.png" alt="4路红外循迹模块"></p><p>图中主控板左侧分别为，VCC、GND、OUT1、OUT2、OUT3、OUT4，其中OUT1、2、3、4分别连接单片机的IO口，用于检测输出电平。主控板右侧分别与四个小板连接，用于采集信息。</p><h2 id="模块使用"><a href="#模块使用" class="headerlink" title="模块使用"></a>模块使用</h2><p>模块正确连接并通电后，小板传感器开始工作。模块感应到传感器反射回来的红外光时，红指示灯亮，输出低电平；没有红外光时，指示灯不亮，输出高电平。以检测黑线为例，如果传感器检测到黑线，红外光无法反射回来则模块红指示灯熄灭，同时小板对应的OUT口输出高电平；如果未检测到黑线，红外光可以反射回来则模块红指示灯亮，小板对应的OUT口输出低电平。其中需要注意一种特殊情况，也就是说当测量物体超出测量范围时，此时红指示灯熄灭，OUT口输出高电平。</p><p>每个小板前面对应的电位器可以用来调整使用精度。</p><h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>代码使用的单片机型号：STC16F40K128</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &quot;headfile.h&quot;&#x2F;** OUT1 P27* OUT2 P26* OUT3 P25* OUT4 P24* 检测到黑线或悬空LED灭，输出高电平*&#x2F; int main() &#123;DisableGlobalIRQ();&#x2F;&#x2F;关闭总中断board_init();&#x2F;&#x2F;初始化寄存器&#x2F;&#x2F;总中断最后开启EnableGlobalIRQ();&#x2F;&#x2F;开启总中断    while(1)&#123;        &#x2F;&#x2F; 判断IO口电平状态if (P27 &#x3D;&#x3D; 1)        &#123;printf(&quot;OUT1 NO\r\n&quot;);&#125;if (P26 &#x3D;&#x3D; 1)&#123;printf(&quot;OUT2 NO\r\n&quot;);&#125;if (P25 &#x3D;&#x3D; 1)&#123;printf(&quot;OUT3 NO\r\n&quot;);&#125;if (P24 &#x3D;&#x3D; 1)&#123;printf(&quot;OUT4 NO\r\n&quot;);&#125;if ((P27 &#x3D;&#x3D; 0)&amp;&amp;(P26 &#x3D;&#x3D; 0)&amp;&amp;(P25 &#x3D;&#x3D; 0)&amp;&amp;(P24 &#x3D;&#x3D; 0))&#123;printf(&quot;OFF\r\n&quot;);&#125;  &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码是比较简单的，就是判断单片机IO口状态。如果IO口是高电平则表示传感器检测到黑线，否则没有检测到黑线。理解了这个原理就可以在其他型号的单片机上使用这个模块。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 硬件使用 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown学习笔记</title>
      <link href="posts/1.html"/>
      <url>posts/1.html</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown学习笔记"><a href="#Markdown学习笔记" class="headerlink" title="Markdown学习笔记"></a>Markdown学习笔记</h1><a id="more"></a><h2 id="1、代码块"><a href="#1、代码块" class="headerlink" title="1、代码块"></a>1、代码块</h2><p><strong>代码块语法：</strong></p><p>“ ``` ” 三个这个号（ESC下面的）加上想写的语言，就可以生成代码块区域</p><h2 id="2、标题"><a href="#2、标题" class="headerlink" title="2、标题"></a>2、标题</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="3、字体"><a href="#3、字体" class="headerlink" title="3、字体"></a>3、字体</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 加粗**闪电丶教主**# 代码高亮显示&#x3D;&#x3D;闪电丶教主&#x3D;&#x3D;# 删除线~~闪电丶教主~~# 斜体*闪电丶教主*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><p><strong>闪电丶教主</strong></p><h3 id="代码高亮显示"><a href="#代码高亮显示" class="headerlink" title="代码高亮显示"></a>代码高亮显示</h3><p><code>闪电丶教主</code></p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p><del>闪电丶教主</del></p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p><em>闪电丶教主</em></p><h2 id="4、引用"><a href="#4、引用" class="headerlink" title="4、引用"></a>4、引用</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 引用语法&gt;作者：闪电丶教主&gt;&gt;作者：闪电丶教主&gt;&gt;&gt;作者：闪电丶教主<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>作者：闪电丶教主</p><blockquote><p>作者：闪电丶教主</p></blockquote><blockquote><blockquote><p>作者：闪电丶教主</p></blockquote></blockquote></blockquote><h2 id="5、分割线"><a href="#5、分割线" class="headerlink" title="5、分割线"></a>5、分割线</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 分割线 比较常用---# 分割线2***<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><hr><h2 id="6、图片插入"><a href="#6、图片插入" class="headerlink" title="6、图片插入"></a>6、图片插入</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 在线图片 # 本地图片![图片名称](图片路径)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/posts/1/666.png" alt="测试图片"></p><p><img src="/posts/1/%E5%B0%8F%E6%81%B6%E9%AD%94.png" alt="就这¿"></p><h2 id="7、超链接"><a href="#7、超链接" class="headerlink" title="7、超链接"></a>7、超链接</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 超链接[名称](地址)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="8、列表语法"><a href="#8、列表语法" class="headerlink" title="8、列表语法"></a>8、列表语法</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 无序列表- 目录1- 目录2- 目录3# 1+. +名称1. 闪电丶教主<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>目录1</li><li>目录2</li><li>目录3</li></ul><ol><li>闪电丶教主</li></ol><h2 id="9、表格"><a href="#9、表格" class="headerlink" title="9、表格"></a>9、表格</h2><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>6</td><td>6</td><td>6</td></tr><tr><td>6</td><td>6</td><td>6</td></tr><tr><td>6</td><td>6</td><td>6</td></tr></tbody></table><p>ctrl+/ 查看源代码</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
