<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OpenCV学习笔记</title>
      <link href="posts/6.html"/>
      <url>posts/6.html</url>
      
        <content type="html"><![CDATA[<h1 id="OpenCV学习笔记"><a href="#OpenCV学习笔记" class="headerlink" title="OpenCV学习笔记"></a>OpenCV学习笔记</h1><a id="more"></a><h2 id="图像翻转"><a href="#图像翻转" class="headerlink" title="图像翻转"></a>图像翻转</h2><p>使用Python的一个包，imutils。使用下面的指令可以安装。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pip install imutils<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>imutils包的Github地址：<a href="https://github.com/jrosebr1/imutils">https://github.com/jrosebr1/imutils</a>    CSDN镜像：<a href="https://codechina.csdn.net/mirrors/jrosebr1/imutils">https://codechina.csdn.net/mirrors/jrosebr1/imutils</a></p><p>可以在上面这个地址里面学习更多的使用方式。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import cv2import imutils&#39;&#39;&#39;imutils.rotate第一个参数是翻转的图像，第二个参数的翻转角度函数还提供翻转中心的设置，但默认就是中心翻转。&#39;&#39;&#39;vc &#x3D; cv2.VideoCapture(0)if vc.isOpened():    flag, frame &#x3D; vc.read()    img &#x3D; imutils.rotate(frame, 180)    # 图像翻转     cv2.imshow(&quot;frame&quot;, img)else:    flag &#x3D; Falsewhile flag:    flag, frame &#x3D; vc.read()    if frame is None:        break    if flag is True:        img &#x3D; imutils.rotate(frame, 180)    # 图像翻转        cv2.imshow(&quot;frame&quot;, img)        if cv2.waitKey(10) &#x3D;&#x3D; 27:            breakvc.release()cv2.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样写的话，最后的输出图像就是翻转180度的。</p><p>imutils包里还有其他好用的函数，resizing、4-point Perspective Transform、Sorting Contours等等。</p><h2 id="图像轮廓排序"><a href="#图像轮廓排序" class="headerlink" title="图像轮廓排序"></a>图像轮廓排序</h2><p>这个效果同样也是依靠imutils包完成。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from imutils import contoursimport cv2&#39;&#39;&#39;contours.sort_contours可选排序方式：&quot;left-to-right&quot;, &quot;right-to-left&quot;, &quot;top-to-bottom&quot;, &quot;bottom-to-top&quot;返回值为轮廓和外接矩形contours.label_contourcontours包内自带的画轮廓的函数，可以直接用，然后可以在图片上标出轮廓序号也可以直接使用cv2.drawContours直接画轮廓&#39;&#39;&#39;img &#x3D; cv2.imread(r&quot;D:\opencv-workspace\Opencv\test17--VScode\shapes.png&quot;)draw_img &#x3D; img.copy()img_rect &#x3D; img.copy()gray &#x3D; cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)img &#x3D; cv2.Canny(gray, 10, 20)    # Canny边缘检测cnts, hierarchy &#x3D; cv2.findContours(img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)    # 获得轮廓(cnts, boundingBoxes) &#x3D; contours.sort_contours(cnts, &quot;top-to-bottom&quot;)    # 对轮廓进行排序处理for (i, c) in enumerate(cnts):    sortedImage &#x3D; contours.label_contour(draw_img, c, i, color&#x3D;(240, 0, 159))# img_out &#x3D; cv2.drawContours(draw_img, cnts, -1, (240, 0, 159), 2)# 根据boundingBoxes画外接矩形for (x, y, w, h) in boundingBoxes:    img_rect &#x3D; cv2.rectangle(img_rect, (x, y), (x+w, y+h), (240, 0, 159), 2)cv2.imshow(&quot;top-to-bottom&quot;, sortedImage)cv2.imshow(&quot;rect&quot;, img_rect)cv2.waitKey(0)cv2.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/6/1.jpg" alt="处理效果"></p><h2 id="颜色识别"><a href="#颜色识别" class="headerlink" title="颜色识别"></a>颜色识别</h2><h3 id="基础颜色识别"><a href="#基础颜色识别" class="headerlink" title="基础颜色识别"></a>基础颜色识别</h3><p>颜色识别是在HSV空间内进行的，因此在使用之前先进行颜色空间的转换。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;使用下面这个函数进行转换，第一个参数填写要转换的图片，第二个参数填写cv2.COLOR_BGR2HSV&#39;&#39;&#39;cv2.cvtColor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">import cv2import numpy as np&#39;&#39;&#39;cv2.inRange函数很简单，参数有三个第一个参数：hsv指的是原图第二个参数：lower_red指的是图像中低于这个lower_red的值，图像值变为0第三个参数：upper_red指的是图像中高于这个upper_red的值，图像值变为0而在lower_red～upper_red之间的值变成255&#39;&#39;&#39;# 阈值lower_green &#x3D; np.array([50, 255, 255])upper_green &#x3D; np.array([70, 255, 255])img &#x3D; cv2.imread(r&quot;D:\opencv-workspace\Opencv\test16--VScode\photo.jpg&quot;)img_hsv &#x3D; cv2.cvtColor(img, cv2.COLOR_BGR2HSV)mask_green &#x3D; cv2.inRange(img_hsv, lower_green, upper_green)cv2.imshow(&quot;img_or&quot;, mask_green)# 使用下面这个函数能显示原来的颜色。res_green &#x3D; cv2.bitwise_and(img, img, mask&#x3D;mask_green)cv2.imshow(&quot;img&quot;, res_green)cv2.waitKey(0)cv2.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/6/2.jpg" alt="原图"></p><p><img src="/posts/6/4.jpg" alt="mask_green"></p><p><img src="/posts/6/3.jpg" alt="res_green"></p><p>在进行颜色识别时，难免会出现“漏颜色”的现象，也就是会出现没识别全的现象。这个时候可以再对图像进行处理，比如说进行形态学处理，让图像更加饱满之类的。</p><h3 id="根据BGR获取HSV"><a href="#根据BGR获取HSV" class="headerlink" title="根据BGR获取HSV"></a>根据BGR获取HSV</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">import cv2color &#x3D; np.uint8([[[193, 189, 147]]])    # 参数填写BGR的值hsv &#x3D; cv2.cvtColor(color, cv2.COLOR_BGR2HSV)print(hsv)    # 打印出来的数值就是对应的HSV值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序运行的结果是</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">[[[ 93  61 193]]]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个就是对应的HSV的值。</p><p>根据之前写的颜色识别，就需要把对应的阈值写出。具体写法就是<strong>保持S和V不变，H加减10。</strong>这样的话就可以写出高低阈值然后应用到颜色识别里面就可以了。</p><h3 id="阈值编辑器"><a href="#阈值编辑器" class="headerlink" title="阈值编辑器"></a>阈值编辑器</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">import cv2import numpy as npdef function(x):    lowH &#x3D; cv2.getTrackbarPos(&quot;lowH&quot;, &quot;img_666&quot;)    lowS &#x3D; cv2.getTrackbarPos(&quot;lowS&quot;, &quot;img_666&quot;)    lowV &#x3D; cv2.getTrackbarPos(&quot;lowV&quot;, &quot;img_666&quot;)    HighH &#x3D; cv2.getTrackbarPos(&quot;HighH&quot;, &quot;img_666&quot;)    HighS &#x3D; cv2.getTrackbarPos(&quot;HighS&quot;, &quot;img_666&quot;)    HighV &#x3D; cv2.getTrackbarPos(&quot;HighV&quot;, &quot;img_666&quot;)    # print(lowH, lowS, lowV, HighH, HighS, HighV)    lower &#x3D; np.uint8([lowH, lowS, lowV])    upper &#x3D; np.uint8([HighH, HighS, HighV])    mask &#x3D; cv2.inRange(img_hsv, lower, upper)    res &#x3D; cv2.bitwise_and(img, img, mask&#x3D;mask)    cv2.imshow(&quot;img&quot;, res)img &#x3D; cv2.imread(r&quot;D:\opencv-workspace\Opencv\test16--VScode\test.jpg&quot;)img_hsv &#x3D; cv2.cvtColor(img, cv2.COLOR_BGR2HSV)cv2.namedWindow(&quot;img_666&quot;)cv2.createTrackbar(&quot;lowH&quot;, &quot;img_666&quot;, 0, 179, function)cv2.createTrackbar(&quot;lowS&quot;, &quot;img_666&quot;, 0, 255, function)cv2.createTrackbar(&quot;lowV&quot;, &quot;img_666&quot;, 0, 255, function)cv2.createTrackbar(&quot;HighH&quot;, &quot;img_666&quot;, 0, 179, function)cv2.createTrackbar(&quot;HighS&quot;, &quot;img_666&quot;, 0, 255, function)cv2.createTrackbar(&quot;HighV&quot;, &quot;img_666&quot;, 0, 255, function)cv2.imshow(&quot;img&quot;, img)cv2.waitKey(0)cv2.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>写了一个比较垃圾的阈值编辑器。。。就不多解释了。。</p><p><img src="/posts/6/5.jpg" alt="阈值编辑器"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派串口通信 USB串口通信</title>
      <link href="posts/5.html"/>
      <url>posts/5.html</url>
      
        <content type="html"><![CDATA[<h1 id="树莓派串口通信-USB串口通信"><a href="#树莓派串口通信-USB串口通信" class="headerlink" title="树莓派串口通信 USB串口通信"></a>树莓派串口通信 USB串口通信</h1><a id="more"></a><p>如果不知道树莓派怎么使用USB串口通信的，欢迎浏览我的另一篇博客文章：<a href="https://lightningleader.github.io/posts/4.html">树莓派使用USB串口通信 CH340</a></p><p>这篇文章就以USB串口为例，简单的说下串口通信时常用的几个命令。注意：代码均为Python编写。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>树莓派4</li><li>两个CH340</li><li>串口助手</li></ul><h2 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h2><ol><li><p>最基础的发送数据方式</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;ser.write(data)    # 发送数据data，data为字节型&#39;&#39;&#39;import serialser &#x3D; serial.Serial(&quot;&#x2F;dev&#x2F;ttyUSB0&quot;, 115200)ser.flushInput()    # 清除缓存ser.write(&quot;LightningMaster\r\n&quot;.encode())    # 发送数据  \r\n可以实现换行  encode()默认是&#39;utf-8&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行这个代码就可以在串口助手上收到数据。</p><p><img src="/posts/5/1.jpg" alt="最基础发送数据"></p></li><li><p>发送中文</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import serialser &#x3D; serial.Serial(&quot;&#x2F;dev&#x2F;ttyUSB0&quot;, 115200)ser.flushInput()    # 清除缓存ser.write(&quot;闪电丶教主\r\n&quot;.encode(&#39;gb2312&#39;))    # 发送数据  \r\n可以实现换行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/5/2.jpg" alt="发送中文"></p></li><li><p>发送数据包 十六进制</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import serialimport structser &#x3D; serial.Serial(&quot;&#x2F;dev&#x2F;ttyUSB0&quot;, 115200)ser.flushInput()    # 清除缓存pack &#x3D; struct.pack(&#39;BBBB&#39;, 0xaa, 6, 7, 0x55)    # 将数据打包 格式是unsigned charser.write(pack)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/5/3.jpg" alt="发送数据包"></p><p>这个地方使用到了struct.pack，具体有啥作用可以自行百度去看看，我在这就不多说了。这里的作用就是将数据打包，返回格式是unsigned char 的字节串。</p><p>可以使用这个函数给数据加上“头”“尾”之类的东西。</p></li></ol><h2 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;ser.read(num)    # 读取收到的num个字节的数据ser.inWaiting()    # 可以获取还未读出的数据&#39;&#39;&#39;import serialimport structimport timeser &#x3D; serial.Serial(&quot;&#x2F;dev&#x2F;ttyUSB0&quot;, 115200)ser.flushInput()    # 清除缓存while True:    count &#x3D; ser.inWaiting()    # 获取还有多少字符未读    if count !&#x3D; 0:        data &#x3D; ser.read(count)    # 读取数据存到data中        print(data)    # 打印接受到的数据    time.sleep(0.1)    # 系统等待<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行代码，使用串口助手发送数据，可以在树莓派中看到返回值。</p><p><img src="/posts/5/4.jpg" alt="接收数据"></p><p>可以看到树莓派成功接收到了数据。</p><p>如果想把b’ ‘去掉可以使用代码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(data.decode(&#39;utf-8&#39;))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/5/5.jpg" alt="去掉b&#39;&#39;"></p><p>接收中文的话需要使用下面的代码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(data.decode(&#39;gb2312&#39;))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/5/6.jpg" alt="接收中文"></p><p>具体为什么使用encode和decode，可以自行查阅Python相关资料。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派使用USB串口通信 CH340</title>
      <link href="posts/4.html"/>
      <url>posts/4.html</url>
      
        <content type="html"><![CDATA[<h1 id="树莓派使用USB串口通信-CH340"><a href="#树莓派使用USB串口通信-CH340" class="headerlink" title="树莓派使用USB串口通信 CH340"></a>树莓派使用USB串口通信 CH340</h1><a id="more"></a><p>因为需要使用树莓派做自控方向的东西，所以需要使用树莓派串口与各种外设进行通信。使用串口的话个人比较喜欢直接使用USB串口，用起来比较方便。下面就介绍一下怎么使用树莓派的USB串口通信。</p><p>对于不会使用串口通信的hxd可以康康我的这篇文章，里面详细讲解了常用的串口通信的命令：<a href="https://lightningleader.github.io/posts/5.html">树莓派串口通信 USB串口通信</a></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>树莓派4</li><li>CH340</li><li>串口助手</li></ul><h2 id="树莓派正确识别CH340"><a href="#树莓派正确识别CH340" class="headerlink" title="树莓派正确识别CH340"></a>树莓派正确识别CH340</h2><p>首先正常开启树莓派，不要插入CH340，然后进入树莓派桌面，打开命令行，输入命令lsusb，可以查看本机的USB设备列表，以及USB设备的详细信息。</p><p><img src="/posts/4/1.jpg" alt="输入命令lsusb"></p><p>正常的话，就会像上图那样。</p><p>然后插入CH340，再次运行lsusb命令，这个时候应该会出现下面这个界面。</p><p><img src="/posts/4/2.jpg" alt="再次输入命令lsusb"></p><p>从上图可以明显看出多了一个设备，后面的设备详情也明确表示这个是CH340，这就表明树莓派正确识别到了插入的CH340。</p><p>接着在命令行输入命令 ls -l /dev/tty* </p><p><img src="/posts/4/3.jpg" alt="USB"></p><p>如上图所示，不出意外的话最后一个就是你插入的ch340，然后就记住这个黄色字体即/dev/ttyUSB0。这里的USB0也可能是USB1，这个是不确定的。</p><p>到了这里就代表你的树莓派可以正常识别CH34，下面就是写代码来验证效果了。</p><h2 id="代码实现通信"><a href="#代码实现通信" class="headerlink" title="代码实现通信"></a>代码实现通信</h2><p>这里我的代码是Python的。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import serialser &#x3D; serial.Serial(&quot;&#x2F;dev&#x2F;ttyUSB0&quot;, 115200)    # 第一个参数就是上面那个黄色字体  第二个参数填波特率ser.flushInput()    # 清除缓存ser.write(&quot;LightningMaster\r\n&quot;.encode())   # 发送<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：这个教程是默认树莓派已经进行了串口配置的。比如说安装pyserial包，如果没安装的话，可以使用下面的命令进行安装</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pip3 install pyserial<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为了测试，我使用两个CH340，一个连接树莓派另一个连接电脑，这样就可以直接在电脑上通过串口助手看到发送的数据了。</p><p>运行代码后就可以在串口助手上看到树莓派发送的数据了。</p><p><img src="/posts/4/4.jpg" alt="串口助手"></p><p>这样就可以正常使用USB串口进行通信了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循迹智能小车 循黑线</title>
      <link href="posts/3.html"/>
      <url>posts/3.html</url>
      
        <content type="html"><![CDATA[<h1 id="循迹智能小车-循黑线"><a href="#循迹智能小车-循黑线" class="headerlink" title="循迹智能小车 循黑线"></a>循迹智能小车 循黑线</h1><a id="more"></a><h2 id="硬件菜单"><a href="#硬件菜单" class="headerlink" title="硬件菜单"></a>硬件菜单</h2><ul><li><p>单片机型号：STC16F40K128</p></li><li><p>4路红外循迹模块</p></li><li><p>小车底盘套件（一个底盘、两个TT马达、两个轮胎）</p></li><li><p>12V航模电池</p></li><li><p>降压模块</p></li><li><p>A4950双路电机驱动</p></li><li><p>杜邦线等</p></li></ul><h2 id="硬件使用"><a href="#硬件使用" class="headerlink" title="硬件使用"></a>硬件使用</h2><p><img src="/posts/3/1.png" alt="4路红外循迹模块"></p><ul><li>关于4路红外循迹模块的使用教程，我之前写过一篇博客，里面有详细的介绍。如果有不会的可以先去浏览学习一下。<a href="https://lightningleader.github.io/posts/2.html">跳转至教程</a></li><li>A4950双路电机驱动使用方式不多说了，比较简单。大部分人应该都是用L298N的。</li></ul><h2 id="硬件组装"><a href="#硬件组装" class="headerlink" title="硬件组装"></a>硬件组装</h2><p><img src="/posts/3/2.jpg" alt="循迹小车1"></p><p><img src="/posts/3/3.jpg" alt="循迹小车2"></p><p>硬件组装大概按照上面两张图片组装就行。  </p><ul><li>不过要注意的是红外传感器之间的距离和单个传感器的测量精度。在组装完成后，要通电试一试传感器的工作情况，用它检测黑线，康康是不是能够正常工作。如果无法正常工作需要及时调整传感器的精度或者其他东西。总之要保证传感器能正常检测黑线。</li><li>另一点就是传感器的安装位置。受到传感器数量的限制，所以传感器的安装位置需要仔细考虑。我这里一共有4个传感器所以就像图中那样安装的。中间两个之间留有空隙，空隙的宽度大概为黑线宽度（可以稍微比黑线宽点），其他两个的位置也不要离得太远。具体为什么这样设计再后面讲解。</li></ul><h2 id="程序设计前的理解"><a href="#程序设计前的理解" class="headerlink" title="程序设计前的理解"></a>程序设计前的理解</h2><ul><li>接上面挖下的坑，说一下中间两个传感器之间空隙的问题。</li></ul><p>前提是小车在没有检测到黑线的时候会直线行驶。中间的空隙宽度略微大于黑线宽度，这样就可以满足当黑线处于这个缝隙间的时候传感器不会有反应，小车会直线行驶，在一定程度上满足循线的基础操作。肯定会出现黑线移出这个空隙的情况，这样的话黑线就会被两侧的传感器检测到，然后由单片机做出应对。如果是左侧的传感器检测到黑线（设定小车前进方向为正方向），代表车头右偏了，因此小车需要左转；于此类似，右侧的传感器也是一个道理。理解了这些就可以完成最基本的循线了。</p><ul><li>最外侧两个传感器的作用  </li></ul><p>因为传感器反应速度等等一系列可能的原因会出现黑线在移出中央空隙的时间很短导致传感器没有检测到等的情况，这样的话小车肯定会继续前进而导致无法继续循线。如果在中间两个传感器两侧又安装了两个传感器的话，这样就相当于多了一个保险，如果中间两个没有检测到的话，最外侧的传感器正常工作仍能让小车重新回到循线轨迹上来。不过要注意的是，因为当最外侧的传感器检测到黑线时就意味着车头已经偏的比较严重了，所以要想让车头偏正就需要给更大的“力”，也就是给更大的PWM。</p><h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;headfile.h&quot;&#x2F;******************** 用于初始化PWM的*******************&#x2F;void All_Init(void)&#123;pwm_init(PWMA_CH1P_P60, 10000, 0);pwm_init(PWMA_CH2P_P62, 10000, 0);pwm_init(PWMA_CH3P_P64, 10000, 0);pwm_init(PWMA_CH4P_P66, 10000, 0);&#125;&#x2F;******************** 车子左转*******************&#x2F;void turn_left(int duty)&#123;pwm_duty(PWMA_CH1P_P60, duty);pwm_duty(PWMA_CH2P_P62, 0);pwm_duty(PWMA_CH3P_P64, 0);pwm_duty(PWMA_CH4P_P66, duty);&#125;&#x2F;******************** 车子右转*******************&#x2F;void turn_right(int duty)&#123;pwm_duty(PWMA_CH1P_P60, 0);pwm_duty(PWMA_CH2P_P62, duty);pwm_duty(PWMA_CH3P_P64, duty);pwm_duty(PWMA_CH4P_P66, 0);&#125;&#x2F;******************** 车子直行*******************&#x2F;void go_straight(void)&#123;pwm_duty(PWMA_CH1P_P60, 7000);pwm_duty(PWMA_CH2P_P62, 0);pwm_duty(PWMA_CH3P_P64, 7000);pwm_duty(PWMA_CH4P_P66, 0);&#125;&#x2F;******************** 车子停止*******************&#x2F;void go_stop(void)&#123;pwm_duty(PWMA_CH1P_P60, 0);pwm_duty(PWMA_CH2P_P62, 0);pwm_duty(PWMA_CH3P_P64, 0);pwm_duty(PWMA_CH4P_P66, 0);&#125;&#x2F;****************************************** OUT1 P27* OUT2 P26* OUT3 P25* OUT4 P24* 如图循迹小车2所示，从左到右分别为OUT1、2、3、4* 检测到黑线或悬空LED灭，输出高电平* 对单片机的IO口状态进行判断，这样可以得到是哪个* 传感器检测到了黑线，然后再* 做出相对应的行为。*****************************************&#x2F;void scan(void)&#123;if ((P26 &#x3D;&#x3D; 0)&amp;&amp;(P25 &#x3D;&#x3D; 0)&amp;&amp;(P27 &#x3D;&#x3D; 0)&amp;&amp;(P24 &#x3D;&#x3D; 0))&#123;&#x2F;&#x2F; 未检测到黑线go_straight();&#125;else if ((P26 &#x3D;&#x3D; 1)&amp;&amp;(P25 &#x3D;&#x3D; 1)&amp;&amp;(P27 &#x3D;&#x3D; 1)&amp;&amp;(P24 &#x3D;&#x3D; 1))&#123;&#x2F;&#x2F; 悬空go_stop();&#125;else if ((P26 &#x3D;&#x3D; 0)&amp;&amp;(P25 &#x3D;&#x3D; 1)&amp;&amp;(P27 &#x3D;&#x3D; 0)&amp;&amp;(P24 &#x3D;&#x3D; 0))&#123;&#x2F;&#x2F; 车头右偏（相对于前进方向） 向左转（幅度较小）turn_left(7000);&#125;else if ((P26 &#x3D;&#x3D; 1)&amp;&amp;(P25 &#x3D;&#x3D; 0)&amp;&amp;(P27 &#x3D;&#x3D; 0)&amp;&amp;(P24 &#x3D;&#x3D; 0))&#123;&#x2F;&#x2F; 车头左偏 向右转（幅度较小）turn_right(7000);&#125;else if ((P26 &#x3D;&#x3D; 0)&amp;&amp;(P25 &#x3D;&#x3D; 0)&amp;&amp;(P27 &#x3D;&#x3D; 1)&amp;&amp;(P24 &#x3D;&#x3D; 0))&#123;&#x2F;&#x2F; 向左转（幅度较大）turn_left(9500);&#125;else if ((P26 &#x3D;&#x3D; 0)&amp;&amp;(P25 &#x3D;&#x3D; 0)&amp;&amp;(P27 &#x3D;&#x3D; 0)&amp;&amp;(P24 &#x3D;&#x3D; 1))&#123;&#x2F;&#x2F; 向右转（幅度较大）turn_right(9500);&#125;&#125;void main()&#123;DisableGlobalIRQ();&#x2F;&#x2F;关闭总中断board_init();&#x2F;&#x2F;初始化寄存器All_Init();&#x2F;&#x2F;总中断最后开启EnableGlobalIRQ();&#x2F;&#x2F;开启总中断    while(1)&#123;scan();  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序代码大概就像上面那样。其中有些参数，比如说小车行进速度和转弯占空比该给多少。这个东西需要自己测试然后填写，也就是自己慢慢调参测试，找到合适的数值就行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4路红外循迹模块使用教程</title>
      <link href="posts/2.html"/>
      <url>posts/2.html</url>
      
        <content type="html"><![CDATA[<h1 id="4路红外循迹模块使用教程"><a href="#4路红外循迹模块使用教程" class="headerlink" title="4路红外循迹模块使用教程"></a>4路红外循迹模块使用教程</h1><a id="more"></a><h2 id="模块详细信息："><a href="#模块详细信息：" class="headerlink" title="模块详细信息："></a>模块详细信息：</h2><p>工作电压：DC 3.3V~5V</p><p>工作电流：尽量选择1A以上电源供电</p><p>工作温度：-10℃~+50℃</p><p>安装孔径：M3螺丝</p><p>检测距离：1mm~30cm可调，距离越近2性能越稳定，白色反射距离远</p><p>尺寸大小：中控板42mmX38mmX12mm（长X宽X高）；小板向前25mmX12mmX12mm（长X宽X高）</p><p>输出接口：6线制接口（1、2、3、4为4路信号输出端，VCC接正电源，GND接GND）</p><p>输出信号：TTL电平，可直接连接单片机IO口，感应到传感器反射回来的红外光时，红指示灯亮，输出低电平；没有红外光时，指示灯不亮，输出高电平。</p><h2 id="模块接线"><a href="#模块接线" class="headerlink" title="模块接线"></a>模块接线</h2><p><img src="/posts/2/1.png" alt="4路红外循迹模块"></p><p>图中主控板左侧分别为，VCC、GND、OUT1、OUT2、OUT3、OUT4，其中OUT1、2、3、4分别连接单片机的IO口，用于检测输出电平。主控板右侧分别与四个小板连接，用于采集信息。</p><h2 id="模块使用"><a href="#模块使用" class="headerlink" title="模块使用"></a>模块使用</h2><p>模块正确连接并通电后，小板传感器开始工作。模块感应到传感器反射回来的红外光时，红指示灯亮，输出低电平；没有红外光时，指示灯不亮，输出高电平。以检测黑线为例，如果传感器检测到黑线，红外光无法反射回来则模块红指示灯熄灭，同时小板对应的OUT口输出高电平；如果未检测到黑线，红外光可以反射回来则模块红指示灯亮，小板对应的OUT口输出低电平。其中需要注意一种特殊情况，也就是说当测量物体超出测量范围时，此时红指示灯熄灭，OUT口输出高电平。</p><p>每个小板前面对应的电位器可以用来调整使用精度。</p><h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>代码使用的单片机型号：STC16F40K128</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &quot;headfile.h&quot;&#x2F;** OUT1 P27* OUT2 P26* OUT3 P25* OUT4 P24* 检测到黑线或悬空LED灭，输出高电平*&#x2F; int main() &#123;DisableGlobalIRQ();&#x2F;&#x2F;关闭总中断board_init();&#x2F;&#x2F;初始化寄存器&#x2F;&#x2F;总中断最后开启EnableGlobalIRQ();&#x2F;&#x2F;开启总中断    while(1)&#123;        &#x2F;&#x2F; 判断IO口电平状态if (P27 &#x3D;&#x3D; 1)        &#123;printf(&quot;OUT1 NO\r\n&quot;);&#125;if (P26 &#x3D;&#x3D; 1)&#123;printf(&quot;OUT2 NO\r\n&quot;);&#125;if (P25 &#x3D;&#x3D; 1)&#123;printf(&quot;OUT3 NO\r\n&quot;);&#125;if (P24 &#x3D;&#x3D; 1)&#123;printf(&quot;OUT4 NO\r\n&quot;);&#125;if ((P27 &#x3D;&#x3D; 0)&amp;&amp;(P26 &#x3D;&#x3D; 0)&amp;&amp;(P25 &#x3D;&#x3D; 0)&amp;&amp;(P24 &#x3D;&#x3D; 0))&#123;printf(&quot;OFF\r\n&quot;);&#125;  &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码是比较简单的，就是判断单片机IO口状态。如果IO口是高电平则表示传感器检测到黑线，否则没有检测到黑线。理解了这个原理就可以在其他型号的单片机上使用这个模块。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 硬件使用 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown学习笔记</title>
      <link href="posts/1.html"/>
      <url>posts/1.html</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown学习笔记"><a href="#Markdown学习笔记" class="headerlink" title="Markdown学习笔记"></a>Markdown学习笔记</h1><a id="more"></a><h2 id="1、代码块"><a href="#1、代码块" class="headerlink" title="1、代码块"></a>1、代码块</h2><p><strong>代码块语法：</strong></p><p>“ ``` ” 三个这个号（ESC下面的）加上想写的语言，就可以生成代码块区域</p><h2 id="2、标题"><a href="#2、标题" class="headerlink" title="2、标题"></a>2、标题</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="3、字体"><a href="#3、字体" class="headerlink" title="3、字体"></a>3、字体</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 加粗**闪电丶教主**# 代码高亮显示&#x3D;&#x3D;闪电丶教主&#x3D;&#x3D;# 删除线~~闪电丶教主~~# 斜体*闪电丶教主*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><p><strong>闪电丶教主</strong></p><h3 id="代码高亮显示"><a href="#代码高亮显示" class="headerlink" title="代码高亮显示"></a>代码高亮显示</h3><p><code>闪电丶教主</code></p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p><del>闪电丶教主</del></p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p><em>闪电丶教主</em></p><h2 id="4、引用"><a href="#4、引用" class="headerlink" title="4、引用"></a>4、引用</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 引用语法&gt;作者：闪电丶教主&gt;&gt;作者：闪电丶教主&gt;&gt;&gt;作者：闪电丶教主<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>作者：闪电丶教主</p><blockquote><p>作者：闪电丶教主</p></blockquote><blockquote><blockquote><p>作者：闪电丶教主</p></blockquote></blockquote></blockquote><h2 id="5、分割线"><a href="#5、分割线" class="headerlink" title="5、分割线"></a>5、分割线</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 分割线 比较常用---# 分割线2***<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><hr><h2 id="6、图片插入"><a href="#6、图片插入" class="headerlink" title="6、图片插入"></a>6、图片插入</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 在线图片 # 本地图片![图片名称](图片路径)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/posts/1/666.png" alt="测试图片"></p><p><img src="/posts/1/%E5%B0%8F%E6%81%B6%E9%AD%94.png" alt="就这¿"></p><h2 id="7、超链接"><a href="#7、超链接" class="headerlink" title="7、超链接"></a>7、超链接</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 超链接[名称](地址)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="8、列表语法"><a href="#8、列表语法" class="headerlink" title="8、列表语法"></a>8、列表语法</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 无序列表- 目录1- 目录2- 目录3# 1+. +名称1. 闪电丶教主<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>目录1</li><li>目录2</li><li>目录3</li></ul><ol><li>闪电丶教主</li></ol><h2 id="9、表格"><a href="#9、表格" class="headerlink" title="9、表格"></a>9、表格</h2><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>6</td><td>6</td><td>6</td></tr><tr><td>6</td><td>6</td><td>6</td></tr><tr><td>6</td><td>6</td><td>6</td></tr></tbody></table><p>ctrl+/ 查看源代码</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
