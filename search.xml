<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Skimage库使用</title>
      <link href="posts/13.html"/>
      <url>posts/13.html</url>
      
        <content type="html"><![CDATA[<h1 id="Skimage库使用"><a href="#Skimage库使用" class="headerlink" title="Skimage库使用"></a>Skimage库使用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近发现Skimage库挺好用的，可以和OpenCV搭配一起使用，让图像处理更加灵活和方便。</p><p>本博客只对Skimage库做简单的介绍，细节使用的话推荐官网查看或百度寻找。<a href="https://scikit-image.org/">Skimage官方网站</a></p><p>本博客会不断更新的，尽量。</p><h2 id="实现连通区域染色"><a href="#实现连通区域染色" class="headerlink" title="实现连通区域染色"></a>实现连通区域染色</h2><p><strong>源代码程序：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import cv2from skimage import measure, colorpath &#x3D; &quot;C:\\Users\\17513\\Desktop\\test.jpg&quot;img &#x3D; cv2.imread(path)img_copy &#x3D; img.copy()img_gray &#x3D; cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)img_gauss &#x3D; cv2.GaussianBlur(img_gray, (5, 5), 1)img_temp &#x3D; cv2.threshold(img_gray, 127, 255, cv2.THRESH_BINARY)[1]labels &#x3D; measure.label(img_temp)dst &#x3D; color.label2rgb(labels, bg_label&#x3D;0)    # bg_label&#x3D;0要有，不然会有警告cv2.imshow(&quot;666&quot;, dst)cv2.waitKey(0)cv2.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/13/1.png" alt="效果图"></p><p><strong>代码函数分析：</strong></p><p>这段代码很少，其中需要讲解的只有 <code>measure.label</code>和<code>color.label2rgb</code>，其他均为OpenCV的基础代码。</p><ul><li><p>skimage.measure.label</p><p>功能描述：实现连通区域标记。<br>函数调用形式：skimage.measure.label(input, neighbors = None, background = None, return_num = False, connectivity =None)<br>参数描述：<br>input : Image to label 需要被标记的图片，输入的数据结构不作要求<br>neighbors : 这个参数将被移除，被下面的connectivity替代。可以忽略不看<br>background : 选择背景像素，指定像素作为背景，全部相同像素标记为0<br>return_num : 是一个bool值，如果为True的话返回值是一个元组（labels ，num ）；如果为False的话就只返回labels<br>connectivity : Maximum number of orthogonal hops to consider a pixel/voxel as a neighbor. Accepted values are ranging from 1 to input.ndim. If None, a full connectivity of input.ndim is used. [int, optional]。如果input是一个二维的图片，那么connectivity的值范围选择{1,2}，如果是None则默认是取最高的值，对于二维来说，当connectivity=1时代表4连通，当connectivity=2时代表8连通.<br>Returns:<br>labels : 和input形状一样，但是数值是标记号，所以这是一个已经标记的图片<br>num : 标记的种类数，如果输出0则只有背景，如果输出2则有两个种类或者说是连通域</p></li><li><p>skimage.color.label2rgb</p><p>Parameters<br>labelarray, shape (M, N)<br>Integer array of labels with the same shape as image.</p><p>imagearray, shape (M, N, 3), optional<br>Image used as underlay for labels. If the input is an RGB image, it’s converted to grayscale before coloring.</p><p>colorslist, optional<br>List of colors. If the number of labels exceeds the number of colors, then the colors are cycled.</p><p>alphafloat [0, 1], optional<br>Opacity of colorized labels. Ignored if image is None.</p><p>bg_labelint, optional<br>Label that’s treated as the background. If bg_label is specified, bg_color is None, and kind is overlay, background is not painted by any colors.</p><p>bg_colorstr or array, optional<br>Background color. Must be a name in color_dict or RGB float values between [0, 1].</p><p>image_alphafloat [0, 1], optional<br>Opacity of the image.</p><p>kindstring, one of {‘overlay’, ‘avg’}<br>The kind of color image desired. ‘overlay’ cycles over defined colors and overlays the colored labels over the original image. ‘avg’ replaces each labeled segment with its average color, for a stained-class or pastel painting appearance.</p><p>saturationfloat [0, 1], optional<br>Parameter to control the saturation applied to the original image between fully saturated (original RGB, saturation=1) and fully unsaturated (grayscale, saturation=0). Only applies when kind=’overlay’.</p><p>Returns<br>resultarray of float, shape (M, N, 3)<br>The result of blending a cycling colormap (colors) for each distinct value in label with the image, at a certain alpha value.</p><p>这段关于<code>color.label2rgb</code>是直接复制官网上的。大部分参数都保持默认即可，与<code>measure.label</code>结合使用可以达到对不同连通区域染色的效果。</p></li></ul><h2 id="Skimage-measure-regionprops介绍"><a href="#Skimage-measure-regionprops介绍" class="headerlink" title="Skimage.measure.regionprops介绍"></a>Skimage.measure.regionprops介绍</h2><ul><li><p>Skimage.measure.regionprops</p><p>功能描述：测量标记图像区域的属性。<br>函数调用形式：skimage.measure.regionprops(label_image, intensity_image=None, cache=True, coordinates=None)<br>参数描述：<br>label_image：（N,M）ndarray，标记输入图像；<br>intensity_image : (N, M) ndarray，可选参数，具有与标记图像相同大小的强度（即输入）图像，默认值为“None”；<br>cache：bool，可选参数，确定是否缓存计算的属性。对于缓存属性，计算速度要快得多，而内存消耗则会增加；<br>coordinates：’rc’或’xy‘，可选参数，协调2D图像的约定。（3D图像仅支持’rc‘坐标）<br>Return:<br>region：是一种列表的形式，每个连通域的标记区域。</p></li></ul><p>这个函数返回值是一个列表，内容是每个没标记的连通区域。</p><table><thead><tr><th>属性名称</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>area</td><td>int</td><td>区域内像素点总数</td></tr><tr><td>bbox</td><td>tuple</td><td>边界外接框(min_row, min_col, max_row, max_col)</td></tr><tr><td>centroid</td><td>array</td><td>质心坐标</td></tr><tr><td>convex_area</td><td>int</td><td>凸包内像素点总数</td></tr><tr><td>convex_image</td><td>ndarray</td><td>和边界外接框同大小的凸包</td></tr><tr><td>coords</td><td>ndarray</td><td>区域内像素点坐标</td></tr><tr><td>Eccentricity</td><td>float</td><td>离心率</td></tr><tr><td>equivalent_diameter</td><td>float</td><td>和区域面积相同的圆的直径</td></tr><tr><td>euler_number</td><td>int</td><td>区域欧拉数</td></tr><tr><td>extent</td><td>float</td><td>区域面积和边界外接框面积的比率</td></tr><tr><td>filled_area</td><td>int</td><td>区域和外接框之间填充的像素点总数</td></tr><tr><td>perimeter</td><td>float</td><td>区域周长</td></tr><tr><td>label</td><td>int</td><td>区域标记</td></tr></tbody></table><p>源程序代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import cv2from skimage import measurepath &#x3D; &quot;C:\\Users\\17513\\Desktop\\test.jpg&quot;img &#x3D; cv2.imread(path)img_copy &#x3D; img.copy()img_gray &#x3D; cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)img_gauss &#x3D; cv2.GaussianBlur(img_gray, (5, 5), 1)img_temp &#x3D; cv2.threshold(img_gray, 127, 255, cv2.THRESH_BINARY)[1]labels &#x3D; measure.label(img_temp)a &#x3D; measure.regionprops(labels)for (j, i) in enumerate(a):    (min_row, min_col, max_row, max_col) &#x3D; i.bbox    cv2.rectangle(img_copy, (min_col, min_row), (max_col, max_row), (0, 0, 255))cv2.imshow(&quot;666&quot;, img_copy)cv2.waitKey(0)cv2.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/13/2.png" alt="效果图"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV实现连通区域填充</title>
      <link href="posts/12.html"/>
      <url>posts/12.html</url>
      
        <content type="html"><![CDATA[<h1 id="OpenCV实现连通区域填充"><a href="#OpenCV实现连通区域填充" class="headerlink" title="OpenCV实现连通区域填充"></a>OpenCV实现连通区域填充</h1><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本博客主要解决的问题来源于数据结构老师的一次作业，作业内容如下图所示。</p><p><img src="/posts/12/1.png" alt="问题照片"></p><p>要处理的图像如下：</p><p><img src="/posts/12/2.jpg" alt="原图像"></p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><ul><li>VS2019</li><li>C++</li><li>OpenCV-4.1.0</li></ul><h2 id="第一部分：使用轮廓查找和漫水填充的方法实现区域染色"><a href="#第一部分：使用轮廓查找和漫水填充的方法实现区域染色" class="headerlink" title="第一部分：使用轮廓查找和漫水填充的方法实现区域染色"></a>第一部分：使用轮廓查找和漫水填充的方法实现区域染色</h2><p><strong>流程图：</strong></p><p><img src="/posts/12/3.png" alt="漫水填充"></p><p><strong>源程序代码：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void deal_test_1()&#123;    Mat test_1_gray, test_1_threshold, test_1_gauss;    Mat test_1_sobelx, test_1_sobely, test_1_sobelxy;    Mat test_1_origin &#x3D; imread(&quot;C:\\Users\\17513\\Desktop\\数据结构报告\\栈和队列\\test.jpg&quot;);    Mat test_1_copy &#x3D; test_1_origin.clone();    &#x2F;*转换为灰度图*&#x2F;    cvtColor(test_1_origin, test_1_gray, COLOR_BGR2GRAY);    &#x2F;*高斯滤波*&#x2F;    GaussianBlur(test_1_gray, test_1_gauss, Size(5, 5), 0, 0);    &#x2F;*二值化*&#x2F;    threshold(test_1_gauss, test_1_threshold, 127, 255, THRESH_BINARY);    &#x2F;*Sobel算子*&#x2F;    Sobel(test_1_threshold, test_1_sobelx, CV_64F, 1, 0, 3);    convertScaleAbs(test_1_sobelx, test_1_sobelx);    Sobel(test_1_threshold, test_1_sobely, CV_64F, 0, 1, 3);    convertScaleAbs(test_1_sobely, test_1_sobely);    addWeighted(test_1_sobelx, 1, test_1_sobely, 1, 0, test_1_sobelxy);    &#x2F;*再次二值化*&#x2F;    threshold(test_1_sobelxy, test_1_threshold, 127, 255, THRESH_BINARY);    &#x2F;*寻找轮廓*&#x2F;    vector&lt;vector&lt;Point&gt;&gt; contours;    findContours(test_1_threshold, contours, RETR_EXTERNAL, CHAIN_APPROX_NONE);    &#x2F;*最小外接矩形*&#x2F;Point2f rect[4];vector&lt;Rect&gt; boundRect(contours.size());  &#x2F;&#x2F;定义外接矩形集合    vector&lt;RotatedRect&gt; box(contours.size()); &#x2F;&#x2F;定义最小外接矩形集合    srand((int)time(0));    for (int i &#x3D; 0; i &lt; contours.size(); i++)    &#123;        box[i] &#x3D; minAreaRect(Mat(contours[i]));  &#x2F;&#x2F;计算每个轮廓最小外接矩形        box[i].points(rect);  &#x2F;&#x2F;把最小外接矩形四个端点复制给rect数组        floodFill(test_1_copy, Point(box[i].center.x, box[i].center.y), Scalar(rand() % 255, rand() &amp; 255, rand() % 255), &amp;boundRect[i], Scalar(20, 20, 20), Scalar(20, 20, 20));    &#125;    cv_show(&quot;666&quot;, test_1_copy);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代码分析：</strong></p><ol><li>   这部分代码比较基础。首先对图片进行基本的处理，再使用轮廓查找的方式找的图形的轮廓。再通过轮廓算出其最小外接矩形，这样就可以大致确定每个图形所在的区域，也就是ROI区域。</li><li>   在获取ROI区域后的难点是如何对图像进行染色，而且还要保证每个图形染的颜色是不同的。<br>对于染色方法我这里使用的是漫水填充的算法。这个算法参考<br><a href="https://blog.csdn.net/poem_qianmo/article/details/28261997">【OpenCV入门教程之十五】水漫金山：OpenCV漫水填充算法（Floodfill）</a><br>具体函数的使用方法也比较简单。函数需要提供seedPoint即漫水填充算法的起点，在程序中这个点我给的是每个图像最小外接矩形的中心点。此外还需要提供填充的颜色，为了保证颜色的不同，采用随机数的方式选择不用的BGR颜色，随机数的范围是0到255.</li></ol><p><strong>效果图：</strong></p><p><img src="/posts/12/4.png" alt="漫水填充效果图">\</p><p>程序最终效果还可以接受，但有些图形的外边明显没有进行染色，这可能是因为图像经过基本处理后发生改变与原图像不同导致。</p><h2 id="第二部分：使用队列实现种子填充法"><a href="#第二部分：使用队列实现种子填充法" class="headerlink" title="第二部分：使用队列实现种子填充法"></a>第二部分：使用队列实现种子填充法</h2><p><strong>流程图：</strong></p><p><img src="/posts/12/5.png" alt="种子填充法"></p><p><strong>源程序代码：</strong></p><p>基本的图像处理：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Mat labelImg;Mat colorLabelImg;Mat test_1_gray, test_1_threshold, test_1_gauss;Mat test_1_origin &#x3D; imread(&quot;C:\\Users\\17513\\Desktop\\数据结构报告\\栈和队列\\test.jpg&quot;);Mat test_1_copy;cvtColor(test_1_origin, test_1_gray, COLOR_BGR2GRAY);GaussianBlur(test_1_gray, test_1_gauss, Size(5, 5), 0, 0);threshold(test_1_gauss, test_1_threshold, 127, 255, THRESH_BINARY);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代码分析：</strong><br>一些基本的图像处理。灰度图、高斯滤波和二值化。</p><p>种子填充法相关代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void SeedFillOld(const Mat&amp; binImg, Mat&amp; lableImg)&#123;    if (binImg.empty() || binImg.type() !&#x3D; CV_8UC1)    &#123;        return;    &#125;    lableImg.release();    binImg.convertTo(lableImg, CV_32SC1);    int label &#x3D; 1;    int rows &#x3D; binImg.rows;    int cols &#x3D; binImg.cols;    for (int i &#x3D; 0; i &lt; rows; i++)    &#123;        for (int j &#x3D; 0; j &lt; cols; j++)        &#123;            if (lableImg.at&lt;int&gt;(i, j) &#x3D;&#x3D; 255)            &#123;                queue&lt;pair&lt;int, int&gt;&gt; neighborPixels;                neighborPixels.push(pair&lt;int, int&gt;(i, j));     &#x2F;&#x2F; 像素位置: &lt;i,j&gt;                ++label;                while (!neighborPixels.empty())                &#123;                    pair&lt;int, int&gt; curPixel &#x3D; neighborPixels.front();                    int curX &#x3D; curPixel.first;                    int curY &#x3D; curPixel.second;                    if (lableImg.at&lt;int&gt;(curX, curY) !&#x3D; label)                    &#123;                        lableImg.at&lt;int&gt;(curX, curY) &#x3D; label;                        neighborPixels.pop();                        if (lableImg.at&lt;int&gt;(curX, curY - 1) &#x3D;&#x3D; 255)                        &#123;                            neighborPixels.push(std::pair&lt;int, int&gt;(curX, curY - 1));                        &#125;                        if (lableImg.at&lt;int&gt;(curX, curY + 1) &#x3D;&#x3D; 255)                        &#123;                            neighborPixels.push(std::pair&lt;int, int&gt;(curX, curY + 1));                        &#125;                        if (lableImg.at&lt;int&gt;(curX - 1, curY) &#x3D;&#x3D; 255)                        &#123;                            neighborPixels.push(std::pair&lt;int, int&gt;(curX - 1, curY));                        &#125;                        if (lableImg.at&lt;int&gt;(curX + 1, curY) &#x3D;&#x3D; 255)                        &#123;                            neighborPixels.push(std::pair&lt;int, int&gt;(curX + 1, curY));                        &#125;                    &#125;                    else                    &#123;                        neighborPixels.pop();                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代码分析：</strong></p><ol><li>   种子填充法<br>参考博客：<br><a href="https://blog.csdn.net/icvpr/article/details/10259577">OpenCV_连通区域分析（Connected Component Analysis-Labeling）</a><br><a href="https://blog.csdn.net/qq_37059483/article/details/78018539">OpenCV-二值图像连通域分析</a><br>在上面这两个博客中的种子填充法都是使用堆栈来实现的，因此在本程序中需要考虑换成队列。</li><li>   算法的简单分析：<br>（1）    首先需要获取原图像的列数和行数方便后面对每个像素点的访问。<br>（2）    通过遍历访问像素点，如果像素点(i, j)的值等于255（白色点）则将其坐标点存入neighborPixels队列中，并且标签label加1。<br>（3）    如果neighborPixels队列非空，则取出neighborPixels队列的队头。判断队头代表的像素点是否与当前label相等，如果相等则直接删除并重复步骤（3），否则进行步骤（4）。如果neighborPixels队列为空则执行步骤（2）。<br>（4）    将队头点赋值为label并从队列中删除。对队头点进行4领域判断。上下左右四个点，哪个点的像素值为255哪个值就入队。重复步骤（3）。<br>（5）    当所有像素点被遍历完之后种子填充法结束。</li><li>   种子填充法比较容易理解，我认为难点在于将原本代码中的堆栈转换为队列。经过仔细分析，发现如果仅仅是把堆栈换成队列会导致代码重复，及会出现一个像素点被多次访问的情况。为了解决这个问题，我在程序中多加了一个判断（第135行）。因为一个像素点被访问后会被“贴上”值为label的“标签”，所以对像素点的“标签”进行判断就可以知道这个点有没有被访问过。如果访问过则直接删除，否则正常执行程序即可。</li><li>   本程序中使用的是4领域，还可以换成8领域，不过我没试过，不知道效果怎么样。</li></ol><h2 id="第三部分：对图像染色"><a href="#第三部分：对图像染色" class="headerlink" title="第三部分：对图像染色"></a>第三部分：对图像染色</h2><p><strong>源程序代码：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Scalar GetRandomColor()&#123;    uchar r &#x3D; 255 * (rand() &#x2F; (1.0 + RAND_MAX));    uchar g &#x3D; 255 * (rand() &#x2F; (1.0 + RAND_MAX));    uchar b &#x3D; 255 * (rand() &#x2F; (1.0 + RAND_MAX));    return Scalar(b, g, r);&#125;void LabelColor(const Mat&amp; labelImg, Mat&amp; colorLabelImg)&#123;    int num &#x3D; 0;    if (labelImg.empty() ||        labelImg.type() !&#x3D; CV_32SC1)    &#123;        return;    &#125;    map&lt;int, Scalar&gt; colors;    int rows &#x3D; labelImg.rows;    int cols &#x3D; labelImg.cols;    colorLabelImg.release();    colorLabelImg.create(rows, cols, CV_8UC3);    colorLabelImg &#x3D; Scalar::all(0);    for (int i &#x3D; 0; i &lt; rows; i++)    &#123;        const int* data_src &#x3D; (int*)labelImg.ptr&lt;int&gt;(i);        uchar* data_dst &#x3D; colorLabelImg.ptr&lt;uchar&gt;(i);        for (int j &#x3D; 0; j &lt; cols; j++)        &#123;            int pixelValue &#x3D; data_src[j];            if (pixelValue &gt; 1)            &#123;                if (colors.count(pixelValue) &lt;&#x3D; 0)                &#123;                    colors[pixelValue] &#x3D; GetRandomColor();                    num++;                &#125;                Scalar color &#x3D; colors[pixelValue];                *data_dst++ &#x3D; color[0];                *data_dst++ &#x3D; color[1];                *data_dst++ &#x3D; color[2];            &#125;            else            &#123;                data_dst++;                data_dst++;                data_dst++;            &#125;        &#125;    &#125;    printf(&quot;color num : %d \n&quot;, num);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代码分析：</strong></p><ol><li>   颜色BGR也是取的随机数，可以保证每个区域颜色不同。</li><li>   通过遍历进行染色，判断方式就是对每个像素点的值也就是标签进行染色。同一个标签的点染同一个颜色。</li></ol><p><strong>效果图：</strong></p><p><img src="/posts/12/6.png" alt="种子填充法"></p><p>从图中可以看出，效果比轮廓法要好，颜色填充比较饱满。</p><h2 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;opencv2&#x2F;opencv.hpp&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;list&gt;using namespace cv;using namespace std;void cv_show(string name, Mat img)&#123;&#x2F;*用于显示图像*&#x2F;imshow(name, img);waitKey(0);&#125;void deal_test_1()&#123;Mat test_1_gray, test_1_threshold, test_1_gauss;Mat test_1_sobelx, test_1_sobely, test_1_sobelxy;Mat test_1_origin &#x3D; imread(&quot;C:\\Users\\17513\\Desktop\\数据结构报告\\栈和队列\\test.jpg&quot;);Mat test_1_copy &#x3D; test_1_origin.clone();&#x2F;*转换为灰度图*&#x2F;cvtColor(test_1_origin, test_1_gray, COLOR_BGR2GRAY);&#x2F;*高斯滤波*&#x2F;GaussianBlur(test_1_gray, test_1_gauss, Size(5, 5), 0, 0);&#x2F;*二值化*&#x2F;threshold(test_1_gauss, test_1_threshold, 127, 255, THRESH_BINARY);&#x2F;*Sobel算子*&#x2F;Sobel(test_1_threshold, test_1_sobelx, CV_64F, 1, 0, 3);convertScaleAbs(test_1_sobelx, test_1_sobelx);Sobel(test_1_threshold, test_1_sobely, CV_64F, 0, 1, 3);convertScaleAbs(test_1_sobely, test_1_sobely);addWeighted(test_1_sobelx, 1, test_1_sobely, 1, 0, test_1_sobelxy);&#x2F;*再次二值化*&#x2F;threshold(test_1_sobelxy, test_1_threshold, 127, 255, THRESH_BINARY);&#x2F;*寻找轮廓*&#x2F;vector&lt;vector&lt;Point&gt;&gt; contours;findContours(test_1_threshold, contours, RETR_EXTERNAL, CHAIN_APPROX_NONE);&#x2F;*绘制轮廓*&#x2F;&#x2F;&#x2F;drawContours(test_1_copy, contours, -1, Scalar(0, 255, 255), 2);&#x2F;*最小外接矩形*&#x2F;Point2f rect[4];vector&lt;Rect&gt; boundRect(contours.size());  &#x2F;&#x2F;定义外接矩形集合vector&lt;RotatedRect&gt; box(contours.size()); &#x2F;&#x2F;定义最小外接矩形集合srand((int)time(0));for (int i &#x3D; 0; i &lt; contours.size(); i++)&#123;box[i] &#x3D; minAreaRect(Mat(contours[i]));  &#x2F;&#x2F;计算每个轮廓最小外接矩形&#x2F;&#x2F;boundRect[i] &#x3D; boundingRect(Mat(contours[i]));&#x2F;&#x2F;circle(test_1_copy, Point(box[i].center.x, box[i].center.y), 2, Scalar(0, 255, 0), -1, 8);&#x2F;&#x2F;绘制最小外接矩形的中心点&#x2F;*rectangle(test_1_copy, Point(boundRect[i].x, boundRect[i].y), Point(boundRect[i].x +boundRect[i].width, boundRect[i].y + boundRect[i].height), Scalar(0, 255, 0), 1, 8);*&#x2F;box[i].points(rect);  &#x2F;&#x2F;把最小外接矩形四个端点复制给rect数组floodFill(test_1_copy, Point(box[i].center.x, box[i].center.y), Scalar(rand() % 255, rand() &amp; 255, rand() % 255), &amp;boundRect[i], Scalar(20, 20, 20), Scalar(20, 20, 20));&#125;cv_show(&quot;666&quot;, test_1_copy);&#125;void deal_test_2()&#123;Mat img_origin &#x3D; imread(&quot;C:\\Users\\17513\\Desktop\\数据结构报告\\栈和队列\\test2.jpg&quot;);Mat img_copy &#x3D; img_origin.clone();Mat img_gray, img_gauss, img_threshold;Mat img_sobelx, img_sobely, img_sobelxy;Mat dstImage;Mat element &#x3D; getStructuringElement(MORPH_RECT, Size(3, 3));cvtColor(img_copy, img_gray, COLOR_BGR2GRAY);GaussianBlur(img_gray, img_gauss, Size(5, 5), 0, 0);threshold(img_gray, img_threshold, 127, 255, THRESH_BINARY);morphologyEx(img_threshold, dstImage, 0, element);&#x2F;&#x2F;Sobel(dstImage, img_sobelx, CV_64F, 1, 0, 3);&#x2F;&#x2F;convertScaleAbs(img_sobelx, img_sobelx);&#x2F;&#x2F;Sobel(img_threshold, img_sobely, CV_64F, 0, 1, 3);&#x2F;&#x2F;convertScaleAbs(img_sobely, img_sobely);&#x2F;&#x2F;addWeighted(img_sobelx, 1, img_sobely, 1, 0, img_sobelxy);threshold(dstImage, img_threshold, 127, 255, THRESH_BINARY);vector&lt;vector&lt;Point&gt;&gt; contours;vector&lt;vector&lt;Point&gt;&gt; cnts;vector&lt;vector&lt;Point&gt;&gt; cnts_max;findContours(img_threshold, contours, RETR_EXTERNAL, CHAIN_APPROX_NONE);for (int i &#x3D; 0; i &lt; contours.size(); i++)&#123;double size &#x3D; contourArea(contours[i]);if (size &gt;&#x3D; 10 &amp;&amp; size &lt; 1000)cnts.push_back(contours[i]);if (size &gt;&#x3D; 1000)cnts_max.push_back(contours[i]);&#x2F;&#x2F; cout &lt;&lt; i &lt;&lt; &quot;&#x3D;&quot; &lt;&lt; size &lt;&lt; endl;&#125;Mat img_copy2 &#x3D; img_copy.clone();int sum;sum &#x3D; cnts.size() + cnts_max.size() * 2;drawContours(img_copy2, cnts, -1, Scalar(0, 0, 255), 1);&#x2F;&#x2F;drawContours(img_copy, cnts, -1, Scalar(0, 0, 255), 2);&#x2F;&#x2F;cout &lt;&lt; &quot;contours &#x3D; &quot; &lt;&lt; contours.size() &lt;&lt; endl;&#x2F;&#x2F;cout &lt;&lt; &quot;cnts &#x3D; &quot; &lt;&lt; cnts.size() &lt;&lt; endl;&#x2F;&#x2F;cout &lt;&lt; &quot;cnts_max &#x3D; &quot; &lt;&lt; cnts_max.size() &lt;&lt; endl;cout &lt;&lt; &quot;sum &#x3D; &quot; &lt;&lt; sum &lt;&lt; endl;&#x2F;&#x2F;cout &lt;&lt; &quot;一共有&quot; &lt;&lt; cnts.size() &lt;&lt; &quot;个米粒&quot; &lt;&lt; endl;imshow(&quot;米粒轮廓&quot;, img_copy2);waitKey(0);&#125;void SeedFillOld(const Mat&amp; binImg, Mat&amp; lableImg)&#123;if (binImg.empty() || binImg.type() !&#x3D; CV_8UC1)&#123;return;&#125;lableImg.release();binImg.convertTo(lableImg, CV_32SC1);int label &#x3D; 1;int rows &#x3D; binImg.rows;int cols &#x3D; binImg.cols;for (int i &#x3D; 0; i &lt; rows; i++)&#123;for (int j &#x3D; 0; j &lt; cols; j++)&#123;if (lableImg.at&lt;int&gt;(i, j) &#x3D;&#x3D; 255)&#123;queue&lt;pair&lt;int, int&gt;&gt; neighborPixels;neighborPixels.push(pair&lt;int, int&gt;(i, j));     &#x2F;&#x2F; 像素位置: &lt;i,j&gt;++label;while (!neighborPixels.empty())&#123;pair&lt;int, int&gt; curPixel &#x3D; neighborPixels.front();int curX &#x3D; curPixel.first;int curY &#x3D; curPixel.second;if (lableImg.at&lt;int&gt;(curX, curY) !&#x3D; label)&#123;lableImg.at&lt;int&gt;(curX, curY) &#x3D; label;neighborPixels.pop();if (lableImg.at&lt;int&gt;(curX, curY - 1) &#x3D;&#x3D; 255)&#123;neighborPixels.push(std::pair&lt;int, int&gt;(curX, curY - 1));&#125;if (lableImg.at&lt;int&gt;(curX, curY + 1) &#x3D;&#x3D; 255)&#123;neighborPixels.push(std::pair&lt;int, int&gt;(curX, curY + 1));&#125;if (lableImg.at&lt;int&gt;(curX - 1, curY) &#x3D;&#x3D; 255)&#123;neighborPixels.push(std::pair&lt;int, int&gt;(curX - 1, curY));&#125;if (lableImg.at&lt;int&gt;(curX + 1, curY) &#x3D;&#x3D; 255)&#123;neighborPixels.push(std::pair&lt;int, int&gt;(curX + 1, curY));&#125;&#125;else&#123;neighborPixels.pop();&#125;&#125;&#125;&#125;&#125;&#125;Scalar GetRandomColor()&#123;uchar r &#x3D; 255 * (rand() &#x2F; (1.0 + RAND_MAX));uchar g &#x3D; 255 * (rand() &#x2F; (1.0 + RAND_MAX));uchar b &#x3D; 255 * (rand() &#x2F; (1.0 + RAND_MAX));return Scalar(b, g, r);&#125;void LabelColor(const Mat&amp; labelImg, Mat&amp; colorLabelImg)&#123;int num &#x3D; 0;if (labelImg.empty() ||labelImg.type() !&#x3D; CV_32SC1)&#123;return;&#125;map&lt;int, Scalar&gt; colors;int rows &#x3D; labelImg.rows;int cols &#x3D; labelImg.cols;colorLabelImg.release();colorLabelImg.create(rows, cols, CV_8UC3);colorLabelImg &#x3D; Scalar::all(0);for (int i &#x3D; 0; i &lt; rows; i++)&#123;const int* data_src &#x3D; (int*)labelImg.ptr&lt;int&gt;(i);uchar* data_dst &#x3D; colorLabelImg.ptr&lt;uchar&gt;(i);for (int j &#x3D; 0; j &lt; cols; j++)&#123;int pixelValue &#x3D; data_src[j];if (pixelValue &gt; 1)&#123;if (colors.count(pixelValue) &lt;&#x3D; 0)&#123;colors[pixelValue] &#x3D; GetRandomColor();num++;&#125;Scalar color &#x3D; colors[pixelValue];*data_dst++ &#x3D; color[0];*data_dst++ &#x3D; color[1];*data_dst++ &#x3D; color[2];&#125;else&#123;data_dst++;data_dst++;data_dst++;&#125;&#125;&#125;printf(&quot;color num : %d \n&quot;, num);&#125;void deal_test_3()&#123;Mat labelImg;Mat colorLabelImg;Mat test_1_gray, test_1_threshold, test_1_gauss;Mat test_1_origin &#x3D; imread(&quot;C:\\Users\\17513\\Desktop\\数据结构报告\\栈和队列\\test.jpg&quot;);Mat test_1_copy;cvtColor(test_1_origin, test_1_gray, COLOR_BGR2GRAY);GaussianBlur(test_1_gray, test_1_gauss, Size(5, 5), 0, 0);threshold(test_1_gauss, test_1_threshold, 127, 255, THRESH_BINARY);SeedFillOld(test_1_threshold, labelImg);LabelColor(labelImg, colorLabelImg);cv_show(&quot;666&quot;, colorLabelImg);&#125;int main()&#123;int mode;cout &lt;&lt; &quot;请输入要执行的程序编号：&quot;;cin &gt;&gt; mode;if (mode &#x3D;&#x3D; 1)deal_test_1();else if (mode &#x3D;&#x3D; 2)deal_test_2();else if (mode &#x3D;&#x3D; 3)deal_test_3();elsecout &lt;&lt; &quot;请输入正确的编号！&quot; &lt;&lt; endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV模板匹配识别图片中的数字</title>
      <link href="posts/11.html"/>
      <url>posts/11.html</url>
      
        <content type="html"><![CDATA[<h1 id="OpenCV模板匹配识别图片中的数字"><a href="#OpenCV模板匹配识别图片中的数字" class="headerlink" title="OpenCV模板匹配识别图片中的数字"></a>OpenCV模板匹配识别图片中的数字</h1><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本博客主要实现利用OpenCV的模板匹配识别图像中的数字，然后把识别出来的数字输出到txt文件中，如果识别失败则输出“读取失败”。</p><p><strong>操作环境：</strong></p><ul><li>OpenCV - 4.1.0</li><li>Python 3.8.1</li></ul><h2 id="程序目标"><a href="#程序目标" class="headerlink" title="程序目标"></a>程序目标</h2><p>单个数字模板：（这些单个模板是我自己直接从图片上截取下来的）</p><p><img src="/posts/11/4.png" alt="单个数字模板"></p><p>要处理的图片：</p><p><img src="/posts/11/7.png" alt="要处理的图片"></p><p>终端输出：</p><p><img src="/posts/11/2.png" alt="终端输出"></p><p>文本输出：</p><p><img src="/posts/11/3.png" alt="文本输出"></p><h2 id="思路讲解"><a href="#思路讲解" class="headerlink" title="思路讲解"></a>思路讲解</h2><p><img src="/posts/11/1.jpg" alt="思路讲解"></p><h2 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h2><p>首先定义两个会用到的函数</p><p>第一个是显示图片的函数，这样的话在显示图片的时候就比较方便了</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def cv_show(name, img):    cv2.imshow(name, img)    cv2.waitKey(0)    cv2.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第二个是图片缩放的函数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def resize(image, width&#x3D;None, height&#x3D;None, inter&#x3D;cv2.INTER_AREA):    dim &#x3D; None    (h, w) &#x3D; image.shape[:2]    if width is None and height is None:        return image    if width is None:        r &#x3D; height &#x2F; float(h)        dim &#x3D; (int(w * r), height)    else:        r &#x3D; width &#x2F; float(w)        dim &#x3D; (width, int(h * r))    resized &#x3D; cv2.resize(image, dim, interpolation&#x3D;inter)    return resized<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先把这个代码贴出来，方便后面单个函数代码的理解。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    # 存放数字模板列表    digits &#x3D; []    # 当前运行目录    now_dir &#x3D; os.getcwd()    print(&quot;当前运行目录：&quot; + now_dir)    numbers_address &#x3D; now_dir + &quot;\\numbers&quot;    load_digits()    times &#x3D; input(&quot;请输入程序运行次数：&quot;)    for i in range(1, int(times) + 1):        demo(i)    print(&quot;输出成功，请检查本地temp.txt文件&quot;)    while True:        if input(&quot;输入小写‘q’并回车退出&quot;) &#x3D;&#x3D; &#39;q&#39;:            break<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来是第一个主要函数，功能是加载数字模板并进行处理。</p><p>这个函数使用到了<code>os</code>模块，所以需要在开头<code>import os</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def load_digits():    # 加载数字模板    path &#x3D; numbers_address    # 这个地方就是获取当前运行目录 获取函数在主函数里面    filename &#x3D; os.listdir(path)    # 获取文件夹文件    for file in filename:        img &#x3D; cv2.imread(numbers_address + &quot;\\&quot; + file)    # 读取图片        img_gray &#x3D; cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)    # 灰度处理        # 自动阈值二值化 把图片处理成黑底白字        img_temp &#x3D; cv2.threshold(img_gray, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]        # 寻找数字轮廓        cnt &#x3D; cv2.findContours(img_temp, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)[0]        # 获取数字矩形轮廓        x, y, w, h &#x3D; cv2.boundingRect(cnt[0])        # 将单个数字区域进行缩放并存到列表中以备后面使用        digit_roi &#x3D; cv2.resize(img_temp[y:y+h, x:x+w], (57, 88))        digits.append(digit_roi)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后一个函数是程序的重点，实现功能就是识别出数字并输出。</p><p>不过这里把这个大函数分开两部分来讲解。</p><p>第一部分是对图片进行处理，最终把图片中的数字区域圈出来。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 这两个都是核，参数可以改变rectKernel &#x3D; cv2.getStructuringElement(cv2.MORPH_RECT, (25, 25))sqKernel &#x3D; cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))# 这个就是读取图片的，可以暂时不理解target_path &#x3D; now_dir + &quot;\\&quot; + &quot;demo_&quot; + str(index) + &quot;.png&quot;img_origin &#x3D; cv2.imread(target_path)# 对图片进行缩放处理img_origin &#x3D; resize(img_origin, width&#x3D;300)# 灰度图img_gray &#x3D; cv2.cvtColor(img_origin, cv2.COLOR_BGR2GRAY)# 高斯滤波  参数可以改变，选择效果最好的就可以gaussian &#x3D; cv2.GaussianBlur(img_gray, (5, 5), 1)、# 自动二值化处理，黑底白字img_temp &#x3D; cv2.threshold(    gaussian, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]# 顶帽操作img_top &#x3D; cv2.morphologyEx(img_temp, cv2.MORPH_TOPHAT, rectKernel)# sobel操作img_sobel_x &#x3D; cv2.Sobel(img_top, cv2.CV_64F, 1, 0, ksize&#x3D;7)img_sobel_x &#x3D; cv2.convertScaleAbs(img_sobel_x)img_sobel_y &#x3D; cv2.Sobel(img_top, cv2.CV_64F, 0, 1, ksize&#x3D;7)img_sobel_y &#x3D; cv2.convertScaleAbs(img_sobel_y)img_sobel_xy &#x3D; cv2.addWeighted(img_sobel_x, 1, img_sobel_y, 1, 0)# 闭操作img_closed &#x3D; cv2.morphologyEx(img_sobel_xy, cv2.MORPH_CLOSE, rectKernel)# 自动二值化thresh &#x3D; cv2.threshold(    img_closed, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]# 闭操作img_closed &#x3D; cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, sqKernel)# 寻找数字轮廓cnts &#x3D; cv2.findContours(    img_closed.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)[0]# 轮廓排序(cnts, boundingBoxes) &#x3D; contours.sort_contours(cnts, &quot;top-to-bottom&quot;)# 存放正确数字序列（包含逗号）的轮廓，即过滤掉不需要的轮廓right_loc &#x3D; []# 下面这个循环是对轮廓进行筛选，只有长宽比例大于2的才可以被添加到列表中# 这个比例可以根据具体情况来改变。除此之外，还可以通过轮廓周长和轮廓面积等对轮廓进行筛选for c in cnts:    x, y, w, h &#x3D; cv2.boundingRect(c)    ar &#x3D; w&#x2F;float(h)    if ar &gt; 2:        right_loc.append((x, y, w, h))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>部分步骤的效果图：</p><p><img src="/posts/11/5.png" alt="效果图"></p><p>可以看到在进行完最后一次闭操作后，一串数字全部变成白色区域，这样再进行轮廓检测就可以框出每一行数字的大致范围，这样就可以缩小数字处理的范围，可以在这些具体的区域内部对单个数字进行处理。</p><p>轮廓效果：</p><p><img src="/posts/11/6.png" alt="轮廓效果"></p><p>在这样进行以上步骤之后，就可以确定一行数字的范围了，下面就进行轮廓筛选把符合条件的轮廓存入列表。</p><p><strong>注意：在代码中使用了<code>(cnts, boundingBoxes) = contours.sort_contours(cnts, &quot;top-to-bottom&quot;)</code></strong></p><p><strong>这个函数的使用需要导入<code>imutils</code>，这个模块具体使用方法可以浏览我的另一篇博客<a href="https://lightningleader.github.io/posts/6.html">OpenCV学习笔记</a></strong></p><p>函数的最后一部分就是对每个数字轮廓进行分割，取出单个数字的区域然后进行模板匹配。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">for (gx, gy, gw, gh) in right_loc:        # 用于存放识别到的数字        digit_out &#x3D; []        # 下面两个判断主要是防止出现越界的情况发生，如果发生的话图片读取会出错        if (gy-10 &lt; 0):            now_gy &#x3D; gy        else:            now_gy &#x3D; gy-10        if (gx - 10 &lt; 0):            now_gx &#x3D; gx        else:            now_gx &#x3D; gx-10        # 选择图片兴趣区域        img_digit &#x3D; gaussian[now_gy:gy+gh+10, now_gx:gx+gw+10]        # 二值化处理        img_thresh &#x3D; cv2.threshold(            img_digit, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]        # 寻找所有轮廓 找出每个数字的轮廓（包含逗号） 正确的话应该有9个轮廓        digitCnts &#x3D; cv2.findContours(            img_thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)[0]        # 从左到右排列轮廓        # 这样排列的好处是，正常情况下可以确定逗号的位置方便后面删除逗号        (cnts, boundingBoxes) &#x3D; contours.sort_contours(digitCnts, &quot;left-to-right&quot;)        # cnts是元组，需要先转换成列表，因为后面会对元素进行删除处理        cnts &#x3D; list(cnts)        flag &#x3D; 0        # 判断轮廓数量是否有9个        if len(cnts) &#x3D;&#x3D; 9:            # 删除逗号位置            del cnts[1]            del cnts[2]            del cnts[3]            del cnts[4]            # 可以在转成元组            cnts &#x3D; tuple(cnts)            # 存放单个数字的矩形区域            num_roi &#x3D; []            for c in cnts:                x, y, w, h &#x3D; cv2.boundingRect(c)                num_roi.append((x, y, w, h))            # 对数字区域进行处理，把尺寸缩放到与数字模板相同            # 对其进行简单处理，方便与模板匹配，增加匹配率            for (rx, ry, rw, rh) in num_roi:                roi &#x3D; img_digit[ry:ry+rh, rx:rx+rw]                roi &#x3D; cv2.resize(roi, (57, 88))                # 高斯滤波                roi &#x3D; cv2.GaussianBlur(roi, (5, 5), 1)                # 二值化                roi &#x3D; cv2.threshold(                    roi, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]                # 用于存放匹配率                source &#x3D; []                # 遍历数字模板                for digitROI in digits:                    # 进行模板匹配                    res &#x3D; cv2.matchTemplate(                        roi, digitROI, cv2.TM_CCOEFF_NORMED)                    max_val &#x3D; cv2.minMaxLoc(res)[1]                    source.append(max_val)                # 这个需要仔细理解 这个就是把0-9数字中匹配度最高的数字存放到列表中                digit_out.append(str(source.index(max(source))))            # 打印最终输出值            print(digit_out)        else:            print(&quot;读取失败&quot;)            flag &#x3D; 1        # 将数字输出到txt文本中        t &#x3D; &#39;&#39;        with open(now_dir + &quot;\\temp.txt&quot;, &#39;a+&#39;) as q:            if flag &#x3D;&#x3D; 0:                for content in digit_out:                    t &#x3D; t + str(content) + &quot; &quot;                q.write(t.strip(&quot; &quot;))                q.write(&#39;\n&#39;)                t &#x3D; &#39;&#39;            else:                q.write(&quot;读取失败&quot;)                q.write(&#39;\n&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意理解：<code>digit_out.append(str(source.index(max(source))))</code></strong></p><p><strong>这个是很重要的，列表source存放模板匹配的每个数字的匹配率，求出其中最大值的索引值，因为数字模板是按照0-9排列的，索引source的匹配率也是按照0-9排列的，所以每个元素的索引值就与相匹配的数字相同。这样的话，取得最大值的索引值就相当于取到了匹配率最高的数字。</strong></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">from imutils import contoursimport cv2import osdef cv_show(name, img):    cv2.imshow(name, img)    cv2.waitKey(0)    cv2.destroyAllWindows()def resize(image, width&#x3D;None, height&#x3D;None, inter&#x3D;cv2.INTER_AREA):    dim &#x3D; None    (h, w) &#x3D; image.shape[:2]    if width is None and height is None:        return image    if width is None:        r &#x3D; height &#x2F; float(h)        dim &#x3D; (int(w * r), height)    else:        r &#x3D; width &#x2F; float(w)        dim &#x3D; (width, int(h * r))    resized &#x3D; cv2.resize(image, dim, interpolation&#x3D;inter)    return resizeddef load_digits():    # 加载数字模板    path &#x3D; numbers_address    filename &#x3D; os.listdir(path)    for file in filename:        # print(file)        img &#x3D; cv2.imread(            numbers_address + &quot;\\&quot; + file)        img_gray &#x3D; cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)        img_temp &#x3D; cv2.threshold(            img_gray, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]        cnt &#x3D; cv2.findContours(img_temp, cv2.RETR_EXTERNAL,                               cv2.CHAIN_APPROX_NONE)[0]        x, y, w, h &#x3D; cv2.boundingRect(cnt[0])        digit_roi &#x3D; cv2.resize(img_temp[y:y+h, x:x+w], (57, 88))        # 将数字模板存到列表中        digits.append(digit_roi)def demo(index):    rectKernel &#x3D; cv2.getStructuringElement(cv2.MORPH_RECT, (25, 25))    sqKernel &#x3D; cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))    target_path &#x3D; now_dir + &quot;\\&quot; + &quot;demo_&quot; + str(index) + &quot;.png&quot;    img_origin &#x3D; cv2.imread(target_path)    img_origin &#x3D; resize(img_origin, width&#x3D;300)    img_gray &#x3D; cv2.cvtColor(img_origin, cv2.COLOR_BGR2GRAY)    gaussian &#x3D; cv2.GaussianBlur(img_gray, (5, 5), 1)    img_temp &#x3D; cv2.threshold(        gaussian, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]    img_top &#x3D; cv2.morphologyEx(img_temp, cv2.MORPH_TOPHAT, rectKernel)    img_sobel_x &#x3D; cv2.Sobel(img_top, cv2.CV_64F, 1, 0, ksize&#x3D;7)    img_sobel_x &#x3D; cv2.convertScaleAbs(img_sobel_x)    img_sobel_y &#x3D; cv2.Sobel(img_top, cv2.CV_64F, 0, 1, ksize&#x3D;7)    img_sobel_y &#x3D; cv2.convertScaleAbs(img_sobel_y)    img_sobel_xy &#x3D; cv2.addWeighted(img_sobel_x, 1, img_sobel_y, 1, 0)    img_closed &#x3D; cv2.morphologyEx(img_sobel_xy, cv2.MORPH_CLOSE, rectKernel)    thresh &#x3D; cv2.threshold(        img_closed, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]    img_closed &#x3D; cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, sqKernel)    cnts &#x3D; cv2.findContours(        img_closed.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)[0]    (cnts, boundingBoxes) &#x3D; contours.sort_contours(cnts, &quot;top-to-bottom&quot;)    draw_img &#x3D; img_origin.copy()    draw_img &#x3D; cv2.drawContours(draw_img, cnts, -1, (0, 0, 255), 1)    cv_show(&quot;666&quot;, draw_img)    # 存放正确数字序列（包含逗号）的轮廓，即过滤掉不需要的轮廓    right_loc &#x3D; []    for c in cnts:        x, y, w, h &#x3D; cv2.boundingRect(c)        ar &#x3D; w&#x2F;float(h)        if ar &gt; 2:            right_loc.append((x, y, w, h))    for (gx, gy, gw, gh) in right_loc:        # 用于存放识别到的数字        digit_out &#x3D; []        if (gy-10 &lt; 0):            now_gy &#x3D; gy        else:            now_gy &#x3D; gy-10        if (gx - 10 &lt; 0):            now_gx &#x3D; gx        else:            now_gx &#x3D; gx-10        img_digit &#x3D; gaussian[now_gy:gy+gh+10, now_gx:gx+gw+10]        # 二值化处理        img_thresh &#x3D; cv2.threshold(            img_digit, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]        # 寻找轮廓 找出每个数字的轮廓（包含逗号） 正确的话应该有9个轮廓        digitCnts &#x3D; cv2.findContours(            img_thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)[0]        # 从左到右排列        (cnts, boundingBoxes) &#x3D; contours.sort_contours(digitCnts, &quot;left-to-right&quot;)        cnts &#x3D; list(cnts)        flag &#x3D; 0        if len(cnts) &#x3D;&#x3D; 9:            del cnts[1]            del cnts[2]            del cnts[3]            del cnts[4]            cnts &#x3D; tuple(cnts)            num_roi &#x3D; []            for c in cnts:                x, y, w, h &#x3D; cv2.boundingRect(c)                num_roi.append((x, y, w, h))            for (rx, ry, rw, rh) in num_roi:                roi &#x3D; img_digit[ry:ry+rh, rx:rx+rw]                roi &#x3D; cv2.resize(roi, (57, 88))                roi &#x3D; cv2.GaussianBlur(roi, (5, 5), 1)                roi &#x3D; cv2.threshold(                    roi, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]                source &#x3D; []                for digitROI in digits:                    res &#x3D; cv2.matchTemplate(                        roi, digitROI, cv2.TM_CCOEFF_NORMED)                    max_val &#x3D; cv2.minMaxLoc(res)[1]                    source.append(max_val)                digit_out.append(str(source.index(max(source))))            cv2.rectangle(img_origin, (gx-5, gy-5),                          (gx+gw+5, gy+gh+5), (0, 0, 255), 1)            print(digit_out)        else:            print(&quot;读取失败&quot;)            flag &#x3D; 1        t &#x3D; &#39;&#39;        with open(now_dir + &quot;\\temp.txt&quot;, &#39;a+&#39;) as q:            if flag &#x3D;&#x3D; 0:                for content in digit_out:                    t &#x3D; t + str(content) + &quot; &quot;                q.write(t.strip(&quot; &quot;))                q.write(&#39;\n&#39;)                t &#x3D; &#39;&#39;            else:                q.write(&quot;读取失败&quot;)                q.write(&#39;\n&#39;)if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    # 存放数字模板列表    digits &#x3D; []    # 当前运行目录    now_dir &#x3D; os.getcwd()    print(&quot;当前运行目录：&quot; + now_dir)    numbers_address &#x3D; now_dir + &quot;\\numbers&quot;    load_digits()    times &#x3D; input(&quot;请输入程序运行次数：&quot;)    for i in range(1, int(times) + 1):        demo(i)    print(&quot;输出成功，请检查本地temp.txt文件&quot;)    cv2.waitKey(0)    cv2.destroyAllWindows()    while True:        if input(&quot;输入小写‘q’并回车退出&quot;) &#x3D;&#x3D; &#39;q&#39;:            break<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>整个文件下载地址：<a href="https://wwe.lanzous.com/iLSDunf850b">https://wwe.lanzous.com/iLSDunf850b</a></strong></p><p><strong>注意：如果想同时识别多个图片话，需要将图片统一改名为“demo_ + 数字序号.png”  例如：demo_1.png demo_2.png 同时在运行代码时输入图片个数即可。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个程序代码相对来说不算复杂，主要是对图像的一些基础处理需要注意。因为不同的图像想要识别成功需要进行不同程度的基础处理，所以在做的时候可以多输出几张图片检查一下那一步效果不太好并及时进行修改调整，这样才能达到最终比较好的效果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言数据结构-链表</title>
      <link href="posts/10.html"/>
      <url>posts/10.html</url>
      
        <content type="html"><![CDATA[<h1 id="C语言数据结构-链表"><a href="#C语言数据结构-链表" class="headerlink" title="C语言数据结构-链表"></a>C语言数据结构-链表</h1><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>这篇博客属于学习笔记，是博主在学习链表时的一些笔记，所以不保证内容的完全正确性和严谨性以及简洁等。</strong></p><p><strong>此外由于属于学习笔记所以不会对原理性知识进行讲解，博客重点放在代码上。</strong></p><p>使用环境：</p><ul><li>C语言</li><li>VS2019</li></ul><h2 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h2><p>创建链表的方法可能会有很多种，博主这里使用的是把头结点空出来也就是不给头节点赋值的一种创建方式。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;*结点结构体*&#x2F;struct Node&#123;int data;struct Node* next;&#125;;typedef struct Node Node;&#x2F;*创建链表*&#x2F;Node* createNode()&#123;&#x2F;* head,tail分别指向链表的头结点和尾结点*&#x2F;Node* head, * tail, * p;int num;head &#x3D; (Node*)malloc(sizeof(Node));    &#x2F;*申请内存*&#x2F;tail &#x3D; head;printf(&quot;请输入一组数据，结尾使用&#39;-9999&#39;\n&quot;);(void)scanf(&quot;%d&quot;, &amp;num);while (num !&#x3D; -9999)&#123;p &#x3D; (Node*)malloc(sizeof(Node));    &#x2F;*申请内存*&#x2F;p-&gt;data &#x3D; num;    &#x2F;*结点赋值*&#x2F;tail-&gt;next &#x3D; p;    &#x2F;*当前链表尾指向结点p*&#x2F;tail &#x3D; p;    &#x2F;*将结点p设为尾结点*&#x2F;(void)scanf(&quot;%d&quot;, &amp;num);&#125;tail-&gt;next &#x3D; NULL;    &#x2F;*最后一个结点指向NULL*&#x2F;    printf(&quot;链表创建成功\n&quot;);return head;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="打印链表内容"><a href="#打印链表内容" class="headerlink" title="打印链表内容"></a>打印链表内容</h2><p>因为创建链表是从首结点开始的（从首结点开始赋值），所以打印的时候也要从首结点开始。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;*打印链表*&#x2F;void displayNode(Node* head)&#123;if (head-&gt;next &#x3D;&#x3D; NULL)    &#x2F;*判断链表是否为空*&#x2F;printf(&quot;链表为空\n&quot;);else&#123;Node* p;p &#x3D; head-&gt;next;    &#x2F;*从首结点开始*&#x2F;printf(&quot;链表如下\n&quot;);while (p !&#x3D; NULL)    &#x2F;*遍历打印*&#x2F;&#123;printf(&quot;%d    &quot;, p-&gt;data);p &#x3D; p-&gt;next;&#125;        printf(&quot;\n&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/10/1.jpg" alt="打印链表内容-效果图"></p><p>在这里为了更好的理解代码引用其他博主的博客中的一句话，（出处原地址:<a href="https://blog.csdn.net/qq_41481924/article/details/85340787">C语言链表操作详解</a>)</p><p><strong>我在这着重解释一下p-&gt;next = NULL和p!=NULL的区别，因为我刚开始也经常弄错！！<br>while(p-&gt;next ！= NULL) 循环结束时，此时p的位置是尾节点的位置，但如果用于输出函数的判断条件，则尾节点的数据不会输出。<br>while(p!=NULL) 循环结束时， 此时p指向的位置为尾节点的下一个节点，因为没有申请内存空间，所以是一个未知的区域。</strong></p><p>理解这两句话的话就可以继续下面的学习了。</p><h2 id="释放链表内存"><a href="#释放链表内存" class="headerlink" title="释放链表内存"></a>释放链表内存</h2><p>在结束链表使用的时候需要释放一下内存。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;*释放链表内存*&#x2F;void releaseNode(Node* head)&#123;Node* p1, * p2;p1 &#x3D; head;while (p1 !&#x3D; NULL)&#123;p2 &#x3D; p1;p1 &#x3D; p1-&gt;next;free(p2);&#125;printf(&quot;链表释放内存成功\n&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h2><p>这里提供两种不同目的的删除方式，一种是根据结点值删除，另一种是根据结点位置删除。</p><h3 id="根据结点值删除"><a href="#根据结点值删除" class="headerlink" title="根据结点值删除"></a>根据结点值删除</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*根据结点的值删除链表中结点*&#x2F;void deleteNode_val(Node* head)&#123;if (head-&gt;next &#x3D;&#x3D; NULL)printf(&quot;链表为空\n&quot;);else&#123;Node* p1, * p2;int num;printf(&quot;请输入要删除的结点数值：\n&quot;);(void)scanf(&quot;%d&quot;, &amp;num);p1 &#x3D; head-&gt;next;    &#x2F;*使用p1逐个寻找数据*&#x2F;p2 &#x3D; NULL;while ((p1-&gt;data !&#x3D; num) &amp;&amp; (p1-&gt;next !&#x3D; NULL))    &#x2F;*遍历寻找*&#x2F;&#123;p2 &#x3D; p1;    &#x2F;*用p2记录p1原来的位置*&#x2F;p1 &#x3D; p1-&gt;next;&#125;if (p1-&gt;data &#x3D;&#x3D; num)&#123;if (p1 &#x3D;&#x3D; head-&gt;next)    &#x2F;*判断p1是否为首结点*&#x2F;&#123;head-&gt;next &#x3D; p1-&gt;next;    &#x2F;*如果是则将头结点与首结点的下一个结点链接*&#x2F;&#125;elsep2-&gt;next &#x3D; p1-&gt;next;   &#x2F;*将p1前一个结点p2直接与p1下一个结点链接*&#x2F;free(p1);    &#x2F;*释放p1的内存*&#x2F;printf(&quot;删除成功\n&quot;);&#125;elseprintf(&quot;删除失败\n&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/10/2.jpg" alt="根据结点值删除结点-效果图"></p><h3 id="根据结点位置删除"><a href="#根据结点位置删除" class="headerlink" title="根据结点位置删除"></a>根据结点位置删除</h3><p>这里的位置索引是从“1”开始的，可以通过修改变量<code>now_pos</code>改变位置索引。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*根据结点位置删除结点*&#x2F;void deleteNode_pos(Node* head)&#123;if (head-&gt;next &#x3D;&#x3D; NULL)printf(&quot;链表为空\n&quot;);else&#123;Node* p1, * p2;int  now_pos&#x3D; 1, pos;printf(&quot;请输入要输出结点的位置：\n&quot;);(void)scanf(&quot;%d&quot;, &amp;pos);p1 &#x3D; head-&gt;next;p2 &#x3D; NULL;while ((now_pos !&#x3D; pos) &amp;&amp; (p1-&gt;next !&#x3D; NULL))&#123;p2 &#x3D; p1;p1 &#x3D; p1-&gt;next;now_pos++;&#125;if (now_pos &#x3D;&#x3D; pos)&#123;if (p1 &#x3D;&#x3D; head-&gt;next)head-&gt;next &#x3D; p1-&gt;next;elsep2-&gt;next &#x3D; p1-&gt;next;free(p1);printf(&quot;删除成功\n&quot;);&#125;elseprintf(&quot;删除失败\n&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/10/3.jpg" alt="根据结点位置删除-效果图"></p><h2 id="根据结点位置插入新的结点"><a href="#根据结点位置插入新的结点" class="headerlink" title="根据结点位置插入新的结点"></a>根据结点位置插入新的结点</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;*根据结点位置插入新的结点*&#x2F;void insertNode(Node* head)&#123;if (head-&gt;next !&#x3D; NULL)&#123;int pos, val, now_pos &#x3D; 1;Node* p, * p1, * p2;p &#x3D; (Node*)malloc(sizeof(Node));printf(&quot;请输入要插入的值和位置\n&quot;);(void)scanf(&quot;%d %d&quot;, &amp;val, &amp;pos);p-&gt;data &#x3D; val;p-&gt;next &#x3D; NULL;p1 &#x3D; head-&gt;next;p2 &#x3D; NULL;while ((now_pos !&#x3D; pos) &amp;&amp; (p1 !&#x3D; NULL))    &#x2F;*注意这里，如果使用p1-&gt;next则没办法在插入到最后*&#x2F;&#123;p2 &#x3D; p1;p1 &#x3D; p1-&gt;next;now_pos++;&#125;if (now_pos &#x3D;&#x3D; pos)&#123;if (p1 &#x3D;&#x3D; head-&gt;next)&#123;head-&gt;next &#x3D; p;p-&gt;next &#x3D; p1;&#125;else&#123;p2-&gt;next &#x3D; p;p-&gt;next &#x3D; p1;&#125;printf(&quot;插入成功\n&quot;);&#125;elseprintf(&quot;插入失败\n&quot;);&#125;elseprintf(&quot;链表为空\n&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/10/4.jpg" alt="根据结点位置插入新的结点-效果图"></p><h2 id="根据结点位置修改结点的值"><a href="#根据结点位置修改结点的值" class="headerlink" title="根据结点位置修改结点的值"></a>根据结点位置修改结点的值</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*根据结点位置修改结点的值*&#x2F;void changeNode(Node* head)&#123;if (head-&gt;next &#x3D;&#x3D; NULL)printf(&quot;链表为空\n&quot;);else&#123;int now_pos &#x3D; 1, pos, val;Node* p1;printf(&quot;请输入要修改的值和位置\n&quot;);(void)scanf(&quot;%d %d&quot;, &amp;val, &amp;pos);p1 &#x3D; head-&gt;next;while ((now_pos !&#x3D; pos) &amp;&amp; (p1-&gt;next !&#x3D; NULL))&#123;p1 &#x3D; p1-&gt;next;now_pos++;&#125;if (now_pos &#x3D;&#x3D; pos)&#123;p1-&gt;data &#x3D; val;printf(&quot;修改成功\n&quot;);&#125;elseprintf(&quot;修改失败\n&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/10/5.jpg" alt="根据结点位置修改结点的值-效果图"></p><h2 id="根据结点的值查找结点位置"><a href="#根据结点的值查找结点位置" class="headerlink" title="根据结点的值查找结点位置"></a>根据结点的值查找结点位置</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*根据结点的值查找结点位置*&#x2F;void checkNode(Node* head)&#123;if (head-&gt;next &#x3D;&#x3D; NULL)printf(&quot;链表为空\n&quot;);else&#123;Node* p1;int val, now_pos &#x3D; 1;printf(&quot;请输入要查询的值：\n&quot;);(void)scanf(&quot;%d&quot;, &amp;val);p1 &#x3D; head-&gt;next;while ((p1-&gt;data !&#x3D; val) &amp;&amp; (p1-&gt;next !&#x3D; NULL))&#123;now_pos++;p1 &#x3D; p1-&gt;next;&#125;if (p1-&gt;data &#x3D;&#x3D; val)printf(&quot;位置为：%d\n&quot;, now_pos);elseprintf(&quot;未找到\n&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/10/6.jpg" alt="根据结点的值查找结点位置-效果图"></p><h2 id="根据结点的位置查找结点的值"><a href="#根据结点的位置查找结点的值" class="headerlink" title="根据结点的位置查找结点的值"></a>根据结点的位置查找结点的值</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*根据结点的位置查找结点的值*&#x2F;void checkNode_pos(Node* head)&#123;if (head-&gt;next &#x3D;&#x3D; NULL)printf(&quot;链表为空\n&quot;);else&#123;Node* p1;int pos, now_pos &#x3D; 1;printf(&quot;请输入要查询的位置：\n&quot;);(void)scanf(&quot;%d&quot;, &amp;pos);p1 &#x3D; head-&gt;next;while ((now_pos !&#x3D; pos) &amp;&amp; (p1-&gt;next !&#x3D; NULL))&#123;p1 &#x3D; p1-&gt;next;now_pos++;&#125;if (now_pos &#x3D;&#x3D; pos)printf(&quot;结点值为：%d\n&quot;, p1-&gt;data);elseprintf(&quot;未找到\n&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/10/7.jpg" alt="根据结点的位置查找结点的值-效果图"></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#include &lt;stdlib.h&gt;struct Node&#123;int data;struct Node* next;&#125;;typedef struct Node Node;&#x2F;*创建链表*&#x2F;Node* createNode()&#123;&#x2F;* head,tail分别指向链表的头结点和尾结点*&#x2F;Node* head, * tail, * p;int num;head &#x3D; (Node*)malloc(sizeof(Node));tail &#x3D; head;printf(&quot;请输入一组数据，结尾使用&#39;-9999&#39;\n&quot;);(void)scanf(&quot;%d&quot;, &amp;num);while (num !&#x3D; -9999)&#123;p &#x3D; (Node*)malloc(sizeof(Node));    &#x2F;*申请内存*&#x2F;&#x2F;&#x2F;if (p &#x3D;&#x3D; NULL)&#x2F;&#x2F;exit(0);p-&gt;data &#x3D; num;tail-&gt;next &#x3D; p;tail &#x3D; p;(void)scanf(&quot;%d&quot;, &amp;num);&#125;tail-&gt;next &#x3D; NULL;return head;&#125;&#x2F;*打印链表*&#x2F;void displayNode(Node* head)&#123;if (head-&gt;next &#x3D;&#x3D; NULL)printf(&quot;链表为空\n&quot;);else&#123;Node* p;p &#x3D; head-&gt;next;    &#x2F;*从首结点开始*&#x2F;printf(&quot;链表如下\n&quot;);while (p !&#x3D; NULL)&#123;printf(&quot;%d    &quot;, p-&gt;data);p &#x3D; p-&gt;next;&#125;printf(&quot;\n&quot;);&#125;&#125;&#x2F;*释放链表内存*&#x2F;void releaseNode(Node* head)&#123;Node* p1, * p2;p1 &#x3D; head;while (p1 !&#x3D; NULL)&#123;p2 &#x3D; p1;p1 &#x3D; p1-&gt;next;free(p2);&#125;printf(&quot;链表释放内存成功\n&quot;);&#125;&#x2F;*根据结点的值删除链表中结点*&#x2F;void deleteNode_val(Node* head)&#123;if (head-&gt;next &#x3D;&#x3D; NULL)printf(&quot;链表为空\n&quot;);else&#123;Node* p1, * p2;int num;printf(&quot;请输入要删除的结点数值：\n&quot;);(void)scanf(&quot;%d&quot;, &amp;num);p1 &#x3D; head-&gt;next;    &#x2F;*使用p1逐个寻找数据*&#x2F;p2 &#x3D; NULL;while ((p1-&gt;data !&#x3D; num) &amp;&amp; (p1-&gt;next !&#x3D; NULL))&#123;p2 &#x3D; p1;    &#x2F;*用p2记录p1原来的位置*&#x2F;p1 &#x3D; p1-&gt;next;&#125;if (p1-&gt;data &#x3D;&#x3D; num)&#123;if (p1 &#x3D;&#x3D; head-&gt;next)&#123;head-&gt;next &#x3D; p1-&gt;next;&#125;elsep2-&gt;next &#x3D; p1-&gt;next;   &#x2F;*将p1前一个结点p2直接与p1下一个结点链接*&#x2F;free(p1);printf(&quot;删除成功\n&quot;);&#125;elseprintf(&quot;删除失败\n&quot;);&#125;&#x2F;&#x2F; return head;&#125;&#x2F;*根据结点位置删除结点*&#x2F;void deleteNode_pos(Node* head)&#123;if (head-&gt;next &#x3D;&#x3D; NULL)printf(&quot;链表为空\n&quot;);else&#123;Node* p1, * p2;int  now_pos&#x3D; 1, pos;printf(&quot;请输入要输出结点的位置：\n&quot;);(void)scanf(&quot;%d&quot;, &amp;pos);p1 &#x3D; head-&gt;next;p2 &#x3D; NULL;while ((now_pos !&#x3D; pos) &amp;&amp; (p1-&gt;next !&#x3D; NULL))&#123;p2 &#x3D; p1;p1 &#x3D; p1-&gt;next;now_pos++;&#125;if (now_pos &#x3D;&#x3D; pos)&#123;if (p1 &#x3D;&#x3D; head-&gt;next)head-&gt;next &#x3D; p1-&gt;next;elsep2-&gt;next &#x3D; p1-&gt;next;free(p1);printf(&quot;删除成功\n&quot;);&#125;elseprintf(&quot;删除失败\n&quot;);&#125;&#125;&#x2F;*根据结点位置插入新的结点*&#x2F;void insertNode(Node* head)&#123;if (head-&gt;next !&#x3D; NULL)&#123;int pos, val, now_pos &#x3D; 1;Node* p, * p1, * p2;p &#x3D; (Node*)malloc(sizeof(Node));printf(&quot;请输入要插入的值和位置\n&quot;);(void)scanf(&quot;%d %d&quot;, &amp;val, &amp;pos);p-&gt;data &#x3D; val;p-&gt;next &#x3D; NULL;p1 &#x3D; head-&gt;next;p2 &#x3D; NULL;while ((now_pos !&#x3D; pos) &amp;&amp; (p1 !&#x3D; NULL))&#123;p2 &#x3D; p1;p1 &#x3D; p1-&gt;next;now_pos++;&#125;if (now_pos &#x3D;&#x3D; pos)&#123;if (p1 &#x3D;&#x3D; head-&gt;next)&#123;head-&gt;next &#x3D; p;p-&gt;next &#x3D; p1;&#125;else&#123;p2-&gt;next &#x3D; p;p-&gt;next &#x3D; p1;&#125;printf(&quot;插入成功\n&quot;);&#125;elseprintf(&quot;插入失败\n&quot;);&#125;elseprintf(&quot;链表为空\n&quot;);&#125;&#x2F;*根据结点位置修改结点的值*&#x2F;void changeNode(Node* head)&#123;if (head-&gt;next &#x3D;&#x3D; NULL)printf(&quot;链表为空\n&quot;);else&#123;int now_pos &#x3D; 1, pos, val;Node* p1;printf(&quot;请输入要修改的值和位置\n&quot;);(void)scanf(&quot;%d %d&quot;, &amp;val, &amp;pos);p1 &#x3D; head-&gt;next;while ((now_pos !&#x3D; pos) &amp;&amp; (p1-&gt;next !&#x3D; NULL))&#123;p1 &#x3D; p1-&gt;next;now_pos++;&#125;if (now_pos &#x3D;&#x3D; pos)&#123;p1-&gt;data &#x3D; val;printf(&quot;修改成功\n&quot;);&#125;elseprintf(&quot;修改失败\n&quot;);&#125;&#125;&#x2F;*根据结点的值查找结点位置*&#x2F;void checkNode_val(Node* head)&#123;if (head-&gt;data &#x3D;&#x3D; NULL)printf(&quot;链表为空\n&quot;);else&#123;Node* p1;int val, now_pos &#x3D; 1;printf(&quot;请输入要查询的值：\n&quot;);(void)scanf(&quot;%d&quot;, &amp;val);p1 &#x3D; head-&gt;next;while ((p1-&gt;data !&#x3D; val) &amp;&amp; (p1-&gt;next !&#x3D; NULL))&#123;now_pos++;p1 &#x3D; p1-&gt;next;&#125;if (p1-&gt;data &#x3D;&#x3D; val)printf(&quot;位置为：%d\n&quot;, now_pos);elseprintf(&quot;未找到\n&quot;);&#125;&#125;&#x2F;*根据结点的位置查找结点的值*&#x2F;void checkNode_pos(Node* head)&#123;if (head-&gt;next &#x3D;&#x3D; NULL)printf(&quot;链表为空\n&quot;);else&#123;Node* p1;int pos, now_pos &#x3D; 1;printf(&quot;请输入要查询的位置：\n&quot;);(void)scanf(&quot;%d&quot;, &amp;pos);p1 &#x3D; head-&gt;next;while ((now_pos !&#x3D; pos) &amp;&amp; (p1-&gt;next !&#x3D; NULL))&#123;p1 &#x3D; p1-&gt;next;now_pos++;&#125;if (now_pos &#x3D;&#x3D; pos)printf(&quot;结点值为：%d\n&quot;, p1-&gt;data);elseprintf(&quot;未找到\n&quot;);&#125;&#125;int main()&#123;Node* head;head &#x3D; createNode();    &#x2F;&#x2F; 创建列表displayNode(head);    &#x2F;&#x2F; 打印&#x2F;&#x2F; releaseNode(head);&#x2F;&#x2F; deleteNode_val(head);&#x2F;&#x2F; deleteNode_pos(head);&#x2F;&#x2F; insertNode(head);&#x2F;&#x2F; changeNode(head);&#x2F;&#x2F; checkNode_val(head);checkNode_pos(head);displayNode(head);releaseNode(head);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整理收藏好用的宝藏网站</title>
      <link href="posts/9.html"/>
      <url>posts/9.html</url>
      
        <content type="html"><![CDATA[<h1 id="整理收藏好用的宝藏网站"><a href="#整理收藏好用的宝藏网站" class="headerlink" title="整理收藏好用的宝藏网站"></a>整理收藏好用的宝藏网站</h1><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇博客里面的所有网站均是来源于网络收集，是博主个人看到好玩或者有用的网站才收集的。</p><p>这些网站有些需要科学上网的手段才能进入，所以懂的都懂。</p><p>本篇博客会持续更新的，更新时间可以从博客上方看到。</p><hr><h2 id="推荐网站"><a href="#推荐网站" class="headerlink" title="推荐网站"></a>推荐网站</h2><ul><li><p>壁纸网站：<a href="https://wallhaven.cc/">https://wallhaven.cc/</a></p><p>介绍：这个网站上面有很多精美壁纸。懂的都懂。</p></li><li><p>Al捏人：<a href="https://artbreeder.com/">https://artbreeder.com/</a></p><p>介绍：算是AI合成图片的一种吧，可以随意合成自己想要的图片。可以合成之后用来当头像，毕竟是AI合成的，在一定程度上可以保证“独一无二”的特点。并且合成方向还可以根据自己喜好改变。挺好的。</p></li><li><p>网易见外：<a href="https://jianwai.netease.com/">https://jianwai.netease.com/</a></p><p>介绍：翻译网站。可以把视频翻译。</p></li><li><p>商用图片：<a href="https://www.pexels.com/zh-cn/">https://www.pexels.com/zh-cn/</a></p><p>介绍：顾名思义。免费的商用图片，懂的都懂。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 资源分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习入门笔记</title>
      <link href="posts/8.html"/>
      <url>posts/8.html</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习入门笔记"><a href="#机器学习入门笔记" class="headerlink" title="机器学习入门笔记"></a>机器学习入门笔记</h1><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个是根据“黑马程序员”的一套机器学习课程编写的博客。这篇博客上的案例均为课程里面的，但并没有包含所有案例，只是记录了部分。</p><p><a href="https://www.bilibili.com/video/BV1nt411r7tj">B站视频原地址</a></p><h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><h3 id="Tf-idf文本特征提取"><a href="#Tf-idf文本特征提取" class="headerlink" title="Tf-idf文本特征提取"></a>Tf-idf文本特征提取</h3><h4 id="Tf-idf介绍"><a href="#Tf-idf介绍" class="headerlink" title="Tf-idf介绍"></a>Tf-idf介绍</h4><ul><li><p>TF-IDF的主要思想是：如果<strong>某个词或短语在一篇文章中出现的概率高，并且在其他文章中很少出现</strong>，则认为此词或者短语具有很好的类别区分能力，适合用来分类。</p></li><li><p><strong>TF-IDF作用：用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。</strong></p></li><li><p>词频（term frequency，tf）指的是某一个给定的词语在该文件中出现的频率</p></li><li><p>逆向文档频率（inverse document frequency，idf）是一个词语普遍重要性的度量。某一特定词语的idf，可以<strong>由总文件数目除以包含该词语之文件的数目，再将得到的商取以10为底的对数得到</strong></p></li></ul><p><img src="/posts/8/1.png" alt="tfidf公式"></p><p>最终得出结果可以理解为重要程度。</p><p>注：假如一篇文件的总词语数是100个，而词语”非常”出现了5次，那么”非常”一词在该文件中的词频就是5/100=0.05。而计算文件频率（IDF）的方法是以文件集的文件总数，除以出现”非常”一词的文件数。所以，如果”非常”一词在1,000份文件出现过，而文件总数是10,000,000份的话，其逆向文件频率就是lg（10,000,000 / 1,0000）=3。最后”非常”对于这篇文档的tf-idf的分数为0.05 * 3=0.15</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from sklearn.feature_extraction.text import TfidfVectorizer    # Tf-idf文本特征提取import jieba    # 分词模块def cut_word(text):    &quot;&quot;&quot;    对中文进行分词    &quot;我爱北京天安门&quot;————&gt;&quot;我 爱 北京 天安门&quot;    :param text:    :return: text    &quot;&quot;&quot;    # 用结巴对中文字符串进行分词    text &#x3D; &quot; &quot;.join(list(jieba.cut(text)))    return textdef text_chinese_tfidf_demo():    &quot;&quot;&quot;    对中文进行特征抽取    :return: None    &quot;&quot;&quot;    data &#x3D; [&quot;一种还是一种今天很残酷，明天更残酷，后天很美好，但绝对大部分是死在明天晚上，所以每个人不要放弃今天。&quot;,            &quot;我们看到的从很远星系来的光是在几百万年之前发出的，这样当我们看到宇宙时，我们是在看它的过去。&quot;,            &quot;如果只用一种方式了解某样事物，你就不会真正了解它。了解事物真正含义的秘密取决于如何将其与我们所了解的事物相联系。&quot;]    # 将原始数据转换成分好词的形式    text_list &#x3D; []    for sent in data:        text_list.append(cut_word(sent))    print(text_list)    # 1、实例化一个转换器类    # transfer &#x3D; CountVectorizer(sparse&#x3D;False)    transfer &#x3D; TfidfVectorizer(stop_words&#x3D;[&#39;一种&#39;, &#39;不会&#39;, &#39;不要&#39;])    # 2、调用fit_transform    data &#x3D; transfer.fit_transform(text_list)    print(&quot;文本特征抽取的结果：\n&quot;, data.toarray())    print(&quot;返回特征名字：\n&quot;, transfer.get_feature_names())    return None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Building prefix dict from the default dictionary ...Loading model from cache &#x2F;var&#x2F;folders&#x2F;mz&#x2F;tzf2l3sx4rgg6qpglfb035_r0000gn&#x2F;T&#x2F;jieba.cacheLoading model cost 0.856 seconds.Prefix dict has been built succesfully.[&#39;一种 还是 一种 今天 很 残酷 ， 明天 更 残酷 ， 后天 很 美好 ， 但 绝对 大部分 是 死 在 明天 晚上 ， 所以 每个 人 不要 放弃 今天 。&#39;, &#39;我们 看到 的 从 很 远 星系 来 的 光是在 几百万年 之前 发出 的 ， 这样 当 我们 看到 宇宙 时 ， 我们 是 在 看 它 的 过去 。&#39;, &#39;如果 只用 一种 方式 了解 某样 事物 ， 你 就 不会 真正 了解 它 。 了解 事物 真正 含义 的 秘密 取决于 如何 将 其 与 我们 所 了解 的 事物 相 联系 。&#39;]文本特征抽取的结果： [[ 0.          0.          0.          0.43643578  0.          0.          0.   0.          0.          0.21821789  0.          0.21821789  0.          0.   0.          0.          0.21821789  0.21821789  0.          0.43643578   0.          0.21821789  0.          0.43643578  0.21821789  0.          0.   0.          0.21821789  0.21821789  0.          0.          0.21821789   0.        ] [ 0.2410822   0.          0.          0.          0.2410822   0.2410822   0.2410822   0.          0.          0.          0.          0.          0.   0.          0.2410822   0.55004769  0.          0.          0.          0.   0.2410822   0.          0.          0.          0.          0.48216441   0.          0.          0.          0.          0.          0.2410822   0.          0.2410822 ] [ 0.          0.644003    0.48300225  0.          0.          0.          0.   0.16100075  0.16100075  0.          0.16100075  0.          0.16100075   0.16100075  0.          0.12244522  0.          0.          0.16100075   0.          0.          0.          0.16100075  0.          0.          0.   0.3220015   0.16100075  0.          0.          0.16100075  0.          0.   0.        ]]返回特征名字： [&#39;之前&#39;, &#39;了解&#39;, &#39;事物&#39;, &#39;今天&#39;, &#39;光是在&#39;, &#39;几百万年&#39;, &#39;发出&#39;, &#39;取决于&#39;, &#39;只用&#39;, &#39;后天&#39;, &#39;含义&#39;, &#39;大部分&#39;, &#39;如何&#39;, &#39;如果&#39;, &#39;宇宙&#39;, &#39;我们&#39;, &#39;所以&#39;, &#39;放弃&#39;, &#39;方式&#39;, &#39;明天&#39;, &#39;星系&#39;, &#39;晚上&#39;, &#39;某样&#39;, &#39;残酷&#39;, &#39;每个&#39;, &#39;看到&#39;, &#39;真正&#39;, &#39;秘密&#39;, &#39;绝对&#39;, &#39;美好&#39;, &#39;联系&#39;, &#39;过去&#39;, &#39;还是&#39;, &#39;这样&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Tf-idf的重要性"><a href="#Tf-idf的重要性" class="headerlink" title="Tf-idf的重要性"></a>Tf-idf的重要性</h4><p><strong>分类机器学习算法进行文章分类中前期数据处理方式</strong></p><h3 id="无量纲化处理—标准化"><a href="#无量纲化处理—标准化" class="headerlink" title="无量纲化处理—标准化"></a>无量纲化处理—标准化</h3><p><strong>注意：无量纲化包括归一化和标准化，因为经常使用标准化所以这里只介绍标准化。</strong></p><h4 id="为什么我们要进行标准化？"><a href="#为什么我们要进行标准化？" class="headerlink" title="为什么我们要进行标准化？"></a>为什么我们要进行标准化？</h4><ul><li>特征的<strong>单位或者大小相差较大，或者某特征的方差相比其他的特征要大出几个数量级</strong>，<strong>容易影响（支配）目标结果</strong>，使得一些算法无法学习到其它的特征</li></ul><p><img src="/posts/8/2.png" alt="约会对象数据"></p><p>我们需要用到一些方法进行<strong>无量纲化</strong>，<strong>使不同规格的数据转换到同一规格</strong></p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>通过对原始数据进行变换把数据变换到均值为0,标准差为1范围内</li></ul><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><ul><li>sklearn.preprocessing.StandardScaler( )<ul><li>处理之后每列来说所有数据都聚集在均值0附近标准差差为1</li><li>StandardScaler.fit_transform(X)<ul><li>X:numpy array格式的数据[n_samples,n_features]</li></ul></li><li>返回值：转换后的形状相同的array</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pandas as pdfrom sklearn.preprocessing import StandardScaler    # 标准化def stand_demo():    &quot;&quot;&quot;    标准化演示    :return: None    &quot;&quot;&quot;    data &#x3D; pd.read_csv(&quot;dating.txt&quot;)    print(data)    # 1、实例化一个转换器类    transfer &#x3D; StandardScaler()    # 2、调用fit_transform    data &#x3D; transfer.fit_transform(data[[&#39;milage&#39;,&#39;Liters&#39;,&#39;Consumtime&#39;]])    print(&quot;标准化的结果:\n&quot;, data)    print(&quot;每一列特征的平均值：\n&quot;, transfer.mean_)    print(&quot;每一列特征的方差：\n&quot;, transfer.var_)    return None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">     milage     Liters  Consumtime  target0     40920   8.326976    0.953952       31     14488   7.153469    1.673904       22     26052   1.441871    0.805124       1..      ...        ...         ...     ...997   26575  10.650102    0.866627       3998   48111   9.134528    0.728045       3999   43757   7.882601    1.332446       3[1000 rows x 4 columns]标准化的结果: [[ 0.33193158  0.41660188  0.24523407] [-0.87247784  0.13992897  1.69385734] [-0.34554872 -1.20667094 -0.05422437] ...,  [-0.32171752  0.96431572  0.06952649] [ 0.65959911  0.60699509 -0.20931587] [ 0.46120328  0.31183342  1.00680598]]每一列特征的平均值： [  3.36354210e+04   6.55996083e+00   8.32072997e-01]每一列特征的方差： [  4.81628039e+08   1.79902874e+01   2.46999554e-01]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="标准化总结"><a href="#标准化总结" class="headerlink" title="标准化总结"></a>标准化总结</h4><p>在已有样本足够多的情况下比较稳定，适合现代嘈杂大数据场景。</p><h2 id="PCA降维"><a href="#PCA降维" class="headerlink" title="PCA降维"></a>PCA降维</h2><h4 id="什么是主成分分析-PCA"><a href="#什么是主成分分析-PCA" class="headerlink" title="什么是主成分分析(PCA)"></a>什么是主成分分析(PCA)</h4><ul><li>定义：<strong>高维数据转化为低维数据的过程</strong>，在此过程中<strong>可能会舍弃原有数据、创造新的变量</strong></li><li>作用：<strong>是数据维数压缩，尽可能降低原数据的维数（复杂度），损失少量信息。</strong></li><li>应用：回归分析或者聚类分析当中</li></ul><blockquote><p>对于信息一词，在决策树中会进行介绍</p></blockquote><p>那么更好的理解这个过程呢？我们来看一张图</p><p><img src="/posts/8/3.png" alt="PCA解释图"></p><h4 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h4><ul><li>sklearn.decomposition.PCA(n_components=None)<ul><li>将数据分解为较低维数空间</li><li>n_components:<ul><li><strong>小数：表示保留百分之多少的信息</strong></li><li><strong>整数：减少到多少特征</strong></li></ul></li><li>PCA.fit_transform(X) X:numpy array格式的数据[n_samples,n_features]</li><li>返回值：转换后指定维度的array</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">from sklearn.decomposition import PCA    # PCAdef pca_demo():    &quot;&quot;&quot;    对数据进行PCA降维    :return: None    &quot;&quot;&quot;    data &#x3D; [[2,8,4,5], [6,3,0,8], [5,4,9,1]]    # 1、实例化PCA, 小数——保留多少信息    transfer &#x3D; PCA(n_components&#x3D;0.9)    # 2、调用fit_transform    data1 &#x3D; transfer.fit_transform(data)    print(&quot;保留90%的信息，降维结果为：\n&quot;, data1)    # 1、实例化PCA, 整数——指定降维到的维数    transfer2 &#x3D; PCA(n_components&#x3D;3)    # 2、调用fit_transform    data2 &#x3D; transfer2.fit_transform(data)    print(&quot;降维到3维的结果：\n&quot;, data2)    return None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">保留90%的信息，降维结果为： [[ -3.13587302e-16   3.82970843e+00] [ -5.74456265e+00  -1.91485422e+00] [  5.74456265e+00  -1.91485422e+00]]降维到3维的结果： [[ -3.13587302e-16   3.82970843e+00   4.59544715e-16] [ -5.74456265e+00  -1.91485422e+00   4.59544715e-16] [  5.74456265e+00  -1.91485422e+00   4.59544715e-16]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分类算法"><a href="#分类算法" class="headerlink" title="分类算法"></a>分类算法</h2><h3 id="数据集划分"><a href="#数据集划分" class="headerlink" title="数据集划分"></a>数据集划分</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>机器学习一般的数据集会划分为两个部分：</p><ul><li>训练数据：用于训练，构建模型</li><li>测试数据：在模型检验时使用，用于评估模型是否有效</li></ul><p>划分比例：</p><ul><li>训练集：70% 80% 75%</li><li>测试集：30% 20% 30%</li></ul><h4 id="API-2"><a href="#API-2" class="headerlink" title="API"></a>API</h4><ul><li>sklearn.model_selection.train_test_split(arrays, *options)<ul><li>x 数据集的特征值</li><li>y 数据集的标签值</li><li>test_size 测试集的大小，一般为float</li><li>random_state 随机数种子,不同的种子会造成不同的随机采样结果。相同的种子采样结果相同。</li><li>return ，测试集特征训练集特征值值，训练标签，测试标签(默认随机取)</li></ul></li></ul><p>结合后面的数据集作介绍</p><h3 id="K-近邻算法"><a href="#K-近邻算法" class="headerlink" title="K-近邻算法"></a>K-近邻算法</h3><h4 id="K-近邻算法定义"><a href="#K-近邻算法定义" class="headerlink" title="K-近邻算法定义"></a>K-近邻算法定义</h4><ul><li>如果一个样本在特征空间中的<strong>k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别</strong>，则该样本也属于这个类别。</li></ul><h4 id="距离公式"><a href="#距离公式" class="headerlink" title="距离公式"></a>距离公式</h4><ul><li>两个样本的距离可以通过如下公式计算，又叫欧式距离</li></ul><p><img src="/posts/8/4.png" alt="距离公式"></p><h4 id="API-3"><a href="#API-3" class="headerlink" title="API"></a>API</h4><p>sklearn.neighbors.KNeighborsClassifier(n_neighbors=5,algorithm=’auto’)</p><ul><li>n_neighbors：int,可选（默认= 5），k_neighbors查询默认使用的邻居数</li><li>algorithm：{‘auto’，‘ball_tree’，‘kd_tree’，‘brute’}，可选用于计算最近邻居的算法：‘ball_tree’将会使用 BallTree，‘kd_tree’将使用 KDTree。‘auto’将尝试根据传递给fit方法的值来决定最合适的算法。 (不同实现方式影响效率)<pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;1. 获取数据2. 数据集划分3. 特征工程---标准化4. KNN预估器流程5. 模型评估&quot;&quot;&quot;from sklearn.datasets import load_iris    # 数据集from sklearn.model_selection import train_test_split    # 数据集划分from sklearn.preprocessing import StandardScaler    # 标准化from sklearn.neighbors import KNeighborsClassifier    # KNN算法def knn_iris():    &quot;&quot;&quot;    用KNN算法对鸢尾花进行分类    &quot;&quot;&quot;    # 1. 获取数据    iris &#x3D; load_iris()    # 2. 数据集划分    &quot;&quot;&quot;    x是特征值 y是目标值    训练集的特征值x_train 测试集的特征值x_test 训练集的目标值y_train 测试集的目标值y_test    &quot;&quot;&quot;    # random_state 随机数种子,不同的种子会造成不同的随机采样结果。相同的种子采样结果相同。    x_train, x_test, y_train, y_test &#x3D; train_test_split(        iris.data, iris.target, random_state&#x3D;6)    # 3. 特征工程---标准化    # 训练集和测试集都要进行标准化    transfer &#x3D; StandardScaler()    # 训练集标准化    x_train &#x3D; transfer.fit_transform(x_train)    # 测试集标准化    注意与训练集标准化的区分    x_test &#x3D; transfer.transform(x_test)    # 4. KNN预估器流程    # n_neighbors就是k值    estimator &#x3D; KNeighborsClassifier(n_neighbors&#x3D;3)    estimator.fit(x_train, y_train)    # 5. 模型评估    # 方法1：直接比对真实值和预测值    y_predict &#x3D; estimator.predict(x_test)    print(&quot;y_predict:\n&quot;, y_predict)    print(&quot;直接比对真实值和预测值:\n&quot;, y_test &#x3D;&#x3D; y_predict)    # 方法2：计算准确率    score &#x3D; estimator.score(x_test, y_test)    print(&quot;准确率为：\n&quot;, score)    return Noneif __name__ &#x3D;&#x3D; &quot;__main__&quot;:    knn_iris()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>结果：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">y_predict: [0 2 0 0 2 1 1 0 2 1 2 1 2 2 1 1 2 1 1 0 0 2 0 0 1 1 1 2 0 1 0 1 0 0 1 2 1 2]直接比对真实值和预测值: [ True  True  True  True  True  True False  True  True  True  True  True  True  True  True False  True  True  True  True  True  True  True  True  True  True  True  True  True  True  True  True  True  True False  True  True  True]准确率为： 0.9210526315789473<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="模型选择与调优"><a href="#模型选择与调优" class="headerlink" title="模型选择与调优"></a>模型选择与调优</h3><p>模型选择与调优这里有”交叉验证“和”超参数搜索（网格搜索）“两种，通过调用sklearn中的函数可以直接同时实现这两种功能。</p><h4 id="API-4"><a href="#API-4" class="headerlink" title="API"></a>API</h4><ul><li>sklearn.model_selection.GridSearchCV(estimator, param_grid=None,cv=None)<ul><li>对估计器的指定参数值进行详尽搜索</li><li>estimator：估计器对象</li><li>param_grid：估计器参数(dict){“n_neighbors”:[1,3,5]}</li><li>cv：指定几折交叉验证</li><li></li><li>fit：输入训练数据</li><li>score：准确率</li><li>结果分析：<ul><li>best<em>score</em>:在交叉验证中验证的最好结果_</li><li>best<em>estimator</em>：最好的参数模型</li><li>cv<em>results</em>:每次交叉验证后的验证集准确率结果和训练集准确率结果</li></ul></li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;1. 获取数据2. 数据集划分3. 特征工程---标准化4. KNN预估器流程5. 模型评估&quot;&quot;&quot;from sklearn.datasets import load_iris    # 数据集from sklearn.model_selection import train_test_split    # 数据集划分from sklearn.preprocessing import StandardScaler    # 标准化from sklearn.neighbors import KNeighborsClassifier    # KNN算法from sklearn.model_selection import GridSearchCV    # 模型优化def knn_iris_gscv():    &quot;&quot;&quot;    用KNN算法对鸢尾花进行分类    使用交叉验证和网格搜索进行模型优化与调优    &quot;&quot;&quot;    iris &#x3D; load_iris()    x_train, x_test, y_train, y_test &#x3D; train_test_split(        iris.data, iris.target, random_state&#x3D;6)    transfer &#x3D; StandardScaler()    x_train &#x3D; transfer.fit_transform(x_train)    x_test &#x3D; transfer.transform(x_test)    estimator &#x3D; KNeighborsClassifier()    # 加入网格搜索与交叉验证    param_dict &#x3D; &#123;&quot;n_neighbors&quot;: [1, 3, 5, 7, 9, 11]&#125;    # param_grid：估计器参数(dict) 例如：&#123;“n_neighbors”:[1,3,5]&#125;    # cv：指定几折交叉验证    estimator &#x3D; GridSearchCV(estimator, param_grid&#x3D;param_dict, cv&#x3D;10)    estimator.fit(x_train, y_train)    # 模型评估    # 方法1：直接比对真实值和预测值    y_predict &#x3D; estimator.predict(x_test)    print(&quot;y_predict:\n&quot;, y_predict)    print(&quot;直接比对真实值和预测值:\n&quot;, y_test &#x3D;&#x3D; y_predict)    # 方法2：计算准确率    score &#x3D; estimator.score(x_test, y_test)    print(&quot;准确率为：\n&quot;, score)    # 最佳参数：best_params_    print(&quot;最佳参数：\n&quot;, estimator.best_params_)    # 最佳结果：best_score_    print(&quot;最佳结果：\n&quot;, estimator.best_score_)    # 最佳估计器：best_estimator_    print(&quot;最佳估计器:\n&quot;, estimator.best_estimator_)    # 交叉验证结果：cv_results_    print(&quot;交叉验证结果:\n&quot;, estimator.cv_results_)    return Noneif __name__ &#x3D;&#x3D; &quot;__main__&quot;:    knn_iris_gscv()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">y_predict: [0 2 0 0 2 1 2 0 2 1 2 1 2 2 1 1 2 1 1 0 0 2 0 0 1 1 1 2 0 1 0 1 0 0 1 2 1 2]直接比对真实值和预测值: [ True  True  True  True  True  True  True  True  True  True  True  True  True  True  True False  True  True  True  True  True  True  True  True  True  True  True  True  True  True  True  True  True  True False  True  True  True]准确率为： 0.9473684210526315最佳参数： &#123;&#39;n_neighbors&#39;: 11&#125;最佳结果： 0.9734848484848484最佳估计器: KNeighborsClassifier(n_neighbors&#x3D;11)交叉验证结果: &#123;&#39;mean_fit_time&#39;: array([0.00069556, 0.00049865, 0.0005944 , 0.00069988, 0.00059845,       0.0003933 ]), &#39;std_fit_time&#39;: array([0.00045544, 0.00049865, 0.00048581, 0.00045873, 0.00048918,       0.00048186]), &#39;mean_score_time&#39;: array([0.00119884, 0.00119665, 0.00120168, 0.00109487, 0.0012959 ,       0.00129161]), &#39;std_score_time&#39;: array([0.00039571, 0.00039928, 0.00038471, 0.00030016, 0.00044617,       0.00045765]), &#39;param_n_neighbors&#39;: masked_array(data&#x3D;[1, 3, 5, 7, 9, 11],             mask&#x3D;[False, False, False, False, False, False],       fill_value&#x3D;&#39;?&#39;,            dtype&#x3D;object), &#39;params&#39;: [&#123;&#39;n_neighbors&#39;: 1&#125;, &#123;&#39;n_neighbors&#39;: 3&#125;, &#123;&#39;n_neighbors&#39;: 5&#125;, &#123;&#39;n_neighbors&#39;: 7&#125;, &#123;&#39;n_neighbors&#39;: 9&#125;, &#123;&#39;n_neighbors&#39;: 11&#125;], &#39;split0_test_score&#39;: array([1., 1., 1., 1., 1., 1.]), &#39;split1_test_score&#39;: array([0.91666667, 0.91666667, 1.        , 0.91666667, 0.91666667,       0.91666667]), &#39;split2_test_score&#39;: array([1., 1., 1., 1., 1., 1.]), &#39;split3_test_score&#39;: array([1.        , 1.        , 1.        , 1.        , 0.90909091,       1.        ]), &#39;split4_test_score&#39;: array([1., 1., 1., 1., 1., 1.]), &#39;split5_test_score&#39;: array([0.90909091, 0.90909091, 1.        , 1.        , 1.        ,       1.        ]), &#39;split6_test_score&#39;: array([1., 1., 1., 1., 1., 1.]), &#39;split7_test_score&#39;: array([0.90909091, 0.90909091, 0.90909091, 0.90909091, 1.        ,       1.        ]), &#39;split8_test_score&#39;: array([1., 1., 1., 1., 1., 1.]), &#39;split9_test_score&#39;: array([0.90909091, 0.81818182, 0.81818182, 0.81818182, 0.81818182,       0.81818182]), &#39;mean_test_score&#39;: array([0.96439394, 0.95530303, 0.97272727, 0.96439394, 0.96439394,       0.97348485]), &#39;std_test_score&#39;: array([0.04365767, 0.0604591 , 0.05821022, 0.05965639, 0.05965639,       0.05742104]), &#39;rank_test_score&#39;: array([5, 6, 2, 3, 3, 1])&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与不使用模型优化的KNN算法相对比，可以发现使用模型优化的KNN算法的结果更好。</p><h3 id="朴素贝叶斯算法"><a href="#朴素贝叶斯算法" class="headerlink" title="朴素贝叶斯算法"></a>朴素贝叶斯算法</h3><p>朴素贝叶斯算法多用于文本分类。</p><h4 id="API-5"><a href="#API-5" class="headerlink" title="API"></a>API</h4><ul><li>sklearn.naive_bayes.MultinomialNB(alpha = 1.0)<ul><li>朴素贝叶斯分类</li><li>alpha：拉普拉斯平滑系数</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;朴素贝叶斯算法应用场景：文本分类  单词作为特征优点：    对缺失数据不太敏感，算法也比较简单，常用于文本分类。    分类准确度高，速度快缺点：    由于使用了样本属性独立性的假设，所以如果特征属性有关联时其效果不好&quot;&quot;&quot;from sklearn.datasets import fetch_20newsgroups    # 获取数据集from sklearn.model_selection import train_test_split    # 数据集划分from sklearn.model_selection import GridSearchCV    # 模型优化from sklearn.naive_bayes import MultinomialNB    # 朴素贝叶斯from sklearn.feature_extraction.text import TfidfVectorizer    # 文本特征抽取def nb_news():    # 1. 获取数据    news &#x3D; fetch_20newsgroups(subset&#x3D;&quot;all&quot;)    # 2.划分数据集    x_train, x_test, y_train, y_test &#x3D; train_test_split(news.data, news.target)    transfer &#x3D; TfidfVectorizer()    # 标准化    x_train &#x3D; transfer.fit_transform(x_train)    x_test &#x3D; transfer.transform(x_test)    estimator &#x3D; MultinomialNB()    # 模型优化    param_dict &#x3D; &#123;&quot;alpha&quot;: [1, 3, 5, 7, 9, 11]&#125;    estimator &#x3D; GridSearchCV(estimator, param_grid&#x3D;param_dict, cv&#x3D;10)    estimator.fit(x_train, y_train)    # 5. 模型评估    # 方法1：直接比对真实值和预测值    y_predict &#x3D; estimator.predict(x_test)    print(&quot;y_predict:\n&quot;, y_predict)    print(&quot;直接比对真实值和预测值:\n&quot;, y_test &#x3D;&#x3D; y_predict)    # 方法2：计算准确率    score &#x3D; estimator.score(x_test, y_test)    print(&quot;准确率为：\n&quot;, score)    return Noneif __name__ &#x3D;&#x3D; &quot;__main__&quot;:    nb_news()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">y_predict: [ 9  4 17 ...  8  2  0]直接比对真实值和预测值: [ True  True  True ...  True  True  True]准确率为： 0.8548387096774194<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><h4 id="API-6"><a href="#API-6" class="headerlink" title="API"></a>API</h4><ul><li>class sklearn.tree.DecisionTreeClassifier(criterion=’gini’, max_depth=None,random_state=None)<ul><li>决策树分类器</li><li>criterion:默认是’gini’系数，也可以选择信息增益的熵’entropy’</li><li>max_depth:树的深度大小</li><li>random_state:随机数种子</li></ul></li><li>其中会有些超参数：max_depth:树的深度大小<ul><li>其它超参数我们会结合随机森林讲解</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">from sklearn.datasets import load_iris    # 数据集from sklearn.model_selection import train_test_split    # 数据集划分from sklearn.tree import DecisionTreeClassifier    # 决策树def decision_iris():    &quot;&quot;&quot;    用决策树对鸢尾花进行分类    优点：可视化 - 可解释能力强    缺点：如果数据很多还不设置树的深度这样可能会产生过拟合。    &quot;&quot;&quot;    # 1. 获取数据集    iris &#x3D; load_iris()    # 2. 划分数据集    x_train, x_test, y_train, y_test &#x3D; train_test_split(iris.data, iris.target)    # 3. 决策树预估器    # 参数max_depth:树的深度大小 如果数据集大则树的深度也大这样可能会导致准确率降低    # 所以如果有必要的话可以设置树的深度来提高准确率    estimator &#x3D; DecisionTreeClassifier(criterion&#x3D;&quot;entropy&quot;)    estimator.fit(x_train, y_train)    # 4. 模型评估    # 方法1：直接比对真实值和预测值    y_predict &#x3D; estimator.predict(x_test)    print(&quot;y_predict:\n&quot;, y_predict)    print(&quot;直接比对真实值和预测值:\n&quot;, y_test &#x3D;&#x3D; y_predict)    # 方法2：计算准确率    score &#x3D; estimator.score(x_test, y_test)    print(&quot;准确率为：\n&quot;, score)    return Noneif __name__ &#x3D;&#x3D; &quot;__main__&quot;:    decision_iris()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">y_predict: [0 2 1 0 1 0 0 0 2 1 2 1 2 2 1 1 1 0 0 1 2 2 0 0 2 1 0 2 1 2 1 0 1 1 0 1 1 1]直接比对真实值和预测值: [ True  True  True  True  True  True  True  True  True  True  True  True  True  True  True False  True  True  True False  True  True  True  True  True  True  True  True False False  True  True  True  True  True False  True  True]准确率为： 0.868421052631579<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><h4 id="随机森林原理过程"><a href="#随机森林原理过程" class="headerlink" title="随机森林原理过程"></a>随机森林原理过程</h4><p>学习算法根据下列算法而建造每棵树：</p><ul><li>用N来表示训练用例（样本）的个数，M表示特征数目。<ul><li>1、一次随机选出一个样本，重复N次， （有可能出现重复的样本）</li><li>2、随机去选出m个特征, m &lt;&lt;M，建立决策树</li></ul></li><li>采取bootstrap抽样</li></ul><h4 id="为什么采用BootStrap抽样"><a href="#为什么采用BootStrap抽样" class="headerlink" title="为什么采用BootStrap抽样"></a>为什么采用BootStrap抽样</h4><ul><li>为什么要随机抽样训练集？　　<ul><li>如果不进行随机抽样，每棵树的训练集都一样，那么最终训练出的树分类结果也是完全一样的</li></ul></li><li>为什么要有放回地抽样？<ul><li>如果不是有放回的抽样，那么每棵树的训练样本都是不同的，都是没有交集的，这样每棵树都是“有偏的”，都是绝对“片面的”（当然这样说可能不对），也就是说每棵树训练出来都是有很大的差异的；而随机森林最后分类取决于多棵树（弱分类器）的投票表决。</li></ul></li></ul><h4 id="API-7"><a href="#API-7" class="headerlink" title="API"></a>API</h4><ul><li><p>class sklearn.ensemble.RandomForestClassifier(n_estimators=10, criterion=’gini’, max_depth=None, bootstrap=True, random_state=None, min_samples_split=2)</p><ul><li>随机森林分类器</li><li>n_estimators：integer，optional（default = 10）森林里的树木数量120,200,300,500,800,1200</li><li>criteria：string，可选（default =“gini”）分割特征的测量方法</li><li>max_depth：integer或None，可选（默认=无）树的最大深度 5,8,15,25,30</li><li>max_features=”auto”,每个决策树的最大特征数量<ul><li>If “auto”, then <code>max_features=sqrt(n_features)</code>.</li><li>If “sqrt”, then <code>max_features=sqrt(n_features)</code> (same as “auto”).</li><li>If “log2”, then <code>max_features=log2(n_features)</code>.</li><li>If None, then <code>max_features=n_features</code>.</li></ul></li><li>bootstrap：boolean，optional（default = True）是否在构建树时使用放回抽样</li><li>min_samples_split:节点划分最少样本数</li><li>min_samples_leaf:叶子节点的最小样本数</li></ul></li><li><p>超参数：n_estimator, max_depth, min_samples_split,min_samples_leaf</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">from sklearn.datasets import load_iris    # 数据集from sklearn.model_selection import train_test_split    # 数据集划分from sklearn.ensemble import RandomForestClassifier    # 随机森林from sklearn.model_selection import GridSearchCV    # 模型优化def iris_demo():    # 加载数据集    iris &#x3D; load_iris()    # 数据集划分    x_train, x_test, y_train, y_test &#x3D; train_test_split(iris.data, iris.target)    # 随机森林    estimator &#x3D; RandomForestClassifier()    # 网格化搜索    param_dict &#x3D; &#123;&quot;n_estimators&quot;: [10, 20, 30, 40, 50, 100]&#125;    estimator &#x3D; GridSearchCV(estimator, param_grid&#x3D;param_dict, cv&#x3D;10)    # 训练    estimator.fit(x_train, y_train)    # 模型评估    # 方法1：直接比对真实值和预测值    y_predict &#x3D; estimator.predict(x_test)    print(&quot;y_predict:\n&quot;, y_predict)    print(&quot;直接比对真实值和预测值:\n&quot;, y_test &#x3D;&#x3D; y_predict)    # 方法2：计算准确率    score &#x3D; estimator.score(x_test, y_test)    print(&quot;准确率为：\n&quot;, score)    # 最佳参数：best_params_    print(&quot;最佳参数：\n&quot;, estimator.best_params_)    # 最佳结果：best_score_    print(&quot;最佳结果：\n&quot;, estimator.best_score_)    # 最佳估计器：best_estimator_    print(&quot;最佳估计器:\n&quot;, estimator.best_estimator_)    # 交叉验证结果：cv_results_    print(&quot;交叉验证结果:\n&quot;, estimator.cv_results_)    return Noneif __name__ &#x3D;&#x3D; &quot;__main__&quot;:    iris_demo()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">y_predict: [0 1 2 2 1 2 2 1 2 2 0 0 0 0 0 0 1 2 0 2 1 2 2 0 0 0 1 2 2 2 1 1 1 1 0 2 1 2]直接比对真实值和预测值: [ True  True  True  True  True  True  True  True  True  True  True  True    True  True  True  True  True  True  True  True  True  True  True  True     True  True  True  True  True  True False  True  True  True  True  True     True  True]准确率为： 0.9736842105263158最佳参数： &#123;&#39;n_estimators&#39;: 30&#125;最佳结果： 0.9553030303030303最佳估计器: RandomForestClassifier(n_estimators&#x3D;30)交叉验证结果: &#123;&#39;mean_fit_time&#39;: array([0.01545861, 0.0299505 , 0.04111712, 0.05707047, 0.06866693,       0.145067  ]), &#39;std_fit_time&#39;: array([0.00215007, 0.00540963, 0.00032881, 0.00359371, 0.00326092,       0.0084516 ]), &#39;mean_score_time&#39;: array([0.00159588, 0.0027936 , 0.00379615, 0.00488796, 0.00544808,       0.01146989]), &#39;std_score_time&#39;: array([0.00048815, 0.00040718, 0.00039285, 0.00054974, 0.00046851,       0.00091972]), &#39;param_n_estimators&#39;: masked_array(data&#x3D;[10, 20, 30, 40, 50, 100],             mask&#x3D;[False, False, False, False, False, False],       fill_value&#x3D;&#39;?&#39;,            dtype&#x3D;object), &#39;params&#39;: [&#123;&#39;n_estimators&#39;: 10&#125;, &#123;&#39;n_estimators&#39;: 20&#125;, &#123;&#39;n_estimators&#39;: 30&#125;, &#123;&#39;n_estimators&#39;: 40&#125;, &#123;&#39;n_estimators&#39;: 50&#125;, &#123;&#39;n_estimators&#39;: 100&#125;], &#39;split0_test_score&#39;: array([0.91666667, 0.91666667, 0.91666667, 0.91666667, 0.91666667,       0.91666667]), &#39;split1_test_score&#39;: array([1., 1., 1., 1., 1., 1.]), &#39;split2_test_score&#39;: array([0.90909091, 1.        , 1.        , 1.        , 1.        ,       1.        ]), &#39;split3_test_score&#39;: array([0.90909091, 0.90909091, 0.90909091, 0.90909091, 0.90909091,       0.90909091]), &#39;split4_test_score&#39;: array([0.81818182, 0.81818182, 0.81818182, 0.81818182, 0.81818182,       0.81818182]), &#39;split5_test_score&#39;: array([1., 1., 1., 1., 1., 1.]), &#39;split6_test_score&#39;: array([1., 1., 1., 1., 1., 1.]), &#39;split7_test_score&#39;: array([0.90909091, 0.90909091, 1.        , 0.90909091, 1.        ,       1.        ]), &#39;split8_test_score&#39;: array([1.        , 0.90909091, 1.        , 0.90909091, 1.        ,       1.        ]), &#39;split9_test_score&#39;: array([0.90909091, 0.90909091, 0.90909091, 0.90909091, 0.90909091,       0.90909091]), &#39;mean_test_score&#39;: array([0.93712121, 0.93712121, 0.95530303, 0.93712121, 0.95530303,       0.95530303]), &#39;std_test_score&#39;: array([0.05789881, 0.05789881, 0.0604591 , 0.05789881, 0.0604591 ,       0.0604591 ]), &#39;rank_test_score&#39;: array([4, 4, 1, 4, 1, 1])&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>在当前所有算法中，具有极好的准确率</li><li>能够有效地运行在大数据集上，处理具有高维特征的输入样本，而且不需要降维</li><li>能够评估各个特征在分类问题上的重要性</li></ul><h2 id="回归与聚类算法"><a href="#回归与聚类算法" class="headerlink" title="回归与聚类算法"></a>回归与聚类算法</h2><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><h4 id="线性回归API"><a href="#线性回归API" class="headerlink" title="线性回归API"></a>线性回归API</h4><ul><li>sklearn.linear_model.LinearRegression(fit_intercept=True)<ul><li>通过正规方程优化</li><li>fit_intercept：是否计算偏置</li><li>LinearRegression.coef_：回归系数</li><li>LinearRegression.intercept_：偏置</li></ul></li><li>sklearn.linear_model.SGDRegressor(loss=”squared_loss”, fit_intercept=True, learning_rate =’invscaling’, eta0=0.01)<ul><li>SGDRegressor类实现了随机梯度下降学习，它支持不同的<strong>loss函数和正则化惩罚项</strong>来拟合线性回归模型。</li><li>loss:损失类型<ul><li><strong>loss=”squared_loss”: 普通最小二乘法</strong></li></ul></li><li>fit_intercept：是否计算偏置</li><li>learning_rate : string, optional<ul><li>学习率填充</li><li><strong>‘constant’: eta = eta0</strong></li><li><strong>‘optimal’: eta = 1.0 / (alpha * (t + t0)) [default]</strong></li><li>‘invscaling’: eta = eta0 / pow(t, power_t)<ul><li><strong>power_t=0.25:存在父类当中</strong></li></ul></li><li><strong>对于一个常数值的学习率来说，可以使用learning_rate=’constant’ ，并使用eta0来指定学习率。</strong></li></ul></li><li>SGDRegressor.coef_：回归系数</li><li>SGDRegressor.intercept_：偏置</li></ul></li></ul><blockquote><p>sklearn提供给我们两种实现的API， 可以根据选择使用</p></blockquote><h4 id="回归性能评估"><a href="#回归性能评估" class="headerlink" title="回归性能评估"></a>回归性能评估</h4><p>sklearn.metrics.mean_squared_error(y_true, y_pred)</p><ul><li>均方误差回归损失</li><li>y_true:真实值</li><li>y_pred:预测值</li><li>return:浮点数结果</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">from sklearn.datasets import load_boston    # 加载数据集from sklearn.model_selection import train_test_split    # 数据集划分from sklearn.preprocessing import StandardScaler    # 特征工程 标准化from sklearn.linear_model import LinearRegression, SGDRegressor    # 正规方程 梯度下降from sklearn.metrics import mean_squared_error    # 回归评估 均方误差（值越小越好）def linear1():    &quot;&quot;&quot;    正规方程的优化方法对波士顿房价进行预测    &quot;&quot;&quot;    boston &#x3D; load_boston()    x_train, x_test, y_train, y_test &#x3D; train_test_split(        boston.data, boston.target, random_state&#x3D;22)    transfer &#x3D; StandardScaler()    x_train &#x3D; transfer.fit_transform(x_train)    x_test &#x3D; transfer.transform(x_test)    estimator &#x3D; LinearRegression()    estimator.fit(x_train, y_train)    print(&quot;正规方程-权重系数为：\n&quot;, estimator.coef_)    print(&quot;正规方程-偏置为：\n&quot;, estimator.intercept_)    y_predict &#x3D; estimator.predict(x_test)    print(&quot;正规方程-预测房价：\n&quot;, y_predict)    error &#x3D; mean_squared_error(y_test, y_predict)    print(&quot;正规方程-均方误差：\n&quot;, error)    return Nonedef linear2():    &quot;&quot;&quot;    梯度下降的优化方法对波士顿房价进行预测    &quot;&quot;&quot;    boston &#x3D; load_boston()    x_train, x_test, y_train, y_test &#x3D; train_test_split(        boston.data, boston.target, random_state&#x3D;22)    transfer &#x3D; StandardScaler()    x_train &#x3D; transfer.fit_transform(x_train)    x_test &#x3D; transfer.transform(x_test)    estimator &#x3D; SGDRegressor()    estimator.fit(x_train, y_train)    print(&quot;梯度下降-权重系数为：\n&quot;, estimator.coef_)    print(&quot;梯度下降-偏置为：\n&quot;, estimator.intercept_)    y_predict &#x3D; estimator.predict(x_test)    print(&quot;梯度下降-预测房价：\n&quot;, y_predict)    error &#x3D; mean_squared_error(y_test, y_predict)    print(&quot;梯度下降-均方误差：\n&quot;, error)    return Noneif __name__ &#x3D;&#x3D; &quot;__main__&quot;:    linear1()    linear2()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">正规方程-权重系数为： [-0.64817766  1.14673408 -0.05949444  0.74216553 -1.95515269  2.70902585 -0.07737374 -3.29889391  2.50267196 -1.85679269 -1.75044624  0.87341624  -3.91336869]正规方程-偏置为： 22.62137203166228正规方程-预测房价： [28.22944896 31.5122308  21.11612841 32.6663189  20.0023467  19.07315705 21.09772798 19.61400153 19.61907059 32.87611987 20.97911561 27.52898011  15.54701758 19.78630176 36.88641203 18.81202132  9.35912225 18.49452615  30.66499315 24.30184448 19.08220837 34.11391208 29.81386585 17.51775647  34.91026707 26.54967053 34.71035391 27.4268996  19.09095832 14.92742976  30.86877936 15.88271775 37.17548808  7.72101675 16.24074861 17.19211608   7.42140081 20.0098852  40.58481466 28.93190595 25.25404307 17.74970308  38.76446932  6.87996052 21.80450956 25.29110265 20.427491   20.4698034   17.25330064 26.12442519  8.48268143 27.50871869 30.58284841 16.56039764   9.38919181 35.54434377 32.29801978 21.81298945 17.60263689 22.0804256   23.49262401 24.10617033 20.1346492  38.5268066  24.58319594 19.78072415  13.93429891  6.75507808 42.03759064 21.9215625  16.91352899 22.58327744  40.76440704 21.3998946  36.89912238 27.19273661 20.97945544 20.37925063  25.3536439  22.18729123 31.13342301 20.39451125 23.99224334 31.54729547  26.74581308 20.90199941 29.08225233 21.98331503 26.29101202 20.17329401  25.49225305 24.09171045 19.90739221 16.35154974 15.25184758 18.40766132  24.83797801 16.61703662 20.89470344 26.70854061 20.7591883  17.88403312  24.28656105 23.37651493 21.64202047 36.81476219 15.86570054 21.42338732  32.81366203 33.74086414 20.61688336 26.88191023 22.65739323 17.35731771  21.67699248 21.65034728 27.66728556 25.04691687 23.73976625 14.6649641   15.17700342  3.81620663 29.18194848 20.68544417 22.32934783 28.01568563  28.58237108]正规方程-均方误差： 20.6275137630954梯度下降-权重系数为： [-0.52844184  0.94742828 -0.43896185  0.80011052 -1.70094588  2.83803954 -0.15173308 -3.15314827  1.64459185 -0.92057374 -1.72092516  0.85822999 -3.89079621]梯度下降-偏置为： [22.62848948]梯度下降-预测房价： [28.32292485 31.65691921 21.4754174  32.74532796 20.21502727 19.05803274 21.38012862 19.40598106 19.65928004 32.83684983 21.37788237 27.27547404 15.58434744 19.9543843  37.052139   18.66414622  9.64694632 18.60831548 30.78911441 24.28055663 19.04506654 34.16527664 29.53666782 17.39899068 34.86763757 26.51961514 34.42685759 27.38498522 19.1234001  15.69443705 30.90416755 14.4629764  37.60886681  8.70471496 16.38818819 16.8388242  7.70173349 19.7726613  40.59036302 29.18080616 25.25730687 17.82216674 39.37499484  6.67884528 21.54796917 25.04507005 20.88378703 20.64882236 17.03224546 26.32629603  9.6471961  27.18516688 30.67565735 16.69940767  9.58964556 35.55768574 31.59626177 22.93550937 17.57965025 21.83043993 23.62551177 23.94527301 20.3319314  38.24324246 25.72953353 19.68070738 14.15726975  6.66109511 42.53435973 21.82504626 16.74834226 22.55184196 41.01385643 21.71857114 36.98704919 27.16545173 21.83161702 20.78576019 25.30987444 23.77003724 31.53599899 20.19287298 24.00693276 31.56432429 27.2645538  20.86527222 29.1081147  21.95286144 26.74924411 18.76781794 25.26458575 24.01985914 19.93042174 17.68510263 15.50813547 18.27522698 24.59223379 16.73277678 20.66946955 26.79190915 20.72655782 17.97463708 24.13232421 23.25410362 20.27914227 36.64368885 15.98551815 22.46864296 32.71528599 33.73484378 20.54324486 25.9984172  23.32481418 17.74521574 21.46651544 21.79381137 27.55126895 25.28602934 23.65813339 14.43211265 15.64622064  3.64461024 29.25332792 20.65259117 22.31013756 28.06226938 28.3763949 ]梯度下降-均方误差： 21.168264510208296<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：均方误差越小表示效果越好。</p><h3 id="岭回归—线性回归的改进"><a href="#岭回归—线性回归的改进" class="headerlink" title="岭回归—线性回归的改进"></a>岭回归—线性回归的改进</h3><h4 id="API-8"><a href="#API-8" class="headerlink" title="API"></a>API</h4><p>sklearn.linear_model.Ridge(alpha=1.0, fit_intercept=True,solver=”auto”, normalize=False)</p><ul><li>具有l2正则化的线性回归</li><li>alpha:正则化力度，也叫 λ<ul><li><strong>λ取值：0<del>1 1</del>10</strong></li></ul></li><li>solver:会根据数据自动选择优化方法<ul><li><strong>sag:如果数据集、特征都比较大，选择该随机梯度下降优化</strong></li></ul></li><li>normalize:数据是否进行标准化<ul><li>normalize=False:可以在fit之前调用preprocessing.StandardScaler标准化数据</li></ul></li><li>Ridge.coef_:回归权重</li><li>Ridge.intercept_:回归偏置</li></ul><p><strong>Ridge方法相当于SGDRegressor(penalty=’l2’, loss=”squared_loss”),只不过SGDRegressor实现了一个普通的随机梯度下降学习，推荐使用Ridge(实现了SAG)</strong></p><ul><li>sklearn.linear_model.RidgeCV(_BaseRidgeCV, RegressorMixin)<ul><li>具有l2正则化的线性回归，可以进行交叉验证</li><li>coef_:回归系数</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">from sklearn.datasets import load_boston  # 加载数据集from sklearn.linear_model import Ridge  # 岭回归from sklearn.metrics import mean_squared_error  # 回归评估 均方误差（值越小越好）from sklearn.model_selection import train_test_split  # 数据集划分from sklearn.preprocessing import StandardScaler  # 特征工程 标准化def linear3():    # 加载数据集    boston &#x3D; load_boston()    # 数据集划分    x_train, x_test, y_train, y_test &#x3D; train_test_split(        boston.data, boston.target, random_state&#x3D;22)    # 数据集标准化    transfer &#x3D; StandardScaler()    x_train &#x3D; transfer.fit_transform(x_train)    x_test &#x3D; transfer.transform(x_test)    # 预估器    estimator &#x3D; Ridge()    estimator.fit(x_train, y_train)    # 得出模型    print(&quot;岭回归-权重系数为：\n&quot;, estimator.coef_)    print(&quot;岭回归-偏置为：\n&quot;, estimator.intercept_)    # 模型评估    y_predict &#x3D; estimator.predict(x_test)    print(&quot;岭回归-预测房价：\n&quot;, y_predict)    error &#x3D; mean_squared_error(y_test, y_predict)    print(&quot;岭回归-均方误差：\n&quot;, error)    return Noneif __name__ &#x3D;&#x3D; &quot;__main__&quot;:    linear3()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">岭回归-权重系数为： [-0.63591916  1.12109181 -0.09319611  0.74628129 -1.91888749  2.71927719 -0.08590464 -3.25882705  2.41315949 -1.76930347 -1.74279405  0.87205004  -3.89758657]岭回归-偏置为： 22.62137203166228岭回归-预测房价： [28.22119941 31.49858594 21.14690941 32.64962343 20.03976087 19.07187629 21.11827061 19.61935024 19.64669848 32.83666525 21.01034708 27.47939935 15.55875601 19.80406014 36.86415472 18.79442579  9.42343608 18.5205955 30.67129766 24.30659711 19.07820077 34.08772738 29.77396117 17.50394928 34.87750492 26.52508961 34.65566473 27.42939944 19.08639183 15.04854291 30.84974343 15.76894723 37.18814441  7.81864035 16.27847433 17.15510852  7.46590141 19.98474662 40.55565604 28.96103939 25.25570196 17.7598197 38.78171653  6.87935126 21.76805062 25.25888823 20.47319256 20.48808719 17.24949519 26.11755181  8.61005188 27.47070495 30.57806886 16.57080888  9.42312214 35.50731907 32.20467352 21.93128073 17.62011278 22.08454636 23.50121152 24.08248876 20.16840581 38.47001591 24.69276673 19.7638548 13.96547058  6.76070715 42.04033544 21.9237625  16.88030656 22.60637682 40.74664535 21.44631815 36.86936185 27.17135794 21.09470367 20.40689317 25.35934079 22.35676321 31.1513028  20.39303322 23.99948991 31.54251155 26.77734347 20.89368871 29.05880401 22.00850263 26.31965286 20.04852734 25.46476799 24.08084537 19.90846889 16.47030743 15.27936372 18.39475348 24.80822272 16.62280764 20.86393724 26.70418608 20.74534996 17.89544942 24.25949423 23.35743497 21.51817773 36.76202304 15.90293344 21.52915882 32.78684766 33.68666117 20.61700911 26.78345059 22.72685584 17.40478038 21.67136433 21.6912557  27.66684993 25.08825085 23.72539867 14.64260535 15.21105331  3.81916568 29.16662813 20.67913144 22.33386579 28.01241753 28.531445  ]岭回归-均方误差： 20.65644821435496<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="逻辑回归与二分类—分类算法"><a href="#逻辑回归与二分类—分类算法" class="headerlink" title="逻辑回归与二分类—分类算法"></a>逻辑回归与二分类—分类算法</h3><h4 id="逻辑回归API"><a href="#逻辑回归API" class="headerlink" title="逻辑回归API"></a>逻辑回归API</h4><ul><li>sklearn.linear_model.LogisticRegression(solver=’liblinear’, penalty=‘l2’, C = 1.0)<ul><li>solver:优化求解方式（默认开源的liblinear库实现，内部使用了坐标轴下降法来迭代优化损失函数）<ul><li>sag：根据数据集自动选择，随机平均梯度下降</li></ul></li><li>penalty：正则化的种类</li><li>C：正则化力度</li></ul></li></ul><blockquote><p><strong>默认将类别数量少的当做正例</strong></p></blockquote><p><strong>LogisticRegression方法相当于 SGDClassifier(loss=”log”, penalty=” “),SGDClassifier实现了一个普通的随机梯度下降学习，也支持平均随机梯度下降法（ASGD），可以通过设置average=True。而使用LogisticRegression(实现了SAG)</strong></p><h4 id="分类评估报告API"><a href="#分类评估报告API" class="headerlink" title="分类评估报告API"></a>分类评估报告API</h4><ul><li>sklearn.metrics.classification_report(y_true, y_pred, labels=[], target_names=None )</li><li><ul><li>y_true：真实目标值</li><li>y_pred：估计器预测目标值</li><li>labels:指定类别对应的数字</li><li>target_names：目标类别名称</li><li>return：每个类别精确率与召回率</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">import numpy as npimport pandas as pdfrom sklearn.linear_model import LogisticRegression  # 逻辑回归from sklearn.metrics import classification_report, roc_auc_score    # 分类评估from sklearn.model_selection import train_test_split  # 数据集划分from sklearn.preprocessing import StandardScaler  # 特征工程 标准化if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    # 加载数据    column_name &#x3D; [&#39;Sample code number&#39;, &#39;Clump Thickness&#39;,                   &#39;Uniformity of Cell Size&#39;, &#39;Uniformity of Cell Shape&#39;,                   &#39;Marginal Adhesion&#39;, &#39;Single Epithelial Cell Size&#39;,                   &#39;Bare Nuclei&#39;, &#39;Bland Chromatin&#39;,                   &#39;Normal Nucleoli&#39;, &#39;Mitoses&#39;, &#39;Class&#39;]    path &#x3D; r&quot;D:\痛苦の资料\不会真的有人学编程吧\机器学习\黑马程序员\自己的整理\day3\breast-cancer-wisconsin.data&quot;    data &#x3D; pd.read_csv(path, names&#x3D;column_name)    # 数据处理  因为数据中有缺失值，缺失的地方使用 ? 替代，目标是删掉缺失值    data &#x3D; data.replace(to_replace&#x3D;&#39;?&#39;, value&#x3D;np.nan)    data.dropna(inplace&#x3D;True)    # 数据处理  获取特征值和目标值    x &#x3D; data.iloc[:, 1:-1]    y &#x3D; data[&quot;Class&quot;]    # 数据集划分    x_train, x_test, y_train, y_test &#x3D; train_test_split(x, y)    # 数据标准化    transfer &#x3D; StandardScaler()    x_train &#x3D; transfer.fit_transform(x_train)    x_test &#x3D; transfer.transform(x_test)    # 预估器    estimator &#x3D; LogisticRegression()    estimator.fit(x_train, y_train)    # 模型    print(&quot;逻辑回归-权重系数为：\n&quot;, estimator.coef_)    print(&quot;逻辑回归-偏置为：\n&quot;, estimator.intercept_)    y_predict &#x3D; estimator.predict(x_test)    print(&quot;y_predict：\n&quot;, y_predict)    print(&quot;直接比对真实值和预测值：\n&quot;, y_test &#x3D;&#x3D; y_predict)    score &#x3D; estimator.score(x_test, y_test)    print(&quot;准确率：\n&quot;, score)    # 查看精确率、召回率、F1-score    report &#x3D; classification_report(y_test, y_predict, labels&#x3D;[                                   2, 4], target_names&#x3D;[&#39;良性&#39;, &#39;恶性&#39;])    # y_true:每个样本的真实类别，必须为0(反例),1(正例)标记    # 将y_test 转换成 0 1    y_true &#x3D; np.where(y_test &gt; 3, 1, 0)    print(roc_auc_score(y_true, y_predict))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">逻辑回归-权重系数为： [[1.51911637 0.06401522 0.69614721 0.76445915 0.50264081 1.37783828  1.13432057 0.6161716  0.85294448]]逻辑回归-偏置为： [-0.90973535]y_predict： [2 4 2 4 2 2 2 2 4 2 2 2 2 2 2 2 2 4 2 2 2 2 2 2 2 2 2 2 2 4 4 4 2 2 2 2 4 2 4 2 4 4 2 2 4 4 4 4 4 2 2 2 4 2 4 4 2 2 2 2 4 2 2 2 4 2 4 4 2 2 2 2 2 2 2 2 4 2 2 2 4 2 2 2 2 2 2 2 2 4 2 2 2 2 2 2 2 4 4 4 2 2 2 2 4 4 2 4 4 2 4 2 4 4 4 2 2 2 2 2 2 4 2 4 2 2 2 2 2 4 2 4 4 2 4 2 2 4 4 4 2 2 2 2 2 2 2 2 2 2 2 2 4 4 2 2 2 4 2 4 2 2 2 2 2 2 2 2 4 4 2]直接比对真实值和预测值： 137    True506    True578    True100    True600    True       ...426    True390    True336    True289    True444    TrueName: Class, Length: 171, dtype: bool准确率： 0.96491228070175440.9585488041370394<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="无监督学习—K-means算法"><a href="#无监督学习—K-means算法" class="headerlink" title="无监督学习—K-means算法"></a>无监督学习—K-means算法</h3><h4 id="K-meansAPI"><a href="#K-meansAPI" class="headerlink" title="K-meansAPI"></a>K-meansAPI</h4><ul><li>sklearn.cluster.KMeans(n_clusters=8,init=‘k-means++’)<ul><li>k-means聚类</li><li>n_clusters:开始的聚类中心数量</li><li>init:初始化方法，默认为’k-means ++’</li><li>labels_:默认标记的类型，可以和真实值比较（不是值比较）</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV颜色识别 物体追踪</title>
      <link href="posts/7.html"/>
      <url>posts/7.html</url>
      
        <content type="html"><![CDATA[<h1 id="OpenCV颜色识别-物体追踪"><a href="#OpenCV颜色识别-物体追踪" class="headerlink" title="OpenCV颜色识别 物体追踪"></a>OpenCV颜色识别 物体追踪</h1><a id="more"></a><p>对于颜色识别和<code>imutils</code>包的用法请浏览我得另一篇博客：<a href="https://lightningleader.github.io/posts/6.html">OpenCV学习笔记</a></p><h2 id="代码原理"><a href="#代码原理" class="headerlink" title="代码原理"></a>代码原理</h2><p>这是个比较简单的代码。代码实现的就是简单的物体追踪，将物体用方框框出。</p><p>简单来讲就是先进行颜色识别，正确识别到物体后获取物体的外接矩形再画出外接矩形即可。</p><p>详细的解释可以看代码注释，应该是容易理解的。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">import cv2import numpy as npimport imutilsfrom imutils import contours# 颜色阈值lower &#x3D; np.array([130, 62, 72])upper &#x3D; np.array([170, 255, 148])# 内核kernel &#x3D; np.ones((5, 5), np.uint8)# 打开摄像头vc &#x3D; cv2.VideoCapture(0)if vc.isOpened():    flag, frame &#x3D; vc.read()    # 翻转图像    # 这一步可以忽略，博主的摄像头是反着的    # 所以加上这句话可以让摄像头的图像正过来    frame &#x3D; imutils.rotate(frame, 180)    cv2.imshow(&quot;frame&quot;, frame)else:    flag &#x3D; Falsewhile flag:    flag, frame &#x3D; vc.read()    # 翻转图像    frame &#x3D; imutils.rotate(frame, 180)    draw_frame &#x3D; frame.copy()    if frame is None:        break    if flag is True:        &#39;&#39;&#39;下面对摄像头读取到的图像进行处理，这个步骤是比较重要的&#39;&#39;&#39;        # 转换颜色空间HSV        frame_hsv &#x3D; cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)        # 颜色识别        img &#x3D; cv2.inRange(frame_hsv, lower, upper)        # 膨胀操作        dilation &#x3D; cv2.dilate(img, kernel, iterations&#x3D;1)        # 闭操作        closing &#x3D; cv2.morphologyEx(dilation, cv2.MORPH_CLOSE, kernel)        # 高斯滤波        closing &#x3D; cv2.GaussianBlur(closing, (5, 5), 0)        # 边缘检测        edges &#x3D; cv2.Canny(closing, 10, 20)        &#39;&#39;&#39;上面进行那么多操作就是为了得到更好的目标图形，具体效果因环境而异&#39;&#39;&#39;        # 寻找轮廓        cnts, _ &#x3D; cv2.findContours(            edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)        # 判断轮廓数量也就是判断是否寻找到轮廓，如果没有找到轮廓就不继续进行操作        if len(cnts) &gt; 0:            # 存放轮廓面积的列表            s &#x3D; []            # 存放最大轮廓的索引            max_index &#x3D; 0            # 获得排序后的轮廓列表以及每个轮廓对应的外接矩形            (cnts, boundingRects) &#x3D; contours.sort_contours(cnts)            # 寻找面积最大的轮廓的索引            for cnt in cnts:                s.append(cv2.contourArea(cnt))            max_index &#x3D; s.index(max(s))            # 根据面积最大轮廓的索引找到它的外接矩形的信息            (x, y, w, h) &#x3D; boundingRects[max_index]            # 画矩形            frame_out &#x3D; cv2.rectangle(                         draw_frame, (x, y), (x+w, y+h), (0, 255, 0), 2)        cv2.imshow(&quot;frame&quot;, draw_frame)        if cv2.waitKey(10) &#x3D;&#x3D; 27:            breakvc.release()cv2.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体解释都在代码注释里面了，下面我要提一些注意的地方。</p><ol><li>获得过图像之后可能需要进行一系列的形态学操作，这样可以让获得的图像更加接近目的图像。这些操作虽然不是必需的但如果正常取得的图像效果不好的时候可以加上。</li><li>函数<code>contours.sort_contours</code> 和 <code>imutils.rotate</code>是<code>imutils</code>包里面的，使用起来比较方便，具体用法可以看博主的另一篇博客：<a href="https://lightningleader.github.io/posts/6.html">OpenCV学习笔记</a>。外接矩形也可以通过<code>cv2.boundingRect</code>函数获得。</li><li>代码中博主是以轮廓的最大面积为条件画的图，但这个条件应该根据自己想要的效果而定。这里除了寻找最大面积以外还可以寻找最大周长、最长的边之类的。</li></ol><h2 id="最终效果图"><a href="#最终效果图" class="headerlink" title="最终效果图"></a>最终效果图</h2><p><img src="/posts/7/1.jpg" alt="最终效果图"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV学习笔记</title>
      <link href="posts/6.html"/>
      <url>posts/6.html</url>
      
        <content type="html"><![CDATA[<h1 id="OpenCV学习笔记"><a href="#OpenCV学习笔记" class="headerlink" title="OpenCV学习笔记"></a>OpenCV学习笔记</h1><a id="more"></a><h2 id="图像翻转"><a href="#图像翻转" class="headerlink" title="图像翻转"></a>图像翻转</h2><p>使用Python的一个包，imutils。使用下面的指令可以安装。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pip install imutils<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>imutils包的Github地址：<a href="https://github.com/jrosebr1/imutils">https://github.com/jrosebr1/imutils</a></p><p>CSDN镜像：<a href="https://codechina.csdn.net/mirrors/jrosebr1/imutils">https://codechina.csdn.net/mirrors/jrosebr1/imutils</a></p><p>可以在上面这个地址里面学习更多的使用方式。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import cv2import imutils&#39;&#39;&#39;imutils.rotate第一个参数是翻转的图像，第二个参数的翻转角度函数还提供翻转中心的设置，但默认就是中心翻转。&#39;&#39;&#39;vc &#x3D; cv2.VideoCapture(0)if vc.isOpened():    flag, frame &#x3D; vc.read()    img &#x3D; imutils.rotate(frame, 180)    # 图像翻转     cv2.imshow(&quot;frame&quot;, img)else:    flag &#x3D; Falsewhile flag:    flag, frame &#x3D; vc.read()    if frame is None:        break    if flag is True:        img &#x3D; imutils.rotate(frame, 180)    # 图像翻转        cv2.imshow(&quot;frame&quot;, img)        if cv2.waitKey(10) &#x3D;&#x3D; 27:            breakvc.release()cv2.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样写的话，最后的输出图像就是翻转180度的。</p><p>imutils包里还有其他好用的函数，resizing、4-point Perspective Transform、Sorting Contours等等。</p><h2 id="图像轮廓排序"><a href="#图像轮廓排序" class="headerlink" title="图像轮廓排序"></a>图像轮廓排序</h2><p>这个效果同样也是依靠imutils包完成。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from imutils import contoursimport cv2&#39;&#39;&#39;contours.sort_contours可选排序方式：&quot;left-to-right&quot;, &quot;right-to-left&quot;, &quot;top-to-bottom&quot;, &quot;bottom-to-top&quot;返回值为轮廓和外接矩形contours.label_contourcontours包内自带的画轮廓的函数，可以直接用，然后可以在图片上标出轮廓序号也可以直接使用cv2.drawContours直接画轮廓&#39;&#39;&#39;img &#x3D; cv2.imread(r&quot;D:\opencv-workspace\Opencv\test17--VScode\shapes.png&quot;)draw_img &#x3D; img.copy()img_rect &#x3D; img.copy()gray &#x3D; cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)img &#x3D; cv2.Canny(gray, 10, 20)    # Canny边缘检测cnts, hierarchy &#x3D; cv2.findContours(img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)    # 获得轮廓(cnts, boundingBoxes) &#x3D; contours.sort_contours(cnts, &quot;top-to-bottom&quot;)    # 对轮廓进行排序处理for (i, c) in enumerate(cnts):    sortedImage &#x3D; contours.label_contour(draw_img, c, i, color&#x3D;(240, 0, 159))# img_out &#x3D; cv2.drawContours(draw_img, cnts, -1, (240, 0, 159), 2)# 根据boundingBoxes画外接矩形for (x, y, w, h) in boundingBoxes:    img_rect &#x3D; cv2.rectangle(img_rect, (x, y), (x+w, y+h), (240, 0, 159), 2)cv2.imshow(&quot;top-to-bottom&quot;, sortedImage)cv2.imshow(&quot;rect&quot;, img_rect)cv2.waitKey(0)cv2.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/6/1.jpg" alt="处理效果"></p><h2 id="颜色识别"><a href="#颜色识别" class="headerlink" title="颜色识别"></a>颜色识别</h2><h3 id="基础颜色识别"><a href="#基础颜色识别" class="headerlink" title="基础颜色识别"></a>基础颜色识别</h3><p>颜色识别是在HSV空间内进行的，因此在使用之前先进行颜色空间的转换。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;使用下面这个函数进行转换，第一个参数填写要转换的图片，第二个参数填写cv2.COLOR_BGR2HSV&#39;&#39;&#39;cv2.cvtColor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">import cv2import numpy as np&#39;&#39;&#39;cv2.inRange函数很简单，参数有三个第一个参数：hsv指的是原图第二个参数：lower_red指的是图像中低于这个lower_red的值，图像值变为0第三个参数：upper_red指的是图像中高于这个upper_red的值，图像值变为0而在lower_red～upper_red之间的值变成255&#39;&#39;&#39;# 阈值lower_green &#x3D; np.array([50, 255, 255])upper_green &#x3D; np.array([70, 255, 255])img &#x3D; cv2.imread(r&quot;D:\opencv-workspace\Opencv\test16--VScode\photo.jpg&quot;)img_hsv &#x3D; cv2.cvtColor(img, cv2.COLOR_BGR2HSV)mask_green &#x3D; cv2.inRange(img_hsv, lower_green, upper_green)cv2.imshow(&quot;img_or&quot;, mask_green)# 使用下面这个函数能显示原来的颜色。res_green &#x3D; cv2.bitwise_and(img, img, mask&#x3D;mask_green)cv2.imshow(&quot;img&quot;, res_green)cv2.waitKey(0)cv2.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/6/2.jpg" alt="原图"></p><p><img src="/posts/6/4.jpg" alt="mask_green"></p><p><img src="/posts/6/3.jpg" alt="res_green"></p><p>在进行颜色识别时，难免会出现“漏颜色”的现象，也就是会出现没识别全的现象。这个时候可以再对图像进行处理，比如说进行形态学处理，让图像更加饱满之类的。</p><h3 id="根据BGR获取HSV"><a href="#根据BGR获取HSV" class="headerlink" title="根据BGR获取HSV"></a>根据BGR获取HSV</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">import cv2color &#x3D; np.uint8([[[193, 189, 147]]])    # 参数填写BGR的值hsv &#x3D; cv2.cvtColor(color, cv2.COLOR_BGR2HSV)print(hsv)    # 打印出来的数值就是对应的HSV值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序运行的结果是</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">[[[ 93  61 193]]]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个就是对应的HSV的值。</p><p>根据之前写的颜色识别，就需要把对应的阈值写出。具体写法就是<strong>保持S和V不变，H加减10。</strong>这样的话就可以写出高低阈值然后应用到颜色识别里面就可以了。</p><h3 id="阈值编辑器"><a href="#阈值编辑器" class="headerlink" title="阈值编辑器"></a>阈值编辑器</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">import cv2import numpy as npdef function(x):    lowH &#x3D; cv2.getTrackbarPos(&quot;lowH&quot;, &quot;img_666&quot;)    lowS &#x3D; cv2.getTrackbarPos(&quot;lowS&quot;, &quot;img_666&quot;)    lowV &#x3D; cv2.getTrackbarPos(&quot;lowV&quot;, &quot;img_666&quot;)    HighH &#x3D; cv2.getTrackbarPos(&quot;HighH&quot;, &quot;img_666&quot;)    HighS &#x3D; cv2.getTrackbarPos(&quot;HighS&quot;, &quot;img_666&quot;)    HighV &#x3D; cv2.getTrackbarPos(&quot;HighV&quot;, &quot;img_666&quot;)    # print(lowH, lowS, lowV, HighH, HighS, HighV)    lower &#x3D; np.uint8([lowH, lowS, lowV])    upper &#x3D; np.uint8([HighH, HighS, HighV])    mask &#x3D; cv2.inRange(img_hsv, lower, upper)    res &#x3D; cv2.bitwise_and(img, img, mask&#x3D;mask)    cv2.imshow(&quot;img&quot;, res)img &#x3D; cv2.imread(r&quot;D:\opencv-workspace\Opencv\test16--VScode\test.jpg&quot;)img_hsv &#x3D; cv2.cvtColor(img, cv2.COLOR_BGR2HSV)cv2.namedWindow(&quot;img_666&quot;)cv2.createTrackbar(&quot;lowH&quot;, &quot;img_666&quot;, 0, 179, function)cv2.createTrackbar(&quot;lowS&quot;, &quot;img_666&quot;, 0, 255, function)cv2.createTrackbar(&quot;lowV&quot;, &quot;img_666&quot;, 0, 255, function)cv2.createTrackbar(&quot;HighH&quot;, &quot;img_666&quot;, 0, 179, function)cv2.createTrackbar(&quot;HighS&quot;, &quot;img_666&quot;, 0, 255, function)cv2.createTrackbar(&quot;HighV&quot;, &quot;img_666&quot;, 0, 255, function)cv2.imshow(&quot;img&quot;, img)cv2.waitKey(0)cv2.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>写了一个比较垃圾的阈值编辑器。。。就不多解释了。。</p><p><img src="/posts/6/5.jpg" alt="阈值编辑器"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派串口通信 USB串口通信</title>
      <link href="posts/5.html"/>
      <url>posts/5.html</url>
      
        <content type="html"><![CDATA[<h1 id="树莓派串口通信-USB串口通信"><a href="#树莓派串口通信-USB串口通信" class="headerlink" title="树莓派串口通信 USB串口通信"></a>树莓派串口通信 USB串口通信</h1><a id="more"></a><p>如果不知道树莓派怎么使用USB串口通信的，欢迎浏览我的另一篇博客文章：<a href="https://lightningleader.github.io/posts/4.html">树莓派使用USB串口通信 CH340</a></p><p>这篇文章就以USB串口为例，简单的说下串口通信时常用的几个命令。注意：代码均为Python编写。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>树莓派4</li><li>两个CH340</li><li>串口助手</li></ul><h2 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h2><ol><li><p>最基础的发送数据方式</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;ser.write(data)    # 发送数据data，data为字节型&#39;&#39;&#39;import serialser &#x3D; serial.Serial(&quot;&#x2F;dev&#x2F;ttyUSB0&quot;, 115200)ser.flushInput()    # 清除缓存ser.write(&quot;LightningMaster\r\n&quot;.encode())    # 发送数据  \r\n可以实现换行  encode()默认是&#39;utf-8&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行这个代码就可以在串口助手上收到数据。</p><p><img src="/posts/5/1.jpg" alt="最基础发送数据"></p></li><li><p>发送中文</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import serialser &#x3D; serial.Serial(&quot;&#x2F;dev&#x2F;ttyUSB0&quot;, 115200)ser.flushInput()    # 清除缓存ser.write(&quot;闪电丶教主\r\n&quot;.encode(&#39;gb2312&#39;))    # 发送数据  \r\n可以实现换行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/5/2.jpg" alt="发送中文"></p></li><li><p>发送数据包 十六进制</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import serialimport structser &#x3D; serial.Serial(&quot;&#x2F;dev&#x2F;ttyUSB0&quot;, 115200)ser.flushInput()    # 清除缓存pack &#x3D; struct.pack(&#39;BBBB&#39;, 0xaa, 6, 7, 0x55)    # 将数据打包 格式是unsigned charser.write(pack)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/5/3.jpg" alt="发送数据包"></p><p>这个地方使用到了struct.pack，具体有啥作用可以自行百度去看看，我在这就不多说了。这里的作用就是将数据打包，返回格式是unsigned char 的字节串。</p><p>可以使用这个函数给数据加上“头”“尾”之类的东西。</p></li></ol><h2 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;ser.read(num)    # 读取收到的num个字节的数据ser.inWaiting()    # 可以获取还未读出的数据&#39;&#39;&#39;import serialimport structimport timeser &#x3D; serial.Serial(&quot;&#x2F;dev&#x2F;ttyUSB0&quot;, 115200)ser.flushInput()    # 清除缓存while True:    count &#x3D; ser.inWaiting()    # 获取还有多少字符未读    if count !&#x3D; 0:        data &#x3D; ser.read(count)    # 读取数据存到data中        print(data)    # 打印接受到的数据    time.sleep(0.1)    # 系统等待<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行代码，使用串口助手发送数据，可以在树莓派中看到返回值。</p><p><img src="/posts/5/4.jpg" alt="接收数据"></p><p>可以看到树莓派成功接收到了数据。</p><p>如果想把b’ ‘去掉可以使用代码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(data.decode(&#39;utf-8&#39;))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/5/5.jpg" alt="去掉b&#39;&#39;"></p><p>接收中文的话需要使用下面的代码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(data.decode(&#39;gb2312&#39;))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/5/6.jpg" alt="接收中文"></p><p>具体为什么使用encode和decode，可以自行查阅Python相关资料。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派使用USB串口通信 CH340</title>
      <link href="posts/4.html"/>
      <url>posts/4.html</url>
      
        <content type="html"><![CDATA[<h1 id="树莓派使用USB串口通信-CH340"><a href="#树莓派使用USB串口通信-CH340" class="headerlink" title="树莓派使用USB串口通信 CH340"></a>树莓派使用USB串口通信 CH340</h1><a id="more"></a><p>因为需要使用树莓派做自控方向的东西，所以需要使用树莓派串口与各种外设进行通信。使用串口的话个人比较喜欢直接使用USB串口，用起来比较方便。下面就介绍一下怎么使用树莓派的USB串口通信。</p><p>对于不会使用串口通信的hxd可以康康我的这篇文章，里面详细讲解了常用的串口通信的命令：<a href="https://lightningleader.github.io/posts/5.html">树莓派串口通信 USB串口通信</a></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>树莓派4</li><li>CH340</li><li>串口助手</li></ul><h2 id="树莓派正确识别CH340"><a href="#树莓派正确识别CH340" class="headerlink" title="树莓派正确识别CH340"></a>树莓派正确识别CH340</h2><p>首先正常开启树莓派，不要插入CH340，然后进入树莓派桌面，打开命令行，输入命令lsusb，可以查看本机的USB设备列表，以及USB设备的详细信息。</p><p><img src="/posts/4/1.jpg" alt="输入命令lsusb"></p><p>正常的话，就会像上图那样。</p><p>然后插入CH340，再次运行lsusb命令，这个时候应该会出现下面这个界面。</p><p><img src="/posts/4/2.jpg" alt="再次输入命令lsusb"></p><p>从上图可以明显看出多了一个设备，后面的设备详情也明确表示这个是CH340，这就表明树莓派正确识别到了插入的CH340。</p><p>接着在命令行输入命令 ls -l /dev/tty* </p><p><img src="/posts/4/3.jpg" alt="USB"></p><p>如上图所示，不出意外的话最后一个就是你插入的ch340，然后就记住这个黄色字体即/dev/ttyUSB0。这里的USB0也可能是USB1，这个是不确定的。</p><p>到了这里就代表你的树莓派可以正常识别CH34，下面就是写代码来验证效果了。</p><h2 id="代码实现通信"><a href="#代码实现通信" class="headerlink" title="代码实现通信"></a>代码实现通信</h2><p>这里我的代码是Python的。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import serialser &#x3D; serial.Serial(&quot;&#x2F;dev&#x2F;ttyUSB0&quot;, 115200)    # 第一个参数就是上面那个黄色字体  第二个参数填波特率ser.flushInput()    # 清除缓存ser.write(&quot;LightningMaster\r\n&quot;.encode())   # 发送<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：这个教程是默认树莓派已经进行了串口配置的。比如说安装pyserial包，如果没安装的话，可以使用下面的命令进行安装</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pip3 install pyserial<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为了测试，我使用两个CH340，一个连接树莓派另一个连接电脑，这样就可以直接在电脑上通过串口助手看到发送的数据了。</p><p>运行代码后就可以在串口助手上看到树莓派发送的数据了。</p><p><img src="/posts/4/4.jpg" alt="串口助手"></p><p>这样就可以正常使用USB串口进行通信了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循迹智能小车 循黑线</title>
      <link href="posts/3.html"/>
      <url>posts/3.html</url>
      
        <content type="html"><![CDATA[<h1 id="循迹智能小车-循黑线"><a href="#循迹智能小车-循黑线" class="headerlink" title="循迹智能小车 循黑线"></a>循迹智能小车 循黑线</h1><a id="more"></a><h2 id="硬件菜单"><a href="#硬件菜单" class="headerlink" title="硬件菜单"></a>硬件菜单</h2><ul><li><p>单片机型号：STC16F40K128</p></li><li><p>4路红外循迹模块</p></li><li><p>小车底盘套件（一个底盘、两个TT马达、两个轮胎）</p></li><li><p>12V航模电池</p></li><li><p>降压模块</p></li><li><p>A4950双路电机驱动</p></li><li><p>杜邦线等</p></li></ul><h2 id="硬件使用"><a href="#硬件使用" class="headerlink" title="硬件使用"></a>硬件使用</h2><p><img src="/posts/3/1.png" alt="4路红外循迹模块"></p><ul><li>关于4路红外循迹模块的使用教程，我之前写过一篇博客，里面有详细的介绍。如果有不会的可以先去浏览学习一下。<a href="https://lightningleader.github.io/posts/2.html">跳转至教程</a></li><li>A4950双路电机驱动使用方式不多说了，比较简单。大部分人应该都是用L298N的。</li></ul><h2 id="硬件组装"><a href="#硬件组装" class="headerlink" title="硬件组装"></a>硬件组装</h2><p><img src="/posts/3/2.jpg" alt="循迹小车1"></p><p><img src="/posts/3/3.jpg" alt="循迹小车2"></p><p>硬件组装大概按照上面两张图片组装就行。  </p><ul><li>不过要注意的是红外传感器之间的距离和单个传感器的测量精度。在组装完成后，要通电试一试传感器的工作情况，用它检测黑线，康康是不是能够正常工作。如果无法正常工作需要及时调整传感器的精度或者其他东西。总之要保证传感器能正常检测黑线。</li><li>另一点就是传感器的安装位置。受到传感器数量的限制，所以传感器的安装位置需要仔细考虑。我这里一共有4个传感器所以就像图中那样安装的。中间两个之间留有空隙，空隙的宽度大概为黑线宽度（可以稍微比黑线宽点），其他两个的位置也不要离得太远。具体为什么这样设计再后面讲解。</li></ul><h2 id="程序设计前的理解"><a href="#程序设计前的理解" class="headerlink" title="程序设计前的理解"></a>程序设计前的理解</h2><ul><li>接上面挖下的坑，说一下中间两个传感器之间空隙的问题。</li></ul><p>前提是小车在没有检测到黑线的时候会直线行驶。中间的空隙宽度略微大于黑线宽度，这样就可以满足当黑线处于这个缝隙间的时候传感器不会有反应，小车会直线行驶，在一定程度上满足循线的基础操作。肯定会出现黑线移出这个空隙的情况，这样的话黑线就会被两侧的传感器检测到，然后由单片机做出应对。如果是左侧的传感器检测到黑线（设定小车前进方向为正方向），代表车头右偏了，因此小车需要左转；于此类似，右侧的传感器也是一个道理。理解了这些就可以完成最基本的循线了。</p><ul><li>最外侧两个传感器的作用  </li></ul><p>因为传感器反应速度等等一系列可能的原因会出现黑线在移出中央空隙的时间很短导致传感器没有检测到等的情况，这样的话小车肯定会继续前进而导致无法继续循线。如果在中间两个传感器两侧又安装了两个传感器的话，这样就相当于多了一个保险，如果中间两个没有检测到的话，最外侧的传感器正常工作仍能让小车重新回到循线轨迹上来。不过要注意的是，因为当最外侧的传感器检测到黑线时就意味着车头已经偏的比较严重了，所以要想让车头偏正就需要给更大的“力”，也就是给更大的PWM。</p><h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;headfile.h&quot;&#x2F;******************** 用于初始化PWM的*******************&#x2F;void All_Init(void)&#123;pwm_init(PWMA_CH1P_P60, 10000, 0);pwm_init(PWMA_CH2P_P62, 10000, 0);pwm_init(PWMA_CH3P_P64, 10000, 0);pwm_init(PWMA_CH4P_P66, 10000, 0);&#125;&#x2F;******************** 车子左转*******************&#x2F;void turn_left(int duty)&#123;pwm_duty(PWMA_CH1P_P60, duty);pwm_duty(PWMA_CH2P_P62, 0);pwm_duty(PWMA_CH3P_P64, 0);pwm_duty(PWMA_CH4P_P66, duty);&#125;&#x2F;******************** 车子右转*******************&#x2F;void turn_right(int duty)&#123;pwm_duty(PWMA_CH1P_P60, 0);pwm_duty(PWMA_CH2P_P62, duty);pwm_duty(PWMA_CH3P_P64, duty);pwm_duty(PWMA_CH4P_P66, 0);&#125;&#x2F;******************** 车子直行*******************&#x2F;void go_straight(void)&#123;pwm_duty(PWMA_CH1P_P60, 7000);pwm_duty(PWMA_CH2P_P62, 0);pwm_duty(PWMA_CH3P_P64, 7000);pwm_duty(PWMA_CH4P_P66, 0);&#125;&#x2F;******************** 车子停止*******************&#x2F;void go_stop(void)&#123;pwm_duty(PWMA_CH1P_P60, 0);pwm_duty(PWMA_CH2P_P62, 0);pwm_duty(PWMA_CH3P_P64, 0);pwm_duty(PWMA_CH4P_P66, 0);&#125;&#x2F;****************************************** OUT1 P27* OUT2 P26* OUT3 P25* OUT4 P24* 如图循迹小车2所示，从左到右分别为OUT1、2、3、4* 检测到黑线或悬空LED灭，输出高电平* 对单片机的IO口状态进行判断，这样可以得到是哪个* 传感器检测到了黑线，然后再* 做出相对应的行为。*****************************************&#x2F;void scan(void)&#123;if ((P26 &#x3D;&#x3D; 0)&amp;&amp;(P25 &#x3D;&#x3D; 0)&amp;&amp;(P27 &#x3D;&#x3D; 0)&amp;&amp;(P24 &#x3D;&#x3D; 0))&#123;&#x2F;&#x2F; 未检测到黑线go_straight();&#125;else if ((P26 &#x3D;&#x3D; 1)&amp;&amp;(P25 &#x3D;&#x3D; 1)&amp;&amp;(P27 &#x3D;&#x3D; 1)&amp;&amp;(P24 &#x3D;&#x3D; 1))&#123;&#x2F;&#x2F; 悬空go_stop();&#125;else if ((P26 &#x3D;&#x3D; 0)&amp;&amp;(P25 &#x3D;&#x3D; 1)&amp;&amp;(P27 &#x3D;&#x3D; 0)&amp;&amp;(P24 &#x3D;&#x3D; 0))&#123;&#x2F;&#x2F; 车头右偏（相对于前进方向） 向左转（幅度较小）turn_left(7000);&#125;else if ((P26 &#x3D;&#x3D; 1)&amp;&amp;(P25 &#x3D;&#x3D; 0)&amp;&amp;(P27 &#x3D;&#x3D; 0)&amp;&amp;(P24 &#x3D;&#x3D; 0))&#123;&#x2F;&#x2F; 车头左偏 向右转（幅度较小）turn_right(7000);&#125;else if ((P26 &#x3D;&#x3D; 0)&amp;&amp;(P25 &#x3D;&#x3D; 0)&amp;&amp;(P27 &#x3D;&#x3D; 1)&amp;&amp;(P24 &#x3D;&#x3D; 0))&#123;&#x2F;&#x2F; 向左转（幅度较大）turn_left(9500);&#125;else if ((P26 &#x3D;&#x3D; 0)&amp;&amp;(P25 &#x3D;&#x3D; 0)&amp;&amp;(P27 &#x3D;&#x3D; 0)&amp;&amp;(P24 &#x3D;&#x3D; 1))&#123;&#x2F;&#x2F; 向右转（幅度较大）turn_right(9500);&#125;&#125;void main()&#123;DisableGlobalIRQ();&#x2F;&#x2F;关闭总中断board_init();&#x2F;&#x2F;初始化寄存器All_Init();&#x2F;&#x2F;总中断最后开启EnableGlobalIRQ();&#x2F;&#x2F;开启总中断    while(1)&#123;scan();  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序代码大概就像上面那样。其中有些参数，比如说小车行进速度和转弯占空比该给多少。这个东西需要自己测试然后填写，也就是自己慢慢调参测试，找到合适的数值就行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4路红外循迹模块使用教程</title>
      <link href="posts/2.html"/>
      <url>posts/2.html</url>
      
        <content type="html"><![CDATA[<h1 id="4路红外循迹模块使用教程"><a href="#4路红外循迹模块使用教程" class="headerlink" title="4路红外循迹模块使用教程"></a>4路红外循迹模块使用教程</h1><a id="more"></a><h2 id="模块详细信息："><a href="#模块详细信息：" class="headerlink" title="模块详细信息："></a>模块详细信息：</h2><p>工作电压：DC 3.3V~5V</p><p>工作电流：尽量选择1A以上电源供电</p><p>工作温度：-10℃~+50℃</p><p>安装孔径：M3螺丝</p><p>检测距离：1mm~30cm可调，距离越近2性能越稳定，白色反射距离远</p><p>尺寸大小：中控板42mmX38mmX12mm（长X宽X高）；小板向前25mmX12mmX12mm（长X宽X高）</p><p>输出接口：6线制接口（1、2、3、4为4路信号输出端，VCC接正电源，GND接GND）</p><p>输出信号：TTL电平，可直接连接单片机IO口，感应到传感器反射回来的红外光时，红指示灯亮，输出低电平；没有红外光时，指示灯不亮，输出高电平。</p><h2 id="模块接线"><a href="#模块接线" class="headerlink" title="模块接线"></a>模块接线</h2><p><img src="/posts/2/1.png" alt="4路红外循迹模块"></p><p>图中主控板左侧分别为，VCC、GND、OUT1、OUT2、OUT3、OUT4，其中OUT1、2、3、4分别连接单片机的IO口，用于检测输出电平。主控板右侧分别与四个小板连接，用于采集信息。</p><h2 id="模块使用"><a href="#模块使用" class="headerlink" title="模块使用"></a>模块使用</h2><p>模块正确连接并通电后，小板传感器开始工作。模块感应到传感器反射回来的红外光时，红指示灯亮，输出低电平；没有红外光时，指示灯不亮，输出高电平。以检测黑线为例，如果传感器检测到黑线，红外光无法反射回来则模块红指示灯熄灭，同时小板对应的OUT口输出高电平；如果未检测到黑线，红外光可以反射回来则模块红指示灯亮，小板对应的OUT口输出低电平。其中需要注意一种特殊情况，也就是说当测量物体超出测量范围时，此时红指示灯熄灭，OUT口输出高电平。</p><p>每个小板前面对应的电位器可以用来调整使用精度。</p><h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>代码使用的单片机型号：STC16F40K128</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &quot;headfile.h&quot;&#x2F;** OUT1 P27* OUT2 P26* OUT3 P25* OUT4 P24* 检测到黑线或悬空LED灭，输出高电平*&#x2F; int main() &#123;DisableGlobalIRQ();&#x2F;&#x2F;关闭总中断board_init();&#x2F;&#x2F;初始化寄存器&#x2F;&#x2F;总中断最后开启EnableGlobalIRQ();&#x2F;&#x2F;开启总中断    while(1)&#123;        &#x2F;&#x2F; 判断IO口电平状态if (P27 &#x3D;&#x3D; 1)        &#123;printf(&quot;OUT1 NO\r\n&quot;);&#125;if (P26 &#x3D;&#x3D; 1)&#123;printf(&quot;OUT2 NO\r\n&quot;);&#125;if (P25 &#x3D;&#x3D; 1)&#123;printf(&quot;OUT3 NO\r\n&quot;);&#125;if (P24 &#x3D;&#x3D; 1)&#123;printf(&quot;OUT4 NO\r\n&quot;);&#125;if ((P27 &#x3D;&#x3D; 0)&amp;&amp;(P26 &#x3D;&#x3D; 0)&amp;&amp;(P25 &#x3D;&#x3D; 0)&amp;&amp;(P24 &#x3D;&#x3D; 0))&#123;printf(&quot;OFF\r\n&quot;);&#125;  &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码是比较简单的，就是判断单片机IO口状态。如果IO口是高电平则表示传感器检测到黑线，否则没有检测到黑线。理解了这个原理就可以在其他型号的单片机上使用这个模块。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 硬件使用 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown学习笔记</title>
      <link href="posts/1.html"/>
      <url>posts/1.html</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown学习笔记"><a href="#Markdown学习笔记" class="headerlink" title="Markdown学习笔记"></a>Markdown学习笔记</h1><a id="more"></a><h2 id="1、代码块"><a href="#1、代码块" class="headerlink" title="1、代码块"></a>1、代码块</h2><p><strong>代码块语法：</strong></p><p>“ ``` ” 三个这个号（ESC下面的）加上想写的语言，就可以生成代码块区域</p><h2 id="2、标题"><a href="#2、标题" class="headerlink" title="2、标题"></a>2、标题</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="3、字体"><a href="#3、字体" class="headerlink" title="3、字体"></a>3、字体</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 加粗**闪电丶教主**# 代码高亮显示&#x3D;&#x3D;闪电丶教主&#x3D;&#x3D;# 删除线~~闪电丶教主~~# 斜体*闪电丶教主*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><p><strong>闪电丶教主</strong></p><h3 id="代码高亮显示"><a href="#代码高亮显示" class="headerlink" title="代码高亮显示"></a>代码高亮显示</h3><p><code>闪电丶教主</code></p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p><del>闪电丶教主</del></p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p><em>闪电丶教主</em></p><h2 id="4、引用"><a href="#4、引用" class="headerlink" title="4、引用"></a>4、引用</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 引用语法&gt;作者：闪电丶教主&gt;&gt;作者：闪电丶教主&gt;&gt;&gt;作者：闪电丶教主<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>作者：闪电丶教主</p><blockquote><p>作者：闪电丶教主</p></blockquote><blockquote><blockquote><p>作者：闪电丶教主</p></blockquote></blockquote></blockquote><h2 id="5、分割线"><a href="#5、分割线" class="headerlink" title="5、分割线"></a>5、分割线</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 分割线 比较常用---# 分割线2***<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><hr><h2 id="6、图片插入"><a href="#6、图片插入" class="headerlink" title="6、图片插入"></a>6、图片插入</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 在线图片 # 本地图片![图片名称](图片路径)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/posts/1/666.png" alt="测试图片"></p><p><img src="/posts/1/%E5%B0%8F%E6%81%B6%E9%AD%94.png" alt="就这¿"></p><h2 id="7、超链接"><a href="#7、超链接" class="headerlink" title="7、超链接"></a>7、超链接</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 超链接[名称](地址)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="8、列表语法"><a href="#8、列表语法" class="headerlink" title="8、列表语法"></a>8、列表语法</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 无序列表- 目录1- 目录2- 目录3# 1+. +名称1. 闪电丶教主<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>目录1</li><li>目录2</li><li>目录3</li></ul><ol><li>闪电丶教主</li></ol><h2 id="9、表格"><a href="#9、表格" class="headerlink" title="9、表格"></a>9、表格</h2><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>6</td><td>6</td><td>6</td></tr><tr><td>6</td><td>6</td><td>6</td></tr><tr><td>6</td><td>6</td><td>6</td></tr></tbody></table><p>ctrl+/ 查看源代码</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
